# 微信小程序概述

## 1、了解项目的基本组成结构

![1647781937462](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647781937462.png)

1、pages用来存放所有小程序的页面

2、utils用来存放工具性质的模块（例如：格式化时间的自定义模块）

3、app.js小程序项目的入口文件

4、app.json小程序项目的全局配置文件

5、app.wxss小程序项目的全局样式文件

6、project.config.json项目的配置文件

7、sitemap.json用来配置小程序及其页面是否允许被微信索引

![1647782362241](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647782362241.png)

pages中每个页面由4个基本文件组成，分别为：

.js文件：页面的脚本文件，存放页面的数据、事件处理函数等

.json文件：当前页面的配置文件，配置窗口的外观、表现等

.wxml文件：页面的模板结构文件

.wxss文件：当前页面的样式表文件

#### 1、JSON配置文件的作用

JSON 是一种数据格式，在实际开发中，JSON 总是以配置文件的形式出现。

小程序项目中也不例外：通过不同的 .json 配置文件，可以对小程序项目进行不同级别的配置。

小程序项目中有 4 种 json 配置文件，分别是：

~~~
项目根目录中的 app.json 配置文件
项目根目录中的 project.config.json 配置文件
项目根目录中的 sitemap.json 配置文件
每个页面文件夹中的 .json 配置文件
~~~

##### 1、app.json

app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部 tab 等。Demo 项目里边的 app.json 配置内容如下：

![1647782588555](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647782588555.png)

简单了解下这 4 个配置项的作用：

~~~
pages：用来记录当前小程序所有页面的路径
window：全局定义小程序所有页面的背景色、文字颜色等
style：全局定义小程序组件所使用的样式版本
sitemapLocation：用来指明 sitemap.json 的位置
~~~

##### 2、project.config.json

project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如：

 ~~~
setting 中保存了编译相关的配置
projectname 中保存的是项目名称
appid 中保存的是小程序的账号 ID
 ~~~

##### 3、sitemap.json

**sitemap.json 文件用来配置小程序页面是否允许微信索引**。

当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。

当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。

注意：sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件 

project.config.json 的 setting 中配置字段 checkSiteMap 为 false

#### 2、pages

只需要在 app.json -> pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件

![1647782829790](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647782829790.png)

只需要调整 app.json -> pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的

页面，当作项目首页进行渲染

![1647782859954](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647782859954.png)

#### 3、WXML概述

WXML（WeiXin Markup Language）是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作

用类似于网页开发中的 HTML。

##### 1、WXML 和 HTML 的区别

- **标签名称不同**

HTML （div, span, img, a）

WXML（view, text, image, navigator）

- **属性节点不同**

~~~
<a href='#'>超链接</a>
<navigator url="/pages/home/home"></navigator>
~~~

- **提供了类似于 Vue 中的模板语法** 

 数据绑定、列表渲染、条件渲染 

#### 4、WXSS概述

 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。 

##### 1、WXSS和CSS的区别

- **新增了 rpx 尺寸单位** 

CSS 中需要手动进行像素单位换算，例如 rem 

WXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算 

- **提供了全局的样式和局部样式**

项目根目录中的 app.wxss 会作用于所有小程序页面

局部页面的 .wxss 样式仅对当前页面生效  

- **WXSS 仅支持部分 CSS 选择器** 

.class 和 #id

element

并集选择器、后代选择器

::after 和 ::before 等伪类选择器 

#### 5、.js文件

 一个项目仅仅提供界面展示是不够的，在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户

的点击、获取用户的位置等等。 

小程序中的 JS 文件分为三大类，分别是： 

① app.js：是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序

② 页面的 .js 文件：是页面的入口文件，通过调用 Page() 函数来创建并运行页面

③ 普通的 .js 文件：是普通的功能模块文件，用来封装公共的函数或属性供页面使用 

## 2、宿主环境

#### 1、宿主环境概述

宿主环境（host environment）指的是程序运行所必须的依赖环境。

例如： Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的，所

以， Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！ 

![1647826702057](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647826702057.png)

 **手机微信是小程序的宿主环境** 

![1647826736306](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647826736306.png)

 小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能 

#### 2、小程序宿主环境包含的内容 

 ① 通信模型 ② 运行机制 ③ 组件 ④ API 

##### 1、通信的主体

小程序中通信的主体是**渲染层和逻辑层**，其中： 

① WXML 模板和 WXSS 样式工作在渲染层 ② JS 脚本工作在逻辑层 

![1647826929109](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647826929109.png)

##### 2、小程序的通信模型

 小程序中的通信模型分为两部分： 

① 渲染层和逻辑层之间的通信：由微信客户端进行转发 

② 逻辑层和第三方服务器之间的通信：由微信客户端进行转发 

![1647826988131](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647826988131.png)

##### 3、小程序启动的过程

① 把小程序的代码包下载到本地 

② 解析 app.json 全局配置文件 

③ 执行 app.js 小程序入口文件，调用 App() 创建小程序实例 

④ 渲染小程序首页 

⑤ 小程序启动完成 

##### 4、页面渲染的过程

① 加载解析页面的 .json 配置文件 

② 加载页面的 .wxml 模板和 .wxss 样式 

③ 执行页面的 .js 文件，调用 Page() 创建页面实例 

④ 页面渲染完成 

##### 5、小程序中的组件

 小程序中的组件也是**由宿主环境提供的** 

分为以下9类： ① 视图容器 ② 基础内容 ③ 表单组件 ④ 导航组件 ⑤ 媒体组件 ⑥ map 地图组件 ⑦ canvas 画布组件 ⑧ 开放能力 ⑨ 无障碍访问 

###### 1、常用视图容器类组件

**① view**

​	普通视图区域 

​	类似于 HTML 中的 div，是一个块级元素

​	常用来实现页面的布局效果 

**② scroll-view**

​	可滚动的视图区域

​	常用来实现滚动列表效果

**③ swiper 和 swiper-item** 

​	轮播图容器组件 和 轮播图 item 组件 

###### View组件的基本使用

 实现如图的 flex 横向布局效果 ：

![1647827262528](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647827262528.png)

实现如图的纵向滚动效果：

![1647827824998](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647827824998.png)

<!-- 实现纵向滚动效果 -->

<!-- scroll-y属性：允许纵向滚动 -->

<!-- scroll-x属性：允许横向滚动 -->

<!-- 注意：使用竖向滚动时，必须给scroll-view一个固定高度 -->

###### swiper 和 swiper-item 组件的基本使用  

**轮播图容器组件 和 轮播图 item 组件** 

![1647828268449](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647828268449.png)

###### swiper 组件的常用属性 

| **属性**               | **类型** | **默认值**        | **说明**             |
| ---------------------- | -------- | ----------------- | -------------------- |
| indicator-dots         | boolean  | false             | 是否显示面板指示点   |
| indicator-color        | color    | rgba(0, 0, 0, .3) | 指示点颜色           |
| indicator-active-color | color    | #000000           | 当前选中的指示点颜色 |
| autoplay               | boolean  | false             | 是否自动切换         |
| interval               | number   | 5000              | 自动切换时间间隔     |
| circular               | boolean  | false             | 是否采用衔接滑动     |

###### 2、常用的基础内容组件  

 ① text

​	文本组件

​	类似于 HTML 中的 span 标签，是一个行内元素 

② rich-text 

​	富文本组件

​	支持把 HTML 字符串渲染为 WXML 结构 

###### text组件的基本使用

1、通过 text 组件的 **selectable** 属性，实现长按选中文本内容的效果 

![1647828889732](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647828889732.png)

2、通过 **rich-text** 组件的 **nodes** 属性节点，把 HTML 字符串渲染为对应的 UI 结构 

![1647828959338](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647828959338.png)

###### 3、其他常用组件

**① button**

- 按钮组件

- 功能比 HTML 中的 button 按钮丰富

- 通过 **open-type** 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等） 

![1647829193215](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647829193215.png)

**② image**

- 图片组件

- image 组件默认宽度约 300px、高度约 240px 

![1647829604789](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647829604789.png)

image 组件的 **mode** 属性用来**指定图片的裁剪和缩放模式**，常用的 mode 属性值如下：  

| **mode** **值** | **说明**                                                     |
| --------------- | ------------------------------------------------------------ |
| scaleToFill     | （默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 |
| aspectFit       | 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 |
| aspectFill      | 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 |
| widthFix        | 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变         |
| heightFix       | 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变         |

**③ navigator**（后面课程会专门讲解）

- 页面导航组件

- 类似于 HTML 中的 a 链接 

#### 3、小程序API概述

小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API，开发者可以方便的调用微信提供的能

力， 例如：获取用户信息、本地存储、支付功能等。 

**小程序官方把 API 分为了如下 3 大类：** 

**① 事件监听 API** 

特点：以 on 开头，用来监听某些事件的触发

举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件 

**② 同步 API**

特点1：以 Sync 结尾的 API 都是同步 API

特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常

举例：wx.setStorageSync('key', 'value') 向本地存储中写入内容 

**③ 异步 API**

特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果

举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据 

## 3、协同工作和发布

![1647830166710](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647830166710.png)

![1647830174013](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647830174013.png)

#### 小程序的版本

| **版本阶段** | **说明**                                                     |
| ------------ | ------------------------------------------------------------ |
| 开发版本     | 使用开发者工具，可将代码上传到开发版本中。 开发版本只保留每人最新的一份上传的代码。点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 |
| 体验版本     | 可以选择某个开发版本作为体验版，并且选取一份体验版。         |
| 审核中的版本 | 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 |
| 线上版本     | 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。 |

#### 小程序的发布

##### 1、上传代码

① 点击开发者工具顶部工具栏中的“上传” 按钮 

② 填写版本号以及项目备注 

![1647830276163](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647830276163.png)

获取小程序码的 5 个步骤：
登录小程序管理后台 -> 设置 -> 基本设置 -> 基本信息 -> 小程序码及线下物料下载

# 小程序模板与配置

## 1、WXML模板语法

#### 1、数据绑定的基本原则

① 在 data 中定义数据 

② 在 WXML 中使用数据 

##### 1.1在 data 中定义页面的数据  

在页面对应的.js文件中，把数据定义到 data 对象中即可：

~~~
Page({

  /**
   * 页面的初始数据
   */
  data: {
    // 字符串类型的数据
    info:'init data',
    // 数组类型的数据
    msgList:[{msg:'hello'},{msg:'world'}]
  },
})
~~~

##### 1.2在WXML中使用数据

######  Mustache 语法的格式 

 **把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可**。语法格式为： 

~~~
<view>{{ 要绑定的数据名称 }}</view>
~~~

 Mustache 语法的主要应用场景如下：

- 绑定内容

- 绑定属性

- 运算（三元运算、算术运算等） 

**1、动态绑定内容**

页面的数据：

~~~
Page({
	data:{
		info:'init data'
	}
})
~~~

页面的结构：

~~~
<view>{{ info }}</view>
~~~

**2、动态绑定属性**

页面的数据：

~~~
Page({
	data:{
		imgSrc: 'http://www.itheima.com/images/logo.png'
	}
})
~~~

页面的结构：

~~~
<image src="{{imgSrc}}"></image>
~~~

**3、三元运算**

页面的数据：

~~~
Page({
	data:{
		// 生成10以内的随机数
		randomNum: Math.random()*10
	}
})
~~~

页面的结构：

~~~
<view>{{ randomNum >= 5 ? '随机数大于等于5' : '随机数小于5'}}</view>
~~~

**4、算数运算**

页面的数据：

~~~
Page({
	data:{
    	// 生成一个带两位小数的随机数
		randomNum1: Math.random().toFixed(2)
	}
})
~~~

页面的结构：

~~~
<view>生成100以内的随机数：{{randomNum * 100}}</view>
~~~

#### 2、事件绑定

事件：是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理。

![1647832864143](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647832864143.png)

**小程序常用事件：**

| **类型** | **绑定方式**              | **事件描述**                                    |
| -------- | ------------------------- | ----------------------------------------------- |
| tap      | bindtap 或 bind:tap       | 手指触摸后马上离开，类似于 HTML 中的 click 事件 |
| input    | bindinput 或 bind:input   | 文本框的输入事件                                |
| change   | bindchange 或 bind:change | 状态改变时触发                                  |

**当事件回调触发的时候，会收到一个事件对象 event，它的详细属性如下表所示：** 

| **属性**       | **类型** | **说明**                                     |
| -------------- | -------- | -------------------------------------------- |
| type           | String   | 事件类型                                     |
| timeStamp      | Integer  | 页面打开到触发事件所经过的毫秒数             |
| **target       | Object   | 触发事件的组件的一些属性值集合               |
| currentTarget  | Object   | 当前组件的一些属性值集合                     |
| **detail       | Object   | 额外的信息                                   |
| touches        | Array    | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches | Array    | 触摸事件，当前变化的触摸点信息的数组         |

###### target 和 currentTarget 的区别  

- **target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件 **

![1647845806452](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647845806452.png)

**点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发外层 view 的 tap 事件处理函数。** 

此时，对于外层的 view 来说：

e.target 指向的是触发事件的源头组件，因此，e.target 是内部的按钮组件

e.currentTarget 指向的是当前正在触发事件的那个组件，因此，e.currentTarget 是当前的 view 组件 

##### 2.1 bindtap 的语法格式 

通过 tap 事件来响应用户的触摸行为 

 ① 通过 bindtap，可以为组件绑定 tap 触摸事件，语法如下： 

![1647845979917](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647845979917.png)

 ② 在页面的 .js 文件中定义对应的事件处理函数，**事件参数通过形参 event（一般简写成 e） 来接收**： 

![1647846004746](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647846004746.png)

在事件处理函数中为 data 中的数据赋值：

通过**调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值，**示例如下 

![1647846289857](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647846289857.png)

##### 2.2 事件传参

小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码将不能

正常工作： 

![1647846724756](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647846724756.png)

因为小程序会把 bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为 btnHandler(123) 的

事件处理函数。 

**可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字，示例代码如下： **

![1647846789905](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647846789905.png)

最终：

- info 会被解析为参数的名字

- 数值 2 会被解析为参数的值 

在事件处理函数中，**通过 event.target.dataset.参数名即可获取到具体参数的值**，示例代码如下： 

![1647846851880](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647846851880.png)

##### 2.3  bindinput 的语法格式 

在小程序中，通过 **input 事件来响应文本框的输入事件**，语法格式如下： 

① 通过 bindinput，可以为文本框绑定输入事件： 

![1647847190672](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647847190672.png)

 ② 在页面的 .js 文件中定义事件处理函数： 

**e.detail.value是文本框变化后，最新的值**

![1647847204742](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647847204742.png)

##### 2.4 实现文本框与data之间的数据同步：

实现步骤： ① 定义数据 ② 渲染结构 ③ 美化样式 ④ 绑定 input 事件处理函数 

1. 定义数据

   ![1647847607218](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647847607218.png)

2. 渲染结构

   ![1647847628241](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647847628241.png)

3. 美化样式

   ![1647847661950](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647847661950.png)

4. 绑定input事件处理函数

   ![1647847683754](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647847683754.png)

#### 3、条件渲染

##### 3.1wx:if

在小程序中，使用 **wx:if="{{condition}}" 来判断是否需要渲染该代码块**： 

![1647848026904](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647848026904.png)

也可以用 wx:elif 和 wx:else 来添加 else 判断： 

![1647848052357](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647848052357.png)

######  结合<block 标签使用 wx:if 

~~~
<block></block>
~~~

如果要**一次性控制多个组件的展示与隐藏**，可以使用一个**block标签**将多个组件包装起来，并在block标签上

使用 wx:if控制属性，示例如下： 

![1647848406753](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647848406753.png)

注意：block标签并不是一个组件，它只是一个包裹性质的容器，**不会在页面中做任何渲染。** 

##### 3.2  hidden 

 在小程序中，直接使用 **hidden="{{ condition }}"** 也能控制元素的显示与隐藏： 

![1647848521820](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647848521820.png)

##### 3.3  wx:if 与 hidden 的对比  

 ① 运行方式不同

- **wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏**

- **hidden 以切换样式的方式（display: none/block;），控制元素的显示与隐藏** 

② 使用建议

- 频繁切换时，建议使用 hidden

- 控制条件复杂时，建议使用 wx:if 搭配 wx:elif、wx:else 进行展示与隐藏的切换 

##### 3.4 wx:for

通过 wx:for 可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：  

![1647848715479](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647848715479.png)

默认情况下，**当前循环项的索引用 index 表示；当前循环项用 item 表示。** 

**手动指定索引和当前项的变量名* **

- **使用 wx:for-index 可以指定当前循环项的索引的变量名**

- **使用 wx:for-item 可以指定当前项的变量名** 

![1647849358854](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647849358854.png)

##### 3.5  wx:key 的使用 

类似于 Vue 列表渲染中的 :key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的 key 值， 

从而提高渲染的效率，示例代码如下： 

![1647849487182](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647849487182.png)

## 2、WXSS模板样式

**WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。** 

#### 1、WXSS 和 CSS 的关系  

 WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。 与 CSS 相比，WXSS 扩展的特性有：

1. **rpx 尺寸单位** 
2. **@import 样式导入**  

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647849932237.png" alt="1647849932237" style="zoom:50%;" />

#### 2、rpx 尺寸单位  

 rpx（responsive pixel）是微信小程序独有的，用来**解决屏适配的尺寸单位** 

**rpx实现原理**

rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕， 在宽度上等分为 750 份（即：当前屏幕的总宽度为 750rpx）。

- 在较小的设备上，1rpx 所代表的宽度较小

- 在较大的设备上，1rpx 所代表的宽度较大 

小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适

配。 

rpx和px之间的单位换算

在 iPhone6 上，屏幕宽度为375px，共有 750 个物理像素，等分为 750rpx。则： 

750rpx = 375px = 750 物理像素 

1rpx = 0.5px = 1物理像素 

| **设备**     | **rpx****换算****px (****屏幕宽度****/750)** | **px****换算****rpx (750/****屏幕宽度****)** |
| ------------ | -------------------------------------------- | -------------------------------------------- |
| iPhone5      | 1rpx = 0.42px                                | 1px = 2.34rpx                                |
| iPhone6      | **1rpx** **=** **0.5px**                     | 1px = 2rpx                                   |
| iPhone6 Plus | 1rpx = 0.552px                               | 1px = 1.81rpx                                |

 开发举例：在 iPhone6 上如果要绘制**宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx 和 40rpx** 

#### 3、样式导入

使用 WXSS 提供的 **@import 语法**，可以导入外联的样式表。 

**@import语法格式：**

@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。示例如下： 

![1647850264549](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647850264549.png)

##### 3.1全局样式

定义**在 app.wxss 中的样式为全局样式**，作用于每一个页面。

##### 3.2局部样式

在**页面的 .wxss 文件中定义的样式为局部样式**，只作用于当前页面。 

注意： 

① 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式 

② 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式 

## 3、全局配置

#### 1、全局配置文件及常用的配置项 

小程序根目录下的 app.json 文件是小程序的全局配置文件。

常用的配置项如下： 

**① pages**

- 记录当前小程序所有页面的存放路径 

**② window**

- 全局设置小程序窗口的外观 

**③ tabBar**

- 设置小程序底部的 tabBar 效果 

**④ style**

- 是否启用新版的组件样式 

**小程序窗口的组成：**

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647850738889.png" alt="1647850738889" style="zoom:50%;" />

#### 2、window 节点常用的配置项 

| **属性名**                   | **类型** | **默认值** | **说明**                                       |
| ---------------------------- | -------- | ---------- | ---------------------------------------------- |
| navigationBarTitleText       | String   | 字符串     | 导航栏标题文字内容                             |
| navigationBarBackgroundColor | HexColor | #000000    | 导航栏背景颜色，如 #000000                     |
| navigationBarTextStyle       | String   | white      | 导航栏标题颜色，仅支持 black / white           |
| backgroundColor              | HexColor | #ffffff    | 窗口的背景色                                   |
| backgroundTextStyle          | String   | dark       | 下拉 loading 的样式，仅支持 dark / light       |
| enablePullDownRefresh        | Boolean  | false      | 是否全局开启下拉刷新                           |
| onReachBottomDistance        | Number   | 50         | 页面上拉触底事件触发时距页面底部距离，单位为px |

##### 2.1 全局开启**下拉刷新**功能

概念：下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的

行为。 

设置步骤：app.json -> window -> 把 **enablePullDownRefresh** 的值设置为 true 

注意：在 app.json 中启用下拉刷新功能，会作用于每个小程序页面！ 

##### 2.2 设置下拉刷新时窗口的背景色：

当全局开启下拉刷新功能之后，默认的窗口背景为白色。如果**自定义下拉刷新窗口背景色**，设置步骤为: 

app.json -> window -> 为 **backgroundColor** 指定16进制的颜色值 #efefef。效果如下： 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647851819204.png" alt="1647851819204" style="zoom:50%;" />

##### 2.3 设置下拉刷新时 loading 的样式 

当全局开启下拉刷新功能之后，默认窗口的 loading 样式为白色，如果**要更改 loading 样式的效果**，设置步 

骤为 app.json -> window -> 为 **backgroundTextStyle** 指定 dark 值。效果如下：  

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647851830523.png" alt="1647851830523" style="zoom:50%;" />

**注意： backgroundTextStyle 的可选值只有 light 和 dark **

##### 2.4 设置上拉触底的距离 

概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。 

设置步骤： app.json -> window -> 为 **onReachBottomDistance** 设置新的数值 

注意：**默认距离为50px**，如果没有特殊需求，建议使用默认值即可。 

#### 3、tabBar

tabBar 是移动端应用常见的页面效果，用于实现多页面 的快速切换。

**小程序中通常将其分为：底部tabBar 、顶部 tabBar**  

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647852062166.png" alt="1647852062166" style="zoom:%;" />![1647852074847](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647852074847.png)

注意：

- tabBar中只能配置最少 2 个、最多 5 个 tab 页签

- **当渲染顶部 tabBar 时，不显示 icon，只显示文本** 

##### 3.1 tabBar 的 6 个组成部分 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647852627224.png" alt="1647852627224" style="zoom:50%; margin:0" />

① backgroundColor：tabBar 的背景色

② selectedIconPath：选中时的图片路径 

③ borderStyle：tabBar 上边框的颜色 

④ iconPath：未选中时的图片路径 

⑤ selectedColor：tab 上的文字选中时的颜色 

⑥ color：tab 上文字的默认（未选中）颜色 

##### 3.2 tabBar节点的配置项

| **属性**        | **类型**  | **必填** | **默认值** | **描述**                                     |
| --------------- | --------- | -------- | ---------- | -------------------------------------------- |
| **position**    | String    | 否       | bottom     | **tabBar 的位置，仅支持 bottom/top**         |
| borderStyle     | String    | 否       | black      | tabBar 上边框的颜色，仅支持 black/white      |
| color           | HexColor  | 否       |            | tab 上文字的默认（未选中）颜色               |
| selectedColor   | HexColor  | 否       |            | tab 上的文字选中时的颜色                     |
| backgroundColor | HexColor  | 否       |            | tabBar 的背景色                              |
| **list**        | **Array** | **是**   |            | **tab 页签的列表，最少 2 个、最多 5 个 tab** |

##### 3.3 每个tab项的配置项

| **属性**         | **类型** | **必填** | **描述**                                              |
| ---------------- | -------- | -------- | ----------------------------------------------------- |
| pagePath         | String   | 是       | **页面路径，页面必须在 pages 中预先定义**             |
| text             | String   | 是       | tab 上显示的文字                                      |
| iconPath         | String   | 否       | 未选中时的图标路径；当 postion 为 top 时，不显示 icon |
| selectedIconPath | String   | 否       | 选中时的图标路径；当 postion 为 top 时，不显示 icon   |

##### 3.4 配置tabBar

① 打开 app.json 配置文件，和 pages、window 平级，**新增 tabBar 节点** 

② **tabBar 节点中，新增 list 数组，这个数组中存放的，是每个 tab 项的配置对象** 

③ 在 list 数组中，新增每一个 tab 项的配置对象。对象中包含的属性如下：

1. **pagePath 指定当前 tab 对应的页面路径【必填】**
2. **text 指定当前 tab 上按钮的文字【必填】**
3. **iconPath 指定当前 tab 未选中时候的图片路径【可选】**
4. **selectedIconPath 指定当前 tab 被选中后高亮的图片路径【可选】** 

app.json的tabBar节点中：

~~~
"tabBar": {
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "images/tabs/home.png",
        "selectedIconPath": "images/tabs/home-active.png"
      },
      {
        "pagePath": "pages/msg/msg",
        "text": "消息",
        "iconPath": "images/tabs/message.png",
        "selectedIconPath": "images/tabs/message-active.png"
      },
      {
        "pagePath": "pages/my/my",
        "text": "联系我们",
        "iconPath": "images/tabs/contact.png",
        "selectedIconPath": "images/tabs/contact-active.png"
      }
    ]
  },
~~~

图片名称中包含 -active 的是选中之后的图标 

图片名称中不包含 -active 的是默认图标 

## 4、页面配置

#### 1、页面配置文件的作用 

 小程序中，每个页面都有自己的 .json 配置文件，用**来对当前页面的窗口外观、页面效果等进行配置。** 

#### 2、页面配置和全局配置的关系  

小程序中，**app.json 中的 window 节点，可以全局配置小程序中每个页面的窗口表现。**

如果**某些小程序页面想要拥有特殊的窗口表现**，此时，“页面级别的 .json 配置文件”就可以实现这种需求。 

注意：**当页面配置与全局配置冲突时**，根据就近原则，最终的效果**以页面配置为准**。 

#### 3、页面配置中常用的配置项 

| **属性**                     | **类型** | **默认值** | **描述**                                         |
| ---------------------------- | -------- | ---------- | ------------------------------------------------ |
| navigationBarBackgroundColor | HexColor | #000000    | 当前页面导航栏背景颜色，如 #000000               |
| navigationBarTextStyle       | String   | white      | 当前页面导航栏标题颜色，仅支持 black / white     |
| navigationBarTitleText       | String   |            | 当前页面导航栏标题文字内容                       |
| backgroundColor              | HexColor | #ffffff    | 当前页面窗口的背景色                             |
| backgroundTextStyle          | String   | dark       | 当前页面下拉 loading 的样式，仅支持 dark / light |
| enablePullDownRefresh        | Boolean  | false      | 是否为当前页面开启下拉刷新的效果                 |
| onReachBottomDistance        | Number   | 50         | 页面上拉触底事件触发时距页面底部距离，单位为 px  |

## 5、网络数据请求

#### 1、小程序中网络数据请求的限制 

出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制： 

① 只能请求 **HTTPS 类型**的接口 

② 必须将**接口的域名**添加到信任列表中 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647855549220.png" alt="1647855549220" style="zoom:50%;margin:0" />

#### 2、配置 request 合法域名  

需求描述：假设在自己的微信小程序中，希望请求 https://www.escook.cn/ 域名下的接口 

配置步骤：登录微信小程序管理后台 -> 开发 -> 开发设置 -> 服务器域名 -> 修改 request 合法域名 

注意事项： 

​	① 域名只支持 https 协议 

​	② 域名不能使用 IP 地址或 localhost 

​	③ 域名必须经过 ICP 备案 

​	④ 服务器域名一个月内最多可申请 5 次修改 

#### 3、发起GET请求

调用微信小程序提供的 **wx.request()** 方法，**可以发起 GET 数据请求**，示例代码如下： 

![1647855922227](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647855922227.png)

#### 4、发起POST请求

调用微信小程序提供的 **wx.request()** 方法，**可以发起 POST 数据请求**，示例代码如下： 

![1647856150313](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647856150313.png)

#### 5、在页面刚加载时请求数据 

**需要在页面刚加载的时候，自动请求一些初始化的数据。**此时需要在页面的 **onLoad 事件**中**调用获取数据的**

**函数**，示例代码如下： 

![1647859947092](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647859947092.png)

#### 6、跳过 request 合法域名校验 

如果后端程序员仅仅提供了 http 协议的接口、暂时没有提供 https 协议的接口。 此时为了不耽误开发的进

度，我们可以在微信开发者工具中，临时开启「开发环境不校验请求域名、TLS 版本及 HTTPS 证书」选

项， 跳过 request 合法域名的校验。  

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647860076305.png" alt="1647860076305" style="zoom:50%;margin:0" />

 注意： 跳过 request 合法域名校验的选项，**仅限在开发与调试阶段使用！** 

#### 7、关于跨域和 Ajax 的说明  

跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，**所以小** 

**程序中不存在跨域的问题。** **Ajax 技术的核心是依赖于浏览器中的 XMLHttpRequest 这个对象**，由于小程序

的宿主环境是微信客户端，所 以**小程序中不能叫做“发起 Ajax 请求”，而是叫做“发起网络数据请求”。** 

## 6、案例-本地生活（首页）

#### 1、页面效果及实现步骤

<p>
    ① 新建项目并梳理项目结构 

② 配置导航栏效果 

③ 配置 tabBar 效果 

④ 实现轮播图效果 

⑤ 实现九宫格效果 

⑥ 实现图片布局

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647860377096.png" alt="1647860377096" style="zoom:80%; margin:0"/>

#### 2、接口地址

① 获取轮播图数据列表的接口 

【GET】https://www.escook.cn/slides 

② 获取九宫格数据列表的接口 

【GET】https://www.escook.cn/categories 

## 7、总结

① 能够使用 WXML 模板语法渲染页面结构 

- **wx:if、wx:elif、wx:else、hidden、wx:for、wx:key** 

② 能够使用 WXSS 样式美化页面结构 

- **rpx 尺寸单位、@import 样式导入、全局样式和局部样式** 

③ 能够使用 app.json 对小程序进行全局性配置

- **pages、window、tabBar、style** 

④ 能够使用 page.json 对小程序页面进行个性化配置 

- **对单个页面进行个性化配置、就近原则** 

⑤ 能够知道如何发起网络数据请求 

- **wx.request() 方法、onLoad() 事件** 

#### 隐藏控制台黄色警告：

project.config.json中的settings节点中添加："checkSiteMap":false

# 小程序视图与逻辑

## 1、页面导航

#### 1、页面导航概述

**页面导航指的是页面之间的相互跳转。**例如，浏览器中实现页面导航的方式有如下两种： 

①  链接 ② location.href 

#### 2、小程序中实现页面导航的两种方式 

**① 声明式导航**

- 在页面上声明一个<navigator>导航组件

- 通过点击<navigator>组件实现页面跳转 

**② 编程式导航**

- 调用小程序的导航 API，实现页面的跳转 

##### 2.1 声明式导航

###### 1、导航到tabBar页面

**tabBar 页面指的是被配置为 tabBar 的页面。** 

在使用<navigator>组件跳转到指定的 tabBar 页面时，**需要指定 url 属性和 open-type 属性**，其中：  

- **url 表示要跳转的页面的地址，必须以 / 开头**

- **open-type 表示跳转的方式，必须为 switchTab** 

示例代码如下： 

![1647913276648](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647913276648.png)

###### 2、导航到非 tabBar 页面 

非 tabBar 页面指的是**没有被配置为 tabBar 的页面。** 

在使用<navigator>组件跳转到普通的非 tabBar 页面时，则需要**指定 url 属性和 open-type 属性**，其中：

- **url 表示要跳转的页面的地址，必须以 / 开头** 

- **open-type 表示跳转的方式，必须为 navigate**  

示例代码如下：

![1647914363622](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647914363622.png)

注意：为了简便，**在导航到非 tabBar 页面时，open-type="navigate" 属性可以省略。** 

###### 3、后退导航 

如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中： 

- **open-type 的值必须是 navigateBack，表示要进行后退导航**

- **delta 的值必须是数字，表示要后退的层级** 

示例代码如下：  

![1647914481646](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647914481646.png)

注意：为了简便，**如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1。** 

##### 2.2 编程式导航

###### 1、导航到tabBar页面

- **调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。**

其中 Object 参数对象的属性列表如下：

| **属性** | **类型** | **是否必选** | **说明**                                         |
| -------- | -------- | ------------ | ------------------------------------------------ |
| url      | string   | 是           | 需要跳转的 tabBar 页面的路径，路径后不能带参数   |
| success  | function | 否           | 接口调用成功的回调函数                           |
| fail     | function | 否           | 接口调用失败的回调函数                           |
| complete | function | 否           | 接口调用结束的回调函数（调用成功、失败都会执行） |

示例代码：

![1647914747275](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647914747275.png)

###### 2、导航到非tabBar页面

- **调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。**

其中 Object 参数对象的属性列表如下： 

| **属性** | **类型** | **是否必选** | **说明**                                           |
| -------- | -------- | ------------ | -------------------------------------------------- |
| url      | string   | 是           | 需要跳转到的非 tabBar 页面的路径，路径后可以带参数 |
| success  | function | 否           | 接口调用成功的回调函数                             |
| fail     | function | 否           | 接口调用失败的回调函数                             |
| complete | function | 否           | 接口调用结束的回调函数（调用成功、失败都会执行）   |

示例代码：

![1647915048406](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647915048406.png)

###### 3、后退导航 

**调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。**

其中 Object 参数对象可选的属性列表如下： 

| **属性**  | **类型** | **默认值** | 是否必选**** | **说明**                                              |
| --------- | -------- | ---------- | ------------ | ----------------------------------------------------- |
| **delta** | number   | 1          | 否           | 返回的页面数，如果 delta 大于现有页面数，则返回到首页 |
| success   | function |            | 否           | 接口调用成功的回调函数                                |
| fail      | function |            | 否           | 接口调用失败的回调函数                                |
| complete  | function |            | 否           | 接口调用结束的回调函数（调用成功、失败都会执行）      |

示例代码：

![1647915699645](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647915699645.png)

##### 2.3 导航传参

###### 1、声明式导航传参

**navigator 组件的 url 属性用来指定将要跳转到的页面的路径。**

同时，**路径的后面还可以携带参数：**

- **参数与路径之间使用 ? 分隔** 
- **参数键与参数值用 = 相连**
- **不同参数用 & 分隔** 

代码示例如下： 

![1647916057961](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647916057961.png)

###### 2、编程式导航传参 

**调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数，**代码示例如下 ：

![1647916348097](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647916348097.png)

###### 3、在 onLoad 中接收导航参数  

通过**声明式导航传参或编程式导航传参所携带的参数**，可以**直接在 onLoad 事件中直接获取到**，示例代

码如下： 

![1647916669700](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647916669700.png)

## 2、页面事件

#### 1、下拉刷新事件

**下拉刷新**是移动端的专有名词，**指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为**。 

##### 1.1 启用下拉刷新：

**① 全局开启下拉刷新** 

- 在 **app.json 的 window 节点中**，将 **enablePullDownRefresh 设置为 true** 

**② 局部开启下拉刷新**

- 在**页面的 .json 配置文件**中，将 **enablePullDownRefresh 设置为 true** 

在实际开发中 ，推荐使用第 2 种方式，为需要的页面单独开启下拉刷新的效果。 

##### 1.2 配置下拉刷新窗口的样式 

在全局或页面的 .json 配置文件中，通过 **backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口的样**

**式**，其中：

- **backgroundColor 用来配置下拉刷新窗口的背景颜色**，仅支持16 进制的颜色值 

- **backgroundTextStyle 用来配置下拉刷新 loading 的样式**，**仅支持 dark 和 light** 

##### 1.3 监听页面的下拉刷新事件  

在页面的 .js 文件中，通过 **onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。** 

例如，在页面的wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增 +1： 

![1647917378620](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647917378620.png)

在**触发页面的下拉刷新事件的时候，如果要把 count 的值重置为 0**，示例代码如下： 

![1647917501408](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647917501408.png)

##### 1.4 停止下拉刷新的效果 

当处理完下拉刷新后，下拉刷新的 loading 效果会一直显示，不会主动消失，所以**需要手动隐藏下拉刷新**

**的 loading 效果**。此时，**调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新。**示例代码如下： 

![1647918008702](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918008702.png)

#### 2、上拉触底事件

**上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。** 

##### 1、监听页面的上拉触底事件

在页面的 .js 文件中，通过 **onReachBottom() 函数即可监听当前页面的上拉触底事件**。示例代码如下： 

![1647918479749](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918479749.png)

##### 2、配置上拉触底距离

**上拉触底距离指的是触发上拉触底事件时，滚动条距离页面底部的距离。** 

可以在全局或页面的 .json 配置文件中，**通过 onReachBottomDistance 属性来配置上拉触底的距离。** 

![1647918771586](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918771586.png)

**小程序默认的触底距离是 50px**，在实际开发中，可以根据自己的需求修改这个默认值。 

#### 3、案例

![1647918837289](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918837289.png)

案例的实现步骤：

① 定义获取随机颜色的方法 

![1647918891109](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918891109.png)

② 在页面加载时获取初始数据 

![1647918899510](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918899510.png)

③ 渲染 UI 结构并美化页面效果 

![1647918910753](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918910753.png)

④ 在上拉触底时调用获取随机颜色的方法 

![1647918919933](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918919933.png)

⑤ 添加 loading 提示效果 

![1647918930873](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647918930873.png)

⑥ 对上拉触底进行节流处理 

1. <font color='red'>在 data 中定义 isloading 节流阀 </font>

   - false 表示当前没有进行任何数据请求

   - true 表示当前正在进行数据请求 

2. <font color='red'>在 getColors() 方法中修改 isloading 节流阀的值</font>

   - 在刚调用 getColors 时将节流阀设置 true 

   - 在网络请求的 complete 回调函数中，将节流阀重置为 false 

3. <font color='red'>在 onReachBottom 中判断节流阀的值，从而对数据请求进行节流控制</font>

   - 如果节流阀的值为 true，则阻止当前请求 

   - 如果节流阀的值为 false，则发起数据请求 

###### 总结：

​	<font color='orange'>展示loading：wx.showLoading({title:'XXXX...'})</font>

​	<font color='orange'>隐藏loading：wx.hideLoading()</font>

​	<font color='orange'>complete()：在数据请求中，无论是否成功都会执行此方法的回调函数</font>			

## 3、生命周期

#### 1、生命周期概述

**生命周期（Life Cycle）是指一个对象从<font color='red'>创建 -> 运行 -> 销毁</font>的整个阶段，强调的是一个时间段。** 

##### 1.1 生命周期的分类

在小程序中，生命周期分为两类，分别是： 

<font color='orange'>① 应用生命周期</font>

- 特指<font color='cornflowerblue'>小程序从启动 -> 运行 -> 销毁的过程 </font>

<font color='orange'>② 页面生命周期 </font>

- 特指小程序中，<font color='cornflowerblue'>每个页面的加载 -> 渲染 -> 销毁的过程 </font>

其中，<font color='greenyellow'>页面的生命周期范围较小，应用程序的生命周期范围较大</font>，如图所示： 

![1647933231899](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647933231899.png)

#### 2、生命周期函数

<font color='red'>生命周期函数</font>：是由小程序框架提供的<font color='red'>内置函数</font>，会伴随着生命周期，<font color='red'>自动按次序执行。</font> 

**生命周期函数的作用：允许程序员在特定的时间点，执行某些特定的操作。**例如，页面刚加载的时候，可以

在 onLoad 生命周期函数中初始化页面的数据。 

<font color='cornflowerblue'>注意：生命周期强调的是时间段，生命周期函数强调的是时间点。 </font>

##### 2.1 生命周期函数的分类

小程序中的生命周期函数分为两类，分别是： 

① <font color='greenyellow'>应用的生命周期函数 </font>

- 特指小程序从启动 -> 运行 -> 销毁期间依次调用的那些函数 

② <font color='greenyellow'>页面的生命周期函数</font>

- 特指小程序中，每个页面从加载 -> 渲染 -> 销毁期间依次调用的那些函数 

##### 2.2 应用的生命周期函数

小程序的**<font color='orange'>应用生命周期函数需要在 app.js 中进行声明</font>**，示例代码如下： 

![1647933580472](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647933580472.png)

###### onLaunch

小程序初始化完成时，执行此函数，全局只触发一次，可以做一些初始化的工作

~~~
onLaunch:function(options){}
~~~

###### onShow

小程序启动，或从后台进入前台显示时触发

~~~
onShow():function(options){}
~~~

###### onHide

小程序从前台进入后台时触发

~~~
onHide:function(){}
~~~

##### 2.3 页面的生命周期函数

小程序的页面生命周期函数需要在页面的 .js 文件中进行声明，示例代码如下： 

![1647933996242](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647933996242.png)

###### onLoad

监听页面加载，一个页面只调用1次

###### onShow

监听页面显示

###### onReady

监听页面初次渲染完成，一个页面只调用1次

**在此可以调用wx.setNavigationBarTitle：修改当前页面的标题**

###### onHide

监听页面隐藏

###### onUnload

监听页面卸载，一个页面只调用1次

## 4、WXS脚本

#### 1、WXS脚本概述

<font color='red'>WXS</font>（WeiXin Script）是**小程序独有的一套脚本语言，结合 WXML，可以构建出页面的结构。** 

**wxml 中无法调用在页面的 .js 中定义的函数，但是，wxml 中可以调用 wxs 中定义的函数。**

因此，小程序中 wxs 的典型应用场景就是“过滤器”。 

#### 2、wxs 和 JavaScript 的关系*  

<font color='red'>① wxs 有自己的数据类型</font>

- number 数值类型、string 字符串类型、boolean 布尔类型、object 对象类型、

- function 函数类型、array 数组类型、 date 日期类型、 regexp 正则 

<font color='red'>② wxs 不支持类似于 ES6 及以上的语法形式</font>

- 不支持：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc...

- 支持：var 定义变量、普通 function 函数等类似于 ES5 的语法 

<font color='red'>③ wxs 遵循 CommonJS 规范</font> 

- module 对象 

- require() 函数

- module.exports 对象 

#### 3、WXS脚本基础语法

##### 3.1 内嵌WXS脚本

**wxs 代码可以编写在 wxml 文件中的<wxs>标签内，**就像 Javascript 代码可以编写在 html 文件中的 

<script标签内一样

wxml 文件中的每个(<wxs></wxs>)标签，<font color='red'>必须提供 module 属性</font>，<font color='red'>用来指定当前 wxs 的模块名称</font>，方便在 

wxml 中访问模块中的成员： 

![1647935599214](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647935599214.png)

示例代码：

~~~
<view>{{m1.toUpper(username)}}</view>

<wxs module="m1">
  // 将文本转为大写形式
  module.exports.toUpper=function(str){
    return str.toUpperCase()
  }
</wxs>


.js文件中：
/**
   * 页面的初始数据
   */
  data: {
    username:'zs'
  },
~~~

##### 3.2 定义外联的wxs脚本

wxs 代码还可以编写在以 **.wxs 为后缀名的文件内**，就像 javascript 代码可以编写在以 .js 为后缀名的文件中 一

样。示例代码如下： 

![1647936003528](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647936003528.png)

##### 3.3 使用外联的wxs脚本

在 wxml 中**引入外联的 wxs 脚本时**，**必须为<wxs>标签添加 module 和 src 属性，**其中：

- <font color='red'>module 用来指定模块的名称</font> 

- <font color='red'>src 用来指定要引入的脚本的路径，且必须是相对路径  </font>

示例代码如下：

![1647936245367](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647936245367.png)

#### 4、WXS的特点

###### 1、与JavaScript不同

###### 2、 不能作为组件的事件回调  

wxs 典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用，例如： 

![1647936411359](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647936411359.png)

但是，**在 wxs 中定义的函数不能作为组件的事件回调函数**。例如，下面的用法是错误的： 

![1647936425411](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647936425411.png)

###### 3、隔离性

**隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的**。

体现在如下两方面： 

<font color='red'>① wxs 不能调用 js 中定义的函数</font> 

<font color='red'>② wxs 不能调用小程序提供的 API</font> 

###### 4、性能好

在 iOS 设备上，小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍

在 android 设备上，二者的运行效率无差异 

#### 5、案例-本地生活（列表页面）

![1647936603065](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647936603065.png)

1、页面导航并传参 、上拉触底时加载下一页数据、下拉刷新列表数据 

2、以分页的形式，加载指定分类下商铺列表的数据： 

​	① 接口地址 ⚫ https://www.escook.cn/categories/:cate_id/shops 

​		URL 地址中的 :cate_id 是动态参数，表示分类的 Id 

​	② 请求方式 

​		GET 请求 

​	③ 请求参数 

​		_page 表示请求第几页的数据

​		_limit 表示每页请求几条数据 

3、判断是否还有下一页数据

**如果下面的公式成立，则证明没有下一页数据了：** 

<font color='red'>页码值 * 每页显示多少条数据 >= 总数据条数 </font>

page * pageSize >= total 

案例1：总共有 77 条数据，如果每页显示 10 条数据，则总共分为 8 页，其中第 8 页只有 7 条数据 

page（7）* pageSize（10） >= total（77） 

page（8）* pageSize（10） >= total（77） 

案例2：总共有 80 条数据，如果每页显示 10 条数据，则总共分为 8 页，其中第 8 页面有 10 条数据 

page（7）* pageSize（10） >= total（80） 

page（8）* pageSize（10） >= total（80） 

## 总结

① 能够知道如何实现页面之间的导航跳转

- 声明式导航、编程式导航 

② 能够知道如何实现下拉刷新效果 

- enablePullDownRefresh、onPullDownRefresh 

③ 能够知道如何实现上拉加载更多效果

- onReachBottomDistance、onReachBottom 

④ 能够知道小程序中常用的生命周期函数

- 应用生命周期函数：onLaunch, onShow, onHide 

- 页面生命周期函数：onLoad, onShow, onReady, onHide, onUnload 

# 小程序-基础加强

## 1、自定义组件

#### 1、自定义组件概述

##### 1.1 组件的创建与引用

###### 1、创建组件

① 在项目的根目录中，鼠标右键，**创建 components -> test 文件夹** 

② 在新建的 components -> test 文件夹上，鼠标右键，**点击“新建 Component”** 

③ <font color='red'>键入组件的名称之后回车，会自动生成组件对应的 4 个文件，后缀名分别为 .js，.json， .wxml 和 .wxss </font>

注意：为了保证目录结构的清晰，建议把不同的组件，存放到单独目录中，例如： 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647942130959.png" alt="1647942130959" style="zoom:50%;margin:0" />

###### 2、引用组件

组件的引用方式分为<font color='orange'>“局部引用”</font>和<font color='orange'>“全局引用”</font>，顾名思义：

- **局部引用：组件只能在当前被引用的页面内使用** 

- **全局引用：组件可以在每个小程序页面中使用** 

###### 3、局部引用组件

在页面的 <font color='cornflowerblue'>.json 配置文件中引用组件的方式，叫做“局部引用”</font>。示例代码如下： 

![1647942493939](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647942493939.png)

###### 4、全局引用组件

<font color='cornflowerblue'>在 app.json 全局配置文件中引用组件的方式，叫做“全局引用”。</font>示例代码如下： 

![1647942526879](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647942526879.png)

###### 5、全局引用 VS 局部引用 

根据组件的使用频率和范围，来选择合适的引用方式：

- 如果某组件在多个页面中经常被用到，建议进行“全局引用” 

- 如果某组件只在特定的页面中被用到，建议进行“局部引用” 

###### 6、组件和页面的区别

从表面来看，组件和页面都是由 .js、.json、.wxml 和 .wxss 这四个文件组成的。但是，组件和页面的 .js 与 

.json 文件有明显的不同：

1. **组件的 .json 文件中**需要声明 <font color='orange'>"component": true</font> 属性
2. **组件的 .js 文件中**调用的是 <font color='orange'>Component() </font>函数 
3. **组件的事件处理函数**需要定义到 <font color='orange'>methods</font> 节点中 

#### 2、自定义组件-样式

##### 2.1 组件样式隔离

默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构，如图所示：

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647943086418.png" alt="1647943086418" style="zoom:50%;" />

组件 A 的样式不会影响组件 C 的样式 

组件 A 的样式不会影响小程序页面的样式

小程序页面的样式不会影响组件 A 和 C 的样式 

**好处： ① 防止外界的样式影响组件内部的样式 ② 防止组件的样式破坏外界的样式** 

##### 2.2 组件样式隔离的注意点

- app.wxss 中的全局样式对组件无效

- **只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响** 

建议：<font color='red'>在组件和引用组件的页面中建议使用 class 选择器，不要使用 id、属性、标签选择器！</font> 

##### 2.3 修改组件的样式隔离选项

默认情况下，**自定义组件的样式隔离特性能够防止组件内外样式互相干扰的问题**。但有时，我们希望在外界

能够控制组件内部的样式，**此时，可以通过 styleIsolation 修改组件的样式隔离选项**，用法如下： 

![1647943556932](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647943556932.png)

######  styleIsolation 的可选值 

| **可选值**   | **默认值** | **描述**                                                     |
| ------------ | ---------- | ------------------------------------------------------------ |
| **isolated** | 是         | **表示<font color='red'>启用样式隔离</font>，在自定义组件内外，使用 class 指定的样式将不会相互影响** |
| apply-shared | 否         | 表示<font color='red'>页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面</font> |
| shared       | 否         | 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件 |

#### 3、数据、方法和属性 

##### 3.1 data数据

在小程序组件中，**用于组件模板渲染的私有数据**，**需要定义到 data 节点中**，示例如下： 

![1647943853419](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647943853419.png)

##### 3.2 methods方法

在小程序组件中，<font color='red'>事件处理函数和自定义方法需要定义到 methods 节点中</font>，示例代码如下： 

<font color='cornflowerblue'>methods方法中的自定义方法建议以_开头</font>

![1647943894428](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647943894428.png)

##### 3.3 properties属性

<font color='lime'>在小程序组件中，properties 是组件的对外属性，用来接收外界传递到组件中的数据</font>，示例代码如下： 

![1647944422250](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647944422250.png)

##### 3.4  data 和 properties 的区别  

在小程序的组件中，properties 属性和 data 数据的用法相同，它们**都是可读可写的**，只不过：

- <font color='orange'>data 更倾向于存储组件的私有数据 </font>

- <font color='lime'>properties 更倾向于存储外界传递到组件中的数据</font> 

![1647945631341](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647945631341.png)

##### 3.5 修改properties的值

**<font color='red'>使用 setData 修改 properties 的值</font>** 

由于 **data 数据和 properties 属性在本质上没有任何区别，**因此 properties 属性的值也可以用于页面渲染， 或

使用 setData 为 properties 中的属性重新赋值，示例代码如下： 

![1647945736467](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647945736467.png)

#### 4、数据监听器

<font color='red'>数据监听器用于监听和响应任何属性和数据字段的变化，从而执行特定的操作。</font>它的作用类似于 vue 中的 

**watch 侦听器**。在小程序组件中，数据监听器的基本语法格式如下： 

![1647945897529](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647945897529.png)

##### 4.1 数据监听器的基本用法 

组件的 UI 结构如下： 

![1647946057814](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946057814.png)

 组件的 .js 文件代码如下： 

![1647946072416](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946072416.png)

##### 4.2 监听对象属性的变化  

数据监听器<font color='cornflowerblue'>支持监听对象中单个或多个属性的变化</font>，示例语法如下 ：

![1647946501096](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946501096.png)

##### 4.3 数据监听器 - 案例 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946560404.png" alt="1647946560404" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946578781.png" alt="1647946578781" title="style=&quot;zoom:50%;" style="zoom:50%;" />

###### 1.渲染UI结构

![1647946667883](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946667883.png)

######  2.定义 button 的事件处理函数 

![1647946704746](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946704746.png)

######  3.监听对象中指定属性的变化 

![1647946725919](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946725919.png)

###### 4. 监听对象中所有属性的变化 

**如果某个对象中需要被监听的属性太多**，为了方便，<font color='red'>可以使用通配符 ** 来监听对象中所有属性的变化</font>，示

例代码如下： 

![1647946783506](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647946783506.png)

#### 5、纯数据字段

<font color='red'>概念：纯数据字段指的是那些不用于界面渲染的 data 字段。 </font>

应用场景：例如有些情况下，**某些 data 中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在**

**当前组件内部使用。带有这种特性的 data 字段适合被设置为纯数据字段**。 

好处：纯数据字段有助于提升页面更新的性能。 

##### 5.1 使用规则

在 **Component 构造器的 options 节点中**，**指定 <font color='lime'>pureDataPattern</font> 为一个正则表达式，字段名符合这个正则 **

**表达式的字段将成为纯数据字段**，示例代码如下： 

![1647948014234](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647948014234.png)

##### 5.2 使用纯数据字段改造数据监听器案例 

![1647948197215](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647948197215.png)

#### 6、组件的生命周期

##### 6.1 组件<font color='red'>全部的</font>生命周期函数

| **生命周期函数**                  | **参数**                               | **描述说明**                                                |
| --------------------------------- | -------------------------------------- | ----------------------------------------------------------- |
| <font color='red'>created</font>  | <font color='cornflowerblue'>无</font> | <font color='red'>在组件实例刚刚被创建时执行</font>         |
| <font color='red'>attached</font> | <font color='cornflowerblue'>无</font> | <font color='red'>在组件实例进入页面节点树时执行</font>     |
| ready                             | 无                                     | 在组件在视图层布局完成后执行                                |
| moved                             | 无                                     | 在组件实例被移动到节点树另一个位置时执行                    |
| <font color='red'>detached</font> | <font color='cornflowerblue'>无</font> | <font color='red'>在组件实例被从页面节点树移除时执行</font> |
| error                             | Object Error                           | 每当组件方法抛出错误时执行                                  |

##### 6.2 组件<font color='red'>主要的</font>生命周期函数

在小程序组件中，**<font color='orange'>最重要的生命周期函数有 3 个，分别是 created、attached、detached。</font>**

它们各自的特点 如下： 

**<font color='lime'>① 组件实例刚被创建好的时候，created 生命周期函数会被触发</font>**

**此时还不能调用 setData**

通常在这个生命周期函数中，**只应该用于给组件的 this 添加一些自定义的属性字段** 

**<font color='lime'>② 在组件完全初始化完毕、进入页面节点树后， attached 生命周期函数会被触发</font>**

此时， **this.data 已被初始化完毕**

这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行**（例如发请求获取初始数据）** 

**<font color='lime'>③ 在组件离开页面节点树后， detached 生命周期函数会被触发</font>** 

**退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数**

此时适合做一些清理性质的工作 

##### 6.3 lifetimes节点 

在小程序组件中，生命周期函数可以直接**定义在 Component 构造器的第一级参数中**，可以在 <font color='red'>lifetimes 字段</font> 

内进行声明（这是推荐的方式，**其优先级最高**）。示例代码如下： 

![1647948772427](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647948772427.png)

#### 7、组件所在页面的生命周期

**自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。** 

例如：每当触发页面的 show 生命周期函数的时候，我们希望能够重新生成一个随机的 RGB 颜色值。 

<font color='red'>在自定义组件中，组件所在页面的生命周期函数有如下 3 个</font>，分别是： 

| **生命周期函数** | **参数**    | **描述**                                                     |
| ---------------- | ----------- | ------------------------------------------------------------ |
| show             | 无          | <font color='red'>组件所在的页面</font><font color='orange'>被展示时执行</font> |
| hide             | 无          | <font color='red'>组件所在的页面</font><font color='orange'>被隐藏时执行</font> |
| resize           | Object Size | <font color='red'>组件所在的页面</font><font color='orange'>尺寸变化时执行</font> |

##### 7.1 pageLifetimes 节点 

**组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中，示例代码如下：** 

![1647949221690](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647949221690.png)

##### 7.2  生成随机的 RGB 颜色值 

![1647949384630](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647949384630.png)

#### 8、插槽

##### 8.1 插槽概述

**在自定义组件的 wxml 结构中**，<font color='red'>可以提供一个slot节点（插槽），用于承载组件使用者提供的 wxml 结构 </font>

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647950673893.png" alt="1647950673893" style="zoom:50%;" />

##### 8.2 单个插槽

在小程序中，**默认每个自定义组件中只允许使用一个slot进行占位，这种个数上的限制叫做单个插槽**。 

![1647950731325](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647950731325.png)

##### 8.3 启用多个插槽

**在小程序的自定义组件中，需要使用多slot插槽时，可以在组件的 .js 文件中，通过如下方式进行启用。** 示例

代码如下： 

![1647950776719](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647950776719.png)

##### 8.4 定义多个插槽

<font color='cornflowerblue'>可以在组件的 .wxml 中使用多个slot标签，以不同的 name 来区分不同的插槽。</font>示例代码如下： 

![1647950828537](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647950828537.png)

#### 9、父子组件之间的通信

##### 9.1 父子组件之间通信的 3 种方式 

<font color='lime'>① 属性绑定</font>

- 用于**父组件向子组件的指定属性设置数据**，仅能设置 JSON 兼容的数据 

<font color='lime'>② 事件绑定 </font>

- **用于子组件向父组件传递数据，可以传递任意数据** 

<font color='lime'>③ 获取组件实例 </font>

- **父组件还可以通过 this.selectComponent() 获取子组件实例对象**

- 这样**就可以直接访问子组件的任意数据和方法** 

###### 1、<font color='red'>属性绑定</font>——父向子

<font color='orange'>属性绑定用于实现父向子传值</font>，<font color='orange'>而且只能传递普通类型的数据</font>，<font color='orange'>无法将方法传递给子组件</font>。

父组件的示例代码如下： 

![1647951523600](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647951523600.png)

子组件在 <font color='orange'>properties 节点</font>中声明对应的属性并使用。示例代码如下： 

![1647951956310](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647951956310.png)

###### 2、事件绑定——子向父

<font color='red'>事件绑定</font>用于实现<font color='red'>子向父传值</font>，<font color='red'>可以传递任何类型的数据</font>。

使用步骤如下： 

① 在<font color='red'>父组件</font>的 js 中，定义一个函数，<font color='cornflowerblue'>这个函数即将通过自定义事件的形式，传递给子组件 </font>

② 在<font color='red'>父组件</font>的 wxml 中，<font color='cornflowerblue'>通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件 </font>

③ 在<font color='orange'>子组件</font>的 js 中，通过调用 <font color='orange'>this.triggerEvent('自定义事件名称', { /* 参数对象 */ }) </font>，**将数据发送到父组件** 

④ 在<font color='red'>父组件</font>的 js 中，通过 <font color='red'>e.detail 获取到子组件传递过来的数据</font> 

###### 步骤1：

**在父组件的 js 中，定义一个函数，这个函数即将通过自定义事件的形式，传递给子组件。** 

![1647952456163](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647952456163.png)

###### 步骤2：

**在父组件的 wxml 中，通过自定义事件的形式，将步骤 1 中定义的函数引用，传递给子组件。** 

![1647952511262](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647952511262.png)

###### 步骤3：

**在子组件的 js 中，通过调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ }) ，将数据发送到父组件。** 

![1647952533662](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647952533662.png)

###### 步骤4：

**在父组件的 js 中，通过 e.detail 获取到子组件传递过来的数据。** 

![1647952562441](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647952562441.png)

###### 3、获取组件实例

可在<font color='lime'>父组件里调用 this.selectComponent("id或class选择器")</font> ，**获取子组件的实例对象**，**从而直接访问子组件**

**的任意数据和方法**。调用时需要传入一个选择器，例如 this.selectComponent(".my-component")。 

![1647953050736](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647953050736.png)

#### 10、behaviors 

##### 10.1 behaviors概述

behaviors 是小程序中，**用于实现组件间代码共享的特性**，类似于 Vue.js 中的 “mixins” 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647953569009.png" alt="1647953569009" style="zoom:50%;" />

##### 10.2 behaviors的工作方式

<font color='red'>每个 behavior 可以包含一组属性、数据、生命周期函数和方法。</font>**组件引用它时，它的属性、数据和方法会被** 

**合并到组件中。 每个组件可以引用多个 behavior，behavior 也可以引用其它 behavior。** 

##### 10.3 创建behavior

<font color='cornflowerblue'>调用 Behavior(Object object) 方法即可创建一个共享的 behavior 实例对象，供所有的组件使用：</font> 

![1647953671854](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647953671854.png)

##### 10.4 导入并使用behavior

在组件中，<font color='lime'>使用 require() 方法导入需要的 behavior，挂载后即可访问 behavior 中的数据或方法</font>，示例代码 如

下： 

![1647953721506](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647953721506.png)

**在组件的.wxml中使用：**

![1647954220888](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647954220888.png)

##### 10.5 behavior 中所有可用的节点 

| **可用的节点**                      | **类型**     | **是否必填** | **描述**            |
| ----------------------------------- | ------------ | ------------ | ------------------- |
| <font color='red'>properties</font> | Object Map   | 否           | 同组件的属性        |
| <font color='red'>data</font>       | Object       | 否           | 同组件的数据        |
| <font color='red'>methods</font>    | Object       | 否           | 同自定义组件的方法  |
| <font color='red'>behaviors</font>  | String Array | 否           | 引入其它的 behavior |
| created                             | Function     | 否           | 生命周期函数        |
| attached                            | Function     | 否           | 生命周期函数        |
| ready                               | Function     | 否           | 生命周期函数        |
| moved                               | Function     | 否           | 生命周期函数        |
| detached                            | Function     | 否           | 生命周期函数        |

##### 10.6  同名字段的覆盖和组合规则* 

**组件和它引用的 behavior 中可以包含同名的字段**，此时可以参考如下 3 种同名时的处理规则： 

① 同名的数据字段 (data) 

② 同名的属性 (properties) 或方法 (methods) 

③ 同名的生命周期函数 

### 自定义组件总结

① 能够<font color='red'>创建并引用组件</font>

- 全局引用、局部引用、usingComponents 

② 能够<font color='red'>知道如何修改组件的样式隔离选项</font>

-  options -> styleIsolation（ isolated, apply-shared, shared） 

③ 能够<font color='red'>知道如何定义和使用数据监听器</font>

- observers 

④ 能够<font color='red'>知道如何定义和使用纯数据字段</font>

- options -> pureDataPattern 

⑤ 能够<font color='red'>知道实现组件父子通信有哪3种方式</font>

- 属性绑定、事件绑定、this.selectComponent(' id或class选择器') 

⑥ 能够<font color='red'>知道如何定义和使用behaviors</font> 

- 调用 Behavior() 构造器方法 

## 2、使用npm包

#### 1、小程序对npm的支持与限制

目前，小程序中已经支持使用 npm 安装第三方包，从而来提高小程序的开发效率。但是，在小程序中使用 npm 包有如下 3 个限制： 

① 不支持依赖于 Node.js 内置库的包 

② 不支持依赖于浏览器内置对象的包 

③ 不支持依赖于 C++ 插件的包  

#### 2、Vant Weapp 

##### 2.1 Vant Weapp 概述

Vant Weapp 是有赞前端团队开源的一套小程序 UI 组件库，助力开发者快速搭建小程序应用。

它所使用的是 MIT 开源许可协议，对商业使用比较友好。 

官方文档地址 https://youzan.github.io/vant-weapp 

##### 2.2 安装 Vant 组件库

在小程序项目中，安装 Vant 组件库主要分为如下 3 步： 

① 通过 npm 安装（建议指定版本为@1.3.3） 

![1647956158792](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647956158792.png)

![1647956254694](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647956254694.png)

② 构建 npm 包 

![1647956230246](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647956230246.png)

③ 修改 app.json 

![1647956198915](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647956198915.png)

**注意：如果项目根目录中没有package.json文件，则需要初始化包配置管理文件：npm init -y**

##### 2.3 使用 Vant 组件

安装完 Vant 组件库之后，<font color='red'>可以在 app.json 的 usingComponents 节点中引入需要的组件</font>，即可在 wxml 中直接

使用组件。示例代码如下： 

![1647956135072](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1647956135072.png)

**参考官方文档使用相关组件**

##### 2.4 定义全局主题样式

Vant Weapp 使用 CSS 变量来实现定制主题。 关于 CSS 变量的基本用法，

请参考 MDN 文档： https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties 

###### 1、 在 app.wxss 中，写入 CSS 变量，即可对全局生效： 

page为根节点

![1648000551679](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648000551679.png)

#### 3、API Promise化 

##### 3.1  基于回调函数的异步 API 的缺点 

默认情况下，小程序官方提供的**异步 API 都是基于回调函数实现的**，例如，网络请求的 API 需要按照如下的

方式调用： 

![1648000630934](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648000630934.png)

缺点：容易造成回调地狱的问题，代码的可读性、维护性差！ 

##### 3.2 API Promise化

API Promise化，指的是**通过额外的配置，将官方提供的、基于回调函数的异步 API，升级改造为基于** 

**Promise 的异步 API**，从而提高代码的可读性、维护性，避免回调地狱的问题。 

##### 3.3 实现 API Promise化

<font color='orange'>**注意：在小程序中，每一次安装包之后都需要重新构建npm**</font>

在小程序中，实现 API Promise 化主要依赖于 miniprogram-api-promise 这个第三方的 npm 包。它的安装 和使

用步骤如下： 

![1648001046964](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648001046964.png)

<font color='red'>在小程序入口文件中（app.js），只需调用一次 promisifyAll()方法</font>

![1648001052911](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648001052911.png)

#### 4、全局数据共享

**全局数据共享（又叫做：状态管理）是为了解决组件之间数据共享的问题。** 

开发中常用的全局数据共享方案有：Vuex、Redux、MobX 等。 

##### 4.1 全局数据共享方案

在小程序中，可<font color='red'>使用 mobx-miniprogram 配合 mobx-miniprogram-bindings 实现全局数据共享</font>。其中：

- mobx-miniprogram 用来创建 Store 实例对象 

- mobx-miniprogram-bindings 用来把 Store 中的共享数据或方法，绑定到组件或页面中使用 

###### 1、安装MobX的相关包

在项目中运行如下的命令，安装 MobX 相关的包： 

![1648002457372](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648002457372.png)

注意：MobX 相关的包安装完毕之后，记得删除 miniprogram_npm 目录后，重新构建 npm。 

###### 2、创建 MobX 的 Store 实例 

![1648002595602](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648002595602.png)

###### 3、将 Store 中的成员绑定到页面中 

![1648002627041](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648002627041.png)

###### 4、在页面上使用 Store 中的成员 

![1648002654022](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648002654022.png)

###### 5、将 Store 中的成员绑定到组件中 

![1648004332325](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648004332325.png)

## 3、分包

#### 1、分包基础

分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使

用时按需进行加载。 

##### 1.1 分包的好处

对小程序进行分包的好处主要有以下两点：

- 可以优化小程序首次启动的下载时间 
- 在多团队共同开发时可以更好的解耦协作 

##### 1.2 分包前项目的构成

分包前，小程序项目中<font color='red'>所有的页面和资源</font>都被打包到了一起，导致整个项目体积过大，影响小程序首次启动

的下载时间。 

![1648005146477](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005146477.png)

##### 1.3 分包后项目的构成

**<font color='orange'>分包后，小程序项目由 1 个主包 + 多个分包组成：</font>**

<font color='cornflowerblue'>主包：</font>一般只包含<font color='lime'>项目的启动页面或 TabBar 页面、以及所有分包都需要用到的一些公共资源</font>

<font color='cornflowerblue'>分包：</font>只包含和当前分包有关的页面和私有资源 

![1648005225329](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005225329.png)

##### 1.4 分包的加载规则

① 在小程序启动时，<font color='cornflowerblue'>默认会下载主包并启动主包内页面</font>

- <font color='lime'>tabBar 页面需要放到主包中 </font>

② 当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示 

- 非 tabBar 页面可以按照功能的不同，划分为不同的分包之后，进行按需下载 

##### 1.5 分包的体积限制

目前，小程序分包的大小有以下两个限制：

- 整个小程序所有分包大小不超过 16M（主包 + 所有分包）
- 单个分包/主包大小不能超过 2M 

#### 2、分包的使用

##### 2.1 配置方法

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005388962.png" alt="1648005388962" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005401800.png" alt="1648005401800" style="zoom:50%;" />

##### 2.2 打包原则

① <font color='cornflowerblue'>小程序会按 subpackages 的配置进行分包，subpackages 之外的目录将被打包到主包中 </font>

② <font color='lime'>主包也可以有自己的 pages（即最外层的 pages 字段） </font>

③ <font color='red'>tabBar 页面必须在主包内 </font>

④ <font color='orange'>分包之间不能互相嵌套 </font>

##### 2.3 引用原则

① <font color='red'>主包无法引用分包内的私有资源</font> 

② <font color='cornflowerblue'>分包之间不能相互引用私有资源 </font>

③ <font color='orange'>分包可以引用主包内的公共资源</font> 

#### 3、独立分包

##### 3.1 独立分包定义

<font color='cornflowerblue'>独立分包本质上也是分包</font>，只不过它比较特殊，**可以独立于主包和其他分包而单独运行。** 

![1648005792291](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005792291.png)

##### 3.2 独立分包和普通分包的区别

最主要的区别：**是否依赖于主包才能运行** 

- <font color='orange'>普通分包必须依赖于主包才能运行</font>
- <font color='cornflowerblue'>独立分包可以在不下载主包的情况下，独立运行 </font>

##### 3.3 独立分包应用场景

开发者可以按需，将某些具有一定功能独立性的页面配置到独立分包中。

原因如下：

- 当小程序从普通的分包页面启动时，需要首先下载主包
- 而独立分包不依赖主包即可运行，可以很大程度上提升分包页面的启动速度 

注意：**一个小程序中可以有多个独立分包**。 

##### 3.4 独立分包的配置

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005952017.png" alt="1648005952017" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648005962609.png" alt="1648005962609" style="zoom:50%;" />

##### 3.5 引用原则

独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源！例如： 

**① 主包无法引用独立分包内的私有资源** 

**② 独立分包之间，不能相互引用私有资源** 

**③ 独立分包和普通分包之间，不能相互引用私有资源** 

**④ <font color='red'>特别注意：独立分包中不能引用主包内的公共资源</font>** 

#### 4、分包预下载

分包预下载指的是：在进入小程序的某个页面时，<font color='orange'>由框架自动预下载可能需要的分包</font>，从而提升进入后续分

包页面时的启动速度。 

##### 4.1 配置分包的预下载

**<font color='red'>预下载分包的行为，会在进入指定的页面时触发。</font>**

在 app.json 中，使用 <font color='cornflowerblue'>preloadRule</font> 节点定义分包的预下载规则，示例代码如下： 

![1648006296089](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648006296089.png)

##### 4.2 分包预下载的限制

**同一个分包中的页面享有共同的预下载大小限额 2M**，例如 

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648006417711.png" alt="1648006417711" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648006442990.png" alt="1648006442990" style="zoom:50%;" />

## 案例-自定义tabBar

#### 1、案例效果

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648006592830.png" alt="1648006592830" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648006706936.png" alt="1648006706936" style="zoom:50%;" />

