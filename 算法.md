Java ListNode链表

#### 1、链表的定义

**链表结构：在JAVA中需要自己定义一个ListNode类来生成链表对象**

链表是一种数据结构：由数据和指针构成，链表的指针指向下一个节点。

<font color='red'>自定义的链表结构如下：</font>

~~~
public class ListNode{
	// 数据：节点数据
	int val;
	// 对象：引用下一个节点对象
	ListNode next;
	// 赋值链表的值
	// 构造方法：构造方法和类名相同
	ListNode(int val){
		// 把接收到的参数赋值给当前类的val变量
		this.val = val;
	}
}
~~~

#### 2、创建以及遍历链表

~~~
public class ListNode{
	// 数据：节点数据
	int val;
	// 对象：引用下一个节点对象
	ListNode next;
	// 赋值链表的值
	// 构造方法：构造方法和类名相同
	ListNode(int val){
		// 把接收到的参数赋值给当前类的val变量
		this.val = val;
	}
}

class Text{
	
}
~~~



LeetCode第二题：

![1648201057640](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648201057640.png)

~~~
链表做带进位加法
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)  两个已知链表对象ListNode l1, ListNode l2
输出：7 -> 0 -> 8
原因：342 + 465 = 807

示例：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
~~~

代码：

~~~

~~~

# length、length()、size()的区别

length：属性，用于获取数组的长度；

length()：方法，用于获取字符串的长度；

size()：方法，用于获取泛型集合中元素的个数；

# 泛型集合

泛型是一种约束-规范类型；

特点：

1. 编译时即可检查，而非运行时抛出异常
2. 访问时，不必类型转换也就是拆箱
3. 不同泛型之间引用不能相互赋值，泛型不存在多态。（左泛型不可为右父类）

ArrayList<String> arr = new ArrayList<String>();

此处，泛型集合里的元素类型必须为String；



1、Add():方法用于添加一个元素到当前列表的末尾

2、AddRange():方法用于添加一批元素(数组或者集合)到列表的末尾

3、Remove():方法用于删除一个元素，通过元素本身的引用来删除,填什么删什么

4、RemoveAt():方法用于删除一个元素，通过索引值来删除

5、RemoveRange():用于删除一批元素，通过指定开始的索引和删除的数量来删除

6、Insert(int index,value):用于添加一个元素到指定位置，列表后面的元素依次往后移

7、InsertRange(int index,values):用于从指定位置开始添加一批元素，列表后面的元素依次往后移动

8、Contains():用于查看集合中是否包含所给元素

#### 1、泛型的应用

泛型主要应用于集合中：

- 定义在类中
- 定义在接口中
- 定义在方法中

##### 1.1 泛型类

把泛型定义在类上

格式：

~~~
public class 类名<泛型类型1,...>
~~~

**泛型类型必须为引用类型**

<font color='red'>引用类型</font>

引用类型（reference type）指向一个对象，不是原始值，指向对象的变量是引用变量。 在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型，可以像基本类型一样使用。 

~~~
使用泛型：提高程序的安全性：将泛型定义在类上

public class ObjectTool<T>{
	// 成员变量
	private T obj;
	
	// 获取功能
	public T get(){
		return obj;
	}
	
	// 设置功能
	public void set(T obj){
		this.obj = obj;
	}
}


// 把泛型定义在类上：测试类
public static void main(String[] args){
	// 创建ObjectTools类的对象
	ObjectTool<String> ot = new ObjectTool<String>();
	
	//设置数据
	ot.set("网易");
	// 获取数据
	String s = ot.get();
	System.out.println("姓名是："+s);
	
	ObjectToll<Integer> ot2 = new ObjectTool<Integer>();
	
	// 设置数据
	ot2.set(29);
	Integet i = ot2.get();
	System.out.println("年龄是："+1);
}
~~~

# JAVA数据结构与算法

#### 1、问题-字符串匹配

字符串匹配问题：： 

1) 有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好""，和一个子串 str2="尚硅谷你尚硅你" 

**2)** **现在要判断** **str1** **是否含有** **str2**, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 

3) 要求用最快的速度来完成匹配 

<font color='red'>使用到KMP算法（部分匹配表）</font>

#### 2、问题-汉诺塔

汉诺塔游戏, **请完成汉诺塔游戏的代码**: 

要求：1) 将A塔的所有圆盘移动到C塔。并且规定，在2) 小圆盘上不能放大圆盘，3)在三根柱子之间一次只

能移动一个圆盘

![1648257302744](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648257302744.png)

<font color='red'>使用到分治算法</font>

#### 3、问题-八皇后

八皇后问题，是一个古老而著名的问题，是 **回溯算法的典型案例**。该问题是国际西洋棋 棋手马克斯·贝瑟尔

于1848年提出：在8×8格 的国际象棋上摆放八个皇后，使其不能互相 攻击，即：**任意两个皇后都不能处于同** 

**一行、同一列或同一斜线上，问有多少种摆法**。【92】 

**<font color='red'>使用到回溯算法</font>** 

高斯认为有76种方案。1854年在柏林的象棋 杂志上不同的作者发表了40种不同的解，后来有人用图论的方法

解出92种结果。计算机 http://www.7k7k.com/swf/49842.htm 发明后，有多种计算机语言可以解决此问题。

#### 4、问题-马踏棋盘算法

马踏棋盘算法介绍和游戏演示 

1) 马踏棋盘算法也被称为骑士周游问题 

2) 将马随机放在国际象棋的8×8棋盘 

- Board[0～7][0～7]的某个方格中，马按走棋规则(**马走日字**)进行移动。要求每个方格只进入一次，走遍棋盘上全部

  64个方格 

3) 游戏演示: http://www.4399.com/flash/146267_2.htm 

4) 会使用到图的深度优化遍历算法(DFS) + <font color='red'>**贪心算法优化**</font>

![1648258213151](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648258213151.png)

## 数据结构和算法的介绍

程序=数据结构+算法

数据结构是算法的基础

#### 1、实际编程中遇到的问题

##### 1.1 问题一：字符串替换问题

~~~
public static void main(String[] args) { 
	String str = "Java,Java, hello,world!"; 
	String newStr = str.replaceAll("Java", "尚硅谷~"); //算法 
	System.out.println("newStr=" + newStr); 
}
~~~

问：试写出用**单链表**表示的字符串类及字符串结点类的定义，并依次实现它的构造函数、以及计算串长度、

串赋值、判断两串相等、求子串、两串连接、求子串在串中位置等7个成员函数。

<font color='red'>**小结：需要使用到单链表数据结构**</font>

##### 1.2 五子棋程序

![1648258842949](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648258842949.png)

如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能 

棋盘—>二维数组=>(稀疏数组)-> 写入文件 【存档功能】 

读取文件-》稀疏数组-》二维数组 -》 棋盘 【接上局】

##### 1.3 约瑟夫(Josephu)问题(丢手帕问题)

1) Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数

到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，

由此产生一个出队编号的序列。 

**2)** **提示：**用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表（**单向环形**

**链表**），然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一

个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。

##### 小结：

修路问题 => 最小生成**树(加权值)【数据结构】**+ 普利姆算法 

最短路径问题 => 图+弗洛伊德算法 

**汉诺塔** **=>** **分支算法** 

八皇后问题 => 回溯法

## 1、数据结构的组成

**数据结构分为线性结构与非线性结构**

#### 1、线性结构

1. <font color='red'>线性结构作为最常用的数据结构</font>，其<font color='red'>特点是数据元素之间存在一对一的线性关系</font> 

2. <font color='orange'>线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。</font><font color='cornflowerblue'>顺序存储的线性表称为顺序表</font>，顺序

   表中的存储元素是连续的 

3. <font color='red'>链式存储的线性表称为链表，链表中的存储元素不一定是连续的</font>，<font color='cornflowerblue'>元素节点中存放数据元素以及相邻元素</font>

   <font color='cornflowerblue'>的地址信息 </font>

4. **线性结构常见的有：数组、队列、链表和栈**，后面我们会详细讲解.

#### 2、非线性结构

**非线性结构包括：二维数组，多维数组，广义表，树结构，图结构**

### 1.1稀疏数组和队列

#### 1、稀疏sparsearray数组

先看一个实际需求：

编写的五子棋程序中，有**存盘退出**和续上盘的功能

![1648259727830](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648259727830.png)

**分析问题：**

因为该二维数组的很多值是默认值0, 因此记录了很多没有意义的数据.->稀疏数组。

#### 2、稀疏数组

**<font color='red'>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</font>** 

稀疏数组的处理方法是: 

1. 记录数组一共有几行几列，有多少个不同的值 
2. 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

##### 稀疏数组举例说明：

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648259907556.png" alt="1648259907556" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648259917245.png" alt="1648259917245" style="zoom:50%;" /><font color='red'>稀疏数组</font>

##### 应用实例：

1. 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等) 
2. 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 
3. 整体思路分析 

![1648260019500](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648260019500.png)

<font color='red'>二维数组转稀疏数组的思路：</font>

稀疏数组的第一行为原始数组的行数、列数、有效数据个数

1. 遍历原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到稀疏数组


<font color='red'>稀疏数组转原始的二维数组的思路：</font>

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int[11] [11]
2. 在读取稀疏数组后几行的数据，并赋给原始的二维数组即可.

###### 代码实现：

~~~
package DataStructures.sparseArray;

public class SparseArray {

    public static void main(String[] args) {
        // 创建一个原始的二维数组 11*11
        // 0：表示没有棋子，1表示黑子，2表示白子
        int chessArr1[][] = new int[11][11];
        chessArr1[1][2]=1;
        chessArr1[2][3]=2;
        chessArr1[4][5]=2;
    //    输出原始的二维数组
        for(int[] row:chessArr1){
            System.out.printf("\n");
            for (int data:row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
    //    将二维数组 转为 稀疏数组
    //    1、先遍历二维数组，得到非0数据的个数
        int sum=0;
        for (int i=0;i<chessArr1.length;i++){
            for (int j=0;j<chessArr1.length;j++){
                if(chessArr1[i][j]!=0){
                    sum++;
                }
            }
        }
        System.out.println("非0数据的个数为："+sum);

    //    2、创建对应的稀疏数组
        int sparseArr[][]=new int[sum+1][3];
    //    3、给稀疏数组（第一行）赋值
        sparseArr[0][0]=11;
        sparseArr[0][1]=11;
        sparseArr[0][2]=sum;

    //    遍历二维数组，将非0的值存放到稀疏数组中

        //count用于记录是第几个非0数据
        int count = 0;
        for (int i=0;i<chessArr1.length;i++){
            for (int j=0;j<chessArr1.length;j++){
                if (chessArr1[i][j]!=0){
                    count++;
                    sparseArr[count][0]=i;
                    sparseArr[count][1]=j;
                    sparseArr[count][2]=chessArr1[i][j];
                }
            }
        }

    //    打印稀疏数组
        System.out.println();
        System.out.println("得到的稀疏数组为如下形式：");
        for (int[] row:sparseArr){
            System.out.println();
            for (int data:row){
                System.out.printf("%d\t",data);
            }
        }

    //    将稀疏数组恢复为原始的二维数组
        int newChessArr[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
        int z = 1;
        while (z<=sum){
            newChessArr[sparseArr[z][0]][sparseArr[z][1]]=sparseArr[z][2];
            z++;
        }
        System.out.println("恢复的原始数据为：");
        for (int[] row:newChessArr){
            System.out.println();
            for (int data:row){
                System.out.printf("%d\t",data);
            }
        }

    }
}
~~~

#### 3、队列

银行排队的案例：

![1648263155586](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648263155586.png)

先进先出

<font color="red">队列是一个有序列表，可以用**数组**或是**链表**来实现。</font> 

<font color='orange'>遵循**先入先出**的原则。</font>即：<font color='cornflowerblue'>先存入队列的数据，要先取出。后存入的要后取出。</font>

示意图：(使用数组模拟队列示意图)

![1648263281536](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648263281536.png)

##### 数组模拟队列

- 队列本身是有序列表，若使用**数组的结构来存储队列的数据**，则队列数组的声明如下图, 其中 **maxSize 该队列的最大容量。** 
- 因为**队列的输出、输入是分别从前后端来处理**，因此需要两个变**量** **front**及 **rear分别记录队列前后端**的下标，<font color='red'>front 会随着数据输出而改变，而 rear则是随着数据输入而改变。</font>

如图所示：

![1648263449858](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648263449858.png)

当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：

**思路分析** 

1. 将尾指针往后移：rear+1 , 当front == rear 【空】 
2. 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。<font color='cornflowerblue'> rear == maxSize - 1[队列满]</font>

代码实现：

~~~
package DataStructures.queue;

import com.sun.jmx.remote.internal.ArrayQueue;

import java.util.Scanner;

public class ArrayQueueDemo {
    public static void main(String[] args) {
        // 创建一个队列对象
        ArrayQueue1 arrayQueue = new ArrayQueue1(3);
    //    接收用户输入
        char key = ' ';
        // 扫描器
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
    //    输出一个菜单
        while (loop){
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出程序");
            System.out.println("a(add)：添加数据");
            System.out.println("g(get)：取出数据");
            System.out.println("h(head)：查看队列头数据");

            // 接收一个字符
            key = scanner.next().charAt(0);
            switch (key){
                case 's':
                    arrayQueue.showQueue();
                    break;

                case 'a':
                    System.out.println("请输入一个数：");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try {
                        int result = arrayQueue.getQueue();
                        System.out.printf("取出的数据是：%d\n",result);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }

                    break;
                case 'h':
                    try {
                        int head = arrayQueue.headQueue();
                        System.out.printf("头部数据为：%d\n",head);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    // 退出
                    scanner.close();
                    loop=false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出！");
    }
}

// 使用数组模拟队列 - 编写一个ArrayQueue类
class ArrayQueue1{
    // 表示数组的最大容量
    private int maxSize;
    // 队列头
    private int front;
    // 队列尾
    private int rear;
    // 该数组用于存放数据，模拟队列
    private int[] arr;


    // 创建队列的构造器
    public ArrayQueue1(int maxSize){
        this.maxSize=maxSize;
        arr = new int[maxSize];
        // 初始的时候均为-1

        // 指向队列的头部，且不包含队列的头部第一个数据，即指向-1，指向队列头的前一个位置
        front = -1;
        // 指向队列尾的数据，即包含队列尾的最后一个数据
        rear = -1;
    }

    // 判断队列是否满
    public boolean isFull(){
        return rear==maxSize-1;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear==front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        // 判断队列是否满
        if (isFull()){
            System.out.println("队列满，不能加入数据");
            return;
        }
        // rear 后移
        rear++;
        arr[rear] = n;

    }

    // 获取队列的数据
    public int getQueue(){
        // 判断队列是否为空
        if (isEmpty()){
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        // front后移
        front++;
        return arr[front];
    }

//    显示队列的所有数据
    public void showQueue(){
        // 遍历
        if (isEmpty()){
            System.out.println("队列为空，没有数据！");
            return;
        }
        for (int i=0;i<arr.length;i++){
            System.out.printf("arr[%d] = %d\n",i,arr[i]);
        }
    }

    // 显示队列的头数据，注意不是取出数据
    public int headQueue(){
        // 判断是否为空
        if(isEmpty()){
            throw new RuntimeException("队列为空，没有数据！");
        }
        return arr[front+1];
    }

}
~~~

存在问题：

- 目前数组使用一次不能复用，没有达到复用的效果
- 将这个数组使用算法，改进成一个环形数组  %

##### 数组模拟<font color='red'>环形</font>队列

将数组看作一个环形，利用取模的方式实现。

分析说明：

- 尾索引的下一个为头索引时表示队列满，即将**队列容量空出一个作为约定**,这个在做判断队列满的时候需

  要注意 (rear + 1) % maxSize == front 满] 

- rear == front [空] 

测试示意图:

**利用数组模拟环形队列的思路分析**

![1648270996888](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648270996888.png)

![1648271098378](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648271098378.png)

**代码实现：**

~~~
package DataStructures.queue;

import com.sun.jmx.remote.internal.ArrayQueue;

import java.util.Scanner;

public class ArrayQueueDemo2 {
    public static void main(String[] args) {
        System.out.println("测试数组模拟环形队列案例！");

        // 创建一个队列对象
        CircleArrayQueue arrayQueue = new CircleArrayQueue(3);
        //    接收用户输入
        char key = ' ';
        // 扫描器
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        //    输出一个菜单
        while (loop) {
            System.out.println("s(show)：显示队列");
            System.out.println("e(exit)：退出程序");
            System.out.println("a(add)：添加数据");
            System.out.println("g(get)：取出数据");
            System.out.println("h(head)：查看队列头数据");

            // 接收一个字符
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    arrayQueue.showQueue();
                    break;

                case 'a':
                    System.out.println("请输入一个数：");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':
                    try {
                        int result = arrayQueue.getQueue();
                        System.out.printf("取出的数据是：%d\n", result);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }

                    break;
                case 'h':
                    try {
                        int head = arrayQueue.headQueue();
                        System.out.printf("头部数据为：%d\n", head);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    // 退出
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
            System.out.println("程序退出！");
        }
    }
}

// 使用数组模拟环形队列 - 编写一个CircleArrayQueue类
class CircleArrayQueue{
    // 表示数组的最大容量
    private int maxSize;
    // 队列头：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素
    // front的初始值为：0
    private int front;
    // 队列尾：rear指向队列最后一个元素的后一个位置，预留一个位置
    // rear的初始值为：0
    private int rear;
    // 该数组用于存放数据，模拟队列
    private int[] arr;

    // 创建环形队列的构造器
    public CircleArrayQueue(int maxSize){
        this.maxSize = maxSize;
        arr = new int[maxSize];
        front = 0;
        rear=0;
    }

    // 判断队列是否满
    public boolean isFull(){
        return (rear+1)%maxSize == front;
    }

    // 判断队列是否为空
    public boolean isEmpty(){
        return rear==front;
    }

    // 添加数据到队列
    public void addQueue(int n){
        // 判断队列是否满
        if (isFull()){
            System.out.println("队列满，不能加入数据");
            return;
        }
        // 将数据直接存入
        arr[rear] = n;
        // rear 后移，这里必须考虑取模
        rear = (rear+1)%maxSize;
    }

    // 获取队列的数据
    public int getQueue(){
        // 判断队列是否为空
        if (isEmpty()){
            // 通过抛出异常
            throw new RuntimeException("队列空，不能取数据");
        }
        // front指向队列的第一个元素
        // 1、先把front对应的值保存到一个临时的变量
        int value = arr[front];
        // 2、将front后移，考虑取模，防止数组越界
        front = (front + 1) % maxSize;
        // 3、将临时保存的变量返回
        return value;
    }

    //    显示队列的所有数据
    public void showQueue(){
        // 遍历
        if (isEmpty()){
            System.out.println("队列为空，没有数据！");
            return;
        }
        // 思路：从front遍历，遍历多少个元素
        for (int i = front; i < front + size(); i++){
            System.out.printf("arr[%d] = %d\n",i % maxSize,arr[i % maxSize]);
        }
    }
    // 求出当前队列的有效数据个数
    public int size(){
        return (rear + maxSize -front) % maxSize;
    }

    // 显示队列的头数据，注意不是取出数据
    public int headQueue(){
        // 判断是否为空
        if(isEmpty()){
            throw new RuntimeException("队列为空，没有数据！");
        }
        return arr[front];
    }
}
~~~

#### 4、链表

链表是<font color='red'>有序的列表</font>，但是它在内存中是存储如下：

![1648274697159](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648274697159.png)

小结: 

1) 链表是<font color='red'>以节点的方式来存储,是链式存储 </font>

2) <font color='red'>每个节点包含 data 域， next 域：指向下一个节点. </font>

3) 如图：发现链表的**各个节点不一定是连续存储**. 

4) <font color='lime'>链表分带头节点的链表和没有头节点的链表</font>，根据实际的需求来确定

##### 4.1 单链表

单链表(带头结点) **逻辑结构**示意图如下

![1648275147532](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648275147532.png)

使用带head头的单向链表实现 –水浒英雄排行榜管理

完成对英雄人物的增删改查操作， 注: 删除和修改,查找

第一种方法在添加英雄时，直接添加到链表的尾部

![1648276421085](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648276421085.png)

~~~
package DataStructures.linkList;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        // 创建节点
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");

        // 创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 以此加入节点
        singleLinkedList.add(hero1);
        singleLinkedList.add(hero2);
        singleLinkedList.add(hero3);
        singleLinkedList.add(hero4);

        // 显示链表
        singleLinkedList.list();
    }
}
// 定义SingleLinkedList管理英雄
class SingleLinkedList{
    // 初始化一个头节点，不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    // 添加节点到单向链表
    // 思路：当不考虑编号顺序时
    // 1.找到当前链表的最后节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head;
        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next==null){
                break;
            }
            // 如果没有找到最后
            temp = temp.next;
        }
        // 当退出while循环时，temp就指向了链表的最后
        temp.next = heroNode;
    }

    // 显示链表
    public void list(){
        // 判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空！");
            return;
        }
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head.next;
        while (true){
            // 判断是否到链表最后
            if(temp==null){
                break;
            }
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移，不然会陷入死循环
            temp = temp.next;

        }
    }
}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点
    public HeroNode next;

//    构造器
    public HeroNode(int no,String name,String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

//    重写toString方法
    @Override
    public String toString(){
        return "HeroNode [no="+no+", name="+name+", nickname="+nickname+"]";
    }
}
~~~

<font color='red'>第二种方式在添加英雄时，根据排名将英雄插入到指定位置</font>

![1648276443775](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648276443775.png)

(如果有这个排名，则添加失败，并给出提示)

~~~
package DataStructures.linkList;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        // 创建节点
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero5 = new HeroNode(3,"吴用","智多星");

        // 创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 以此加入节点
        //singleLinkedList.add(hero1);
        //singleLinkedList.add(hero2);
        //singleLinkedList.add(hero3);
        //singleLinkedList.add(hero4);

        // 按照编号的顺序加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero5);

        // 显示链表
        singleLinkedList.list();
    }
}
// 定义SingleLinkedList管理英雄
class SingleLinkedList{
    // 初始化一个头节点，不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    // 添加节点到单向链表
    // 思路：当不考虑编号顺序时
    // 1.找到当前链表的最后节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head;
        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next==null){
                break;
            }
            // 如果没有找到最后
            temp = temp.next;
        }
        // 当退出while循环时，temp就指向了链表的最后
        temp.next = heroNode;
    }

    // 添加节点到单向链表
    // 考虑编号顺序
    // 根据排名将新英雄插入到指定位置
    // 如果有这个排名，则添加失败，并给出提示
    public void addByOrder(HeroNode heroNode){
        // head节点不能动，需要一个辅助节点来找到添加的位置的前一个节点
        // 单链表：找的temp是添加节点的位置的前一个节点，否则插入失败
        HeroNode temp = head;
        // 添加的编号是否存在，默认为false
        boolean flag = false;
        while (true){
            if (temp.next==null){
                // 说明temp已经到链表的最后
                break;
            }
            if (temp.next.no > heroNode.no){
                // 找到位置
                break;
            }else if(temp.next.no == heroNode.no){
                // 说明添加的英雄已经存在
                flag = true;
                break;
            }
            // 后移，遍历当前链表，继续寻找
            temp=temp.next;
        }
        if (flag){
            // 不能添加说明信息存在
            System.out.printf("准备插入的英雄的编号 %d 已经存在，不能继续加入！\n",heroNode.no);
        }else{
            // 插入到链表中
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    // 显示链表
    public void list(){
        // 判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空！");
            return;
        }
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head.next;
        while (true){
            // 判断是否到链表最后
            if(temp==null){
                break;
            }
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移，不然会陷入死循环
            temp = temp.next;

        }
    }
}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点
    public HeroNode next;

//    构造器
    public HeroNode(int no,String name,String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

//    重写toString方法
    @Override
    public String toString(){
        return "HeroNode [no="+no+", name="+name+", nickname="+nickname+"]";
    }
}
~~~

<font color='red'>从单链表中删除一个节点：</font>

![1648279344069](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648279344069.png)

~~~
package DataStructures.linkList;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        // 创建节点
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero5 = new HeroNode(3,"吴用","智多星");

        // 创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 以此加入节点
        //singleLinkedList.add(hero1);
        //singleLinkedList.add(hero2);
        //singleLinkedList.add(hero3);
        //singleLinkedList.add(hero4);

        // 按照编号的顺序加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero5);

        // 显示链表
        singleLinkedList.list();

        // 修改节点
        // 定义新节点
        HeroNode newHeroNode = new HeroNode(2,"小卢","玉麒麟~~~");
        singleLinkedList.update(newHeroNode);

        System.out.println();
        // 显示修改后的链表
        singleLinkedList.list();

        // 删除节点
        singleLinkedList.delete(hero5);
        System.out.println("删除指定节点后的链表：");
        singleLinkedList.list();
    }
}
// 定义SingleLinkedList管理英雄
class SingleLinkedList{
    // 初始化一个头节点，不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    // 添加节点到单向链表
    // 思路：当不考虑编号顺序时
    // 1.找到当前链表的最后节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head;
        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next==null){
                break;
            }
            // 如果没有找到最后
            temp = temp.next;
        }
        // 当退出while循环时，temp就指向了链表的最后
        temp.next = heroNode;
    }

    // 添加节点到单向链表
    // 考虑编号顺序
    // 根据排名将新英雄插入到指定位置
    // 如果有这个排名，则添加失败，并给出提示
    public void addByOrder(HeroNode heroNode){
        // head节点不能动，需要一个辅助节点来找到添加的位置的前一个节点
        // 单链表：找的temp是添加节点的位置的前一个节点，否则插入失败
        HeroNode temp = head;
        // 添加的编号是否存在，默认为false
        boolean flag = false;
        while (true){
            if (temp.next==null){
                // 说明temp已经到链表的最后
                break;
            }
            if (temp.next.no > heroNode.no){
                // 找到位置
                break;
            }else if(temp.next.no == heroNode.no){
                // 说明添加的英雄已经存在
                flag = true;
                break;
            }
            // 后移，遍历当前链表，继续寻找
            temp=temp.next;
        }
        if (flag){
            // 不能添加说明信息存在
            System.out.printf("准备插入的英雄的编号 %d 已经存在，不能继续加入！\n",heroNode.no);
        }else{
            // 插入到链表中
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    // 显示链表
    public void list(){
        // 判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空！");
            return;
        }
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head.next;
        while (true){
            // 判断是否到链表最后
            if(temp==null){
                break;
            }
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移，不然会陷入死循环
            temp = temp.next;

        }
    }

    // 修改节点的信息，根据编号修改，no不能修改
    // 说明：根据newHeroNode的no来修改即可
    public void update(HeroNode newHeroNode){
        // 判断是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，先定义一个辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true){
            if (temp==null){
                // 到了链表的最后
                break;
            }
            if (temp.no == newHeroNode.no){
                // 找到了要修改的节点
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 根据flag 判断是否找到要修改的节点
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        }else {
            // 没找到该节点
            System.out.printf("没有找到编号为 %d 的节点，不能修改！\n",newHeroNode.no);
        }
    }

    // 删除节点
    public void delete(HeroNode heroNode){
        // 判断是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，先定义一个辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true){
            if (temp==null){
                break;
            }
            if (temp.next.no==heroNode.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 删除节点
        if (flag){
            // temp.next = heroNode.next;
            temp.next=temp.next.next;
        }else{
            System.out.printf("没有找到该节点");
        }
    }
}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点
    public HeroNode next;

//    构造器
    public HeroNode(int no,String name,String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

//    重写toString方法
    @Override
    public String toString(){
        return "HeroNode [no="+no+", name="+name+", nickname="+nickname+"]";
    }
}
~~~

### 单链表面试题

求单链表中有效节点的个数

~~~
package DataStructures.linkList;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        // 创建节点
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero5 = new HeroNode(3,"吴用","智多星");

        // 创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 以此加入节点
        //singleLinkedList.add(hero1);
        //singleLinkedList.add(hero2);
        //singleLinkedList.add(hero3);
        //singleLinkedList.add(hero4);

        // 按照编号的顺序加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero5);

        // 显示链表
        singleLinkedList.list();

        // 修改节点
        // 定义新节点
        HeroNode newHeroNode = new HeroNode(2,"小卢","玉麒麟~~~");
        singleLinkedList.update(newHeroNode);

        System.out.println();
        // 显示修改后的链表
        singleLinkedList.list();

        // 删除节点
        singleLinkedList.delete(3);
        System.out.println("删除指定节点后的链表：");
        singleLinkedList.list();

        // 获得单链表有效节点个数
        int result = singleLinkedList.getNum();
        System.out.printf("单链表有效节点个数为：%d\n",result);

        System.out.printf("有效节点的个数为：%d",getLength(singleLinkedList.getHead()));
    }

    // 方法：获取到单链表的节点的个数（如果是带头节点的链表，需要不统计头节点）
    /**
     * @param head 链表的头节点
     * @return 返回有效节点的个数
     */
    public static int getLength(HeroNode head){
        if(head.next==null){
            return 0;
        }
        int length = 0;
        // 定义一个辅助的变量
        HeroNode cur = head.next;
        while (cur!=null){
            length++;
            // 遍历
            cur = cur.next;
        }
        return length;
    }
}
// 定义SingleLinkedList管理英雄
class SingleLinkedList{
    // 初始化一个头节点，不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    // 返回头节点
    public HeroNode getHead(){
        return head;
    }

    // 添加节点到单向链表
    // 思路：当不考虑编号顺序时
    // 1.找到当前链表的最后节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head;
        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next==null){
                break;
            }
            // 如果没有找到最后
            temp = temp.next;
        }
        // 当退出while循环时，temp就指向了链表的最后
        temp.next = heroNode;
    }

    // 添加节点到单向链表
    // 考虑编号顺序
    // 根据排名将新英雄插入到指定位置
    // 如果有这个排名，则添加失败，并给出提示
    public void addByOrder(HeroNode heroNode){
        // head节点不能动，需要一个辅助节点来找到添加的位置的前一个节点
        // 单链表：找的temp是添加节点的位置的前一个节点，否则插入失败
        HeroNode temp = head;
        // 添加的编号是否存在，默认为false
        boolean flag = false;
        while (true){
            if (temp.next==null){
                // 说明temp已经到链表的最后
                break;
            }
            if (temp.next.no > heroNode.no){
                // 找到位置
                break;
            }else if(temp.next.no == heroNode.no){
                // 说明添加的英雄已经存在
                flag = true;
                break;
            }
            // 后移，遍历当前链表，继续寻找
            temp=temp.next;
        }
        if (flag){
            // 不能添加说明信息存在
            System.out.printf("准备插入的英雄的编号 %d 已经存在，不能继续加入！\n",heroNode.no);
        }else{
            // 插入到链表中
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    // 显示链表
    public void list(){
        // 判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空！");
            return;
        }
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head.next;
        while (true){
            // 判断是否到链表最后
            if(temp==null){
                break;
            }
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移，不然会陷入死循环
            temp = temp.next;

        }
    }

    // 修改节点的信息，根据编号修改，no不能修改
    // 说明：根据newHeroNode的no来修改即可
    public void update(HeroNode newHeroNode){
        // 判断是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，先定义一个辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true){
            if (temp==null){
                // 到了链表的最后
                break;
            }
            if (temp.no == newHeroNode.no){
                // 找到了要修改的节点
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 根据flag 判断是否找到要修改的节点
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        }else {
            // 没找到该节点
            System.out.printf("没有找到编号为 %d 的节点，不能修改！\n",newHeroNode.no);
        }
    }

    // 删除节点
    public void delete(int no){
        // 判断是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，先定义一个辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true){
            if (temp==null){
                break;
            }
            if (temp.next.no==no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 删除节点
        if (flag){
            // temp.next = heroNode.next;
            temp.next=temp.next.next;
        }else{
            System.out.printf("没有找到节点：%d",no);
        }
    }

    // 获取单链表中有效节点的个数
    public int getNum(){
        int sum = 0;
        // 先定义一个辅助节点
        HeroNode temp = head.next;
        while (true){
            if (temp!=null){
                sum++;
            }else {
                break;
            }
            temp = temp.next;
        }
        return sum;
    }
}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点
    public HeroNode next;

//    构造器
    public HeroNode(int no,String name,String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

//    重写toString方法
    @Override
    public String toString(){
        return "HeroNode [no="+no+", name="+name+", nickname="+nickname+"]";
    }
}
~~~

#### 1、单链表倒数第k个结点-新浪

<font color='red'>查找单链表中的倒数第k个结点</font>

~~~
 // 查找单链表中的倒数第k个结点【新浪面试题】
    /**
     * 思路：
     * 1、编写一份方法，接收head节点，同时接收一个index
     * 2、index 表示是倒数第index个元素
     * 3、先把链表从头到尾遍历，得到链表的总长度  getLength
     * 4、得到size后，从链表的第一个结点开始遍历，一直遍历到（size-index）个结点位置
     * 5、如果找到了返回该节点，如果没找到则返回空
     */
    /**
     * @param
     * @return
     */
    public static HeroNode findLastIndexNode(HeroNode head,int index){
        // 判断是否为空
        if(head.next==null){
            return null;
        }
        // 第一次遍历，得到链表的长度
        int length = getLength(head);
        //第二次遍历到 length - index 位置，找到倒数第index个结点并返回该结点
        if (index <= 0 || index > length){
            return null;
        }
        //定义一个辅助节点
        HeroNode temp = head.next;

        // 我的做法：
        //int num = 1;
        //while (temp!=null){
        //    if (length+1-index == num){
        //        break;
        //    }
        //    num++;
        //    temp=temp.next;
        //}

        // 老师的做法：
        // for循环定位到该结点
        for (int i = 0; i< length-index; i++){
            temp = temp.next;
        }
        return temp;
    }
~~~

测试代码：

~~~
 System.out.println("倒数第1个结点为："+findLastIndexNode(singleLinkedList.getHead(),1));

 System.out.println("倒数第2个结点为："+findLastIndexNode(singleLinkedList.getHead(),2));

 System.out.println("倒数第3个结点为："+findLastIndexNode(singleLinkedList.getHead(),3));
~~~

#### 2、单链表的反转-腾讯面试题

<font color='red'>单链表的反转</font><font color="green">有点难度</font>

![1648283373368](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648283373368.png)

![1648283396460](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648283396460.png)

![1648283407743](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648283407743.png)

~~~
package DataStructures.linkList;

public class SingleLinkedListDemo {
    public static void main(String[] args) {
        // 创建节点
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero5 = new HeroNode(3,"吴用","智多星");

        // 创建一个链表
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        // 以此加入节点
        //singleLinkedList.add(hero1);
        //singleLinkedList.add(hero2);
        //singleLinkedList.add(hero3);
        //singleLinkedList.add(hero4);

        // 按照编号的顺序加入
        singleLinkedList.addByOrder(hero1);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero5);

        // 显示链表
        singleLinkedList.list();

        // 修改节点
        // 定义新节点
        HeroNode newHeroNode = new HeroNode(2,"小卢","玉麒麟~~~");
        singleLinkedList.update(newHeroNode);

        System.out.println();
        // 显示修改后的链表
        singleLinkedList.list();

        // 删除节点
        singleLinkedList.delete(3);
        System.out.println("删除指定节点后的链表：");
        singleLinkedList.list();

        // 获得单链表有效节点个数
        int result = singleLinkedList.getNum();
        System.out.printf("单链表有效节点个数为：%d\n",result);

        System.out.printf("有效节点的个数为：%d\n",getLength(singleLinkedList.getHead()));

        System.out.println("倒数第1个结点为："+findLastIndexNode(singleLinkedList.getHead(),1));

        System.out.println("倒数第2个结点为："+findLastIndexNode(singleLinkedList.getHead(),2));

        System.out.println("倒数第3个结点为："+findLastIndexNode(singleLinkedList.getHead(),3));

        System.out.println("反转后的链表为：");
        reverseList(singleLinkedList.getHead());
        singleLinkedList.list();

    }

    // 方法：获取到单链表的节点的个数（如果是带头节点的链表，需要不统计头节点）
    /**
     * @param head 链表的头节点
     * @return 返回有效节点的个数
     */
    public static int getLength(HeroNode head){
        if(head.next==null){
            return 0;
        }
        int length = 0;
        // 定义一个辅助的变量
        HeroNode cur = head.next;
        while (cur!=null){
            length++;
            // 遍历
            cur = cur.next;
        }
        return length;
    }

    // 查找单链表中的倒数第k个结点【新浪面试题】
    /**
     * 思路：
     * 1、编写一份方法，接收head节点，同时接收一个index
     * 2、index 表示是倒数第index个元素
     * 3、先把链表从头到尾遍历，得到链表的总长度  getLength
     * 4、得到size后，从链表的第一个结点开始遍历，一直遍历到（size-index）个结点位置
     * 5、如果找到了返回该节点，如果没找到则返回空
     */
    /**
     * @param
     * @return
     */
    public static HeroNode findLastIndexNode(HeroNode head,int index){
        // 判断是否为空
        if(head.next==null){
            return null;
        }
        // 第一次遍历，得到链表的长度
        int length = getLength(head);
        //第二次遍历到 length - index 位置，找到倒数第index个结点并返回该结点
        if (index <= 0 || index > length){
            return null;
        }
        //定义一个辅助节点
        HeroNode temp = head.next;

        // 我的做法：
        //int num = 1;
        //while (temp!=null){
        //    if (length+1-index == num){
        //        break;
        //    }
        //    num++;
        //    temp=temp.next;
        //}

        // 老师的做法：
        // for循环定位到该结点
        for (int i = 0; i< length-index; i++){
            temp = temp.next;
        }
        return temp;
    }

    // 反转链表【腾讯面试题】
    // 1、先定义一个结点reverseHead = new HeroNode()
    // 2、从头到尾遍历原来的链表，每遍历一个结点，就将其取出，并放在新的链表的最前端，即：reverseHead.next = head.next;
    // 3、原来的链表的head.next = reverseHead.next;
    public static void reverseList(HeroNode head){
        // 如果当前链表为空，或者只有一个节点，无需反转，直接返回
        if (head.next==null || head.next.next==null){
            return;
        }
        // 定义一个辅助指针，帮助遍历原来的链表
        HeroNode cur = head.next;
        // 指向当前节点的下一个结点
        HeroNode next =null;
        // 定义反转头结点
        HeroNode reverseHead = new HeroNode(0,"","");
        // 遍历原来的链表，每遍历一个结点，就将其取出，并放在新的链表的最前端
        while (cur!=null){
            // 先暂时保存当前结点的下一个结点
            next = cur.next;
            // 将cur的下一个结点指向reverseHead
            cur.next = reverseHead.next;
            // 将cur连接到新的链表上
            reverseHead.next=cur;
            // 让cur后移
            cur = next;
        }
        // 将head.next指向reverseHead.next，实现单链表的反转
        head.next=reverseHead.next;

    }
}
// 定义SingleLinkedList管理英雄
class SingleLinkedList{
    // 初始化一个头节点，不存放具体的数据
    private HeroNode head = new HeroNode(0,"","");

    // 返回头节点
    public HeroNode getHead(){
        return head;
    }

    // 添加节点到单向链表
    // 思路：当不考虑编号顺序时
    // 1.找到当前链表的最后节点
    // 2.将最后这个节点的next指向新的节点
    public void add(HeroNode heroNode){
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head;
        // 遍历链表，找到最后
        while (true){
            // 找到链表的最后
            if (temp.next==null){
                break;
            }
            // 如果没有找到最后
            temp = temp.next;
        }
        // 当退出while循环时，temp就指向了链表的最后
        temp.next = heroNode;
    }

    // 添加节点到单向链表
    // 考虑编号顺序
    // 根据排名将新英雄插入到指定位置
    // 如果有这个排名，则添加失败，并给出提示
    public void addByOrder(HeroNode heroNode){
        // head节点不能动，需要一个辅助节点来找到添加的位置的前一个节点
        // 单链表：找的temp是添加节点的位置的前一个节点，否则插入失败
        HeroNode temp = head;
        // 添加的编号是否存在，默认为false
        boolean flag = false;
        while (true){
            if (temp.next==null){
                // 说明temp已经到链表的最后
                break;
            }
            if (temp.next.no > heroNode.no){
                // 找到位置
                break;
            }else if(temp.next.no == heroNode.no){
                // 说明添加的英雄已经存在
                flag = true;
                break;
            }
            // 后移，遍历当前链表，继续寻找
            temp=temp.next;
        }
        if (flag){
            // 不能添加说明信息存在
            System.out.printf("准备插入的英雄的编号 %d 已经存在，不能继续加入！\n",heroNode.no);
        }else{
            // 插入到链表中
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    // 显示链表
    public void list(){
        // 判断链表是否为空
        if(head.next==null){
            System.out.println("链表为空！");
            return;
        }
        // 因为head不能动，所以需要一个辅助遍历 temp
        HeroNode temp = head.next;
        while (true){
            // 判断是否到链表最后
            if(temp==null){
                break;
            }
            // 输出节点的信息
            System.out.println(temp);
            // 将 temp 后移，不然会陷入死循环
            temp = temp.next;

        }
    }

    // 修改节点的信息，根据编号修改，no不能修改
    // 说明：根据newHeroNode的no来修改即可
    public void update(HeroNode newHeroNode){
        // 判断是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，先定义一个辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true){
            if (temp==null){
                // 到了链表的最后
                break;
            }
            if (temp.no == newHeroNode.no){
                // 找到了要修改的节点
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 根据flag 判断是否找到要修改的节点
        if (flag){
            temp.name = newHeroNode.name;
            temp.nickname = newHeroNode.nickname;
        }else {
            // 没找到该节点
            System.out.printf("没有找到编号为 %d 的节点，不能修改！\n",newHeroNode.no);
        }
    }

    // 删除节点
    public void delete(int no){
        // 判断是否为空
        if (head.next==null){
            System.out.println("链表为空");
            return;
        }
        // 找到需要修改的节点，先定义一个辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        boolean flag = false;
        while (true){
            if (temp==null){
                break;
            }
            if (temp.next.no==no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        // 删除节点
        if (flag){
            // temp.next = heroNode.next;
            temp.next=temp.next.next;
        }else{
            System.out.printf("没有找到节点：%d",no);
        }
    }

    // 获取单链表中有效节点的个数
    public int getNum(){
        int sum = 0;
        // 先定义一个辅助节点
        HeroNode temp = head.next;
        while (true){
            if (temp!=null){
                sum++;
            }else {
                break;
            }
            temp = temp.next;
        }
        return sum;
    }
}

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点
    public HeroNode next;

//    构造器
    public HeroNode(int no,String name,String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

//    重写toString方法
    @Override
    public String toString(){
        return "HeroNode [no="+no+", name="+name+", nickname="+nickname+"]";
    }
}
~~~

#### 3、从尾到头打印单链表-百度面试题

要求：1、反向遍历  2、Stack栈

![1648429152026](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648429152026.png)

![1648429179441](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648429179441.png)

实现代码：

~~~
// 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果
    // 逆序打印链表【百度面试题】
    public static void reversePrint(HeroNode head){
        if (head.next==null){
            // 空链表，无法打印
            return;
        }
        // 创建一个栈，将各个节点压入栈
        Stack<HeroNode> stack = new Stack<HeroNode>();
        HeroNode cur = head.next;
        // 将链表的所有节点压入栈
        while (cur != null){
            stack.push(cur);
            // cur后移，指向下一个数据，压入下一个结点
            cur = cur.next;
        }
        // 将栈中的结点进行打印，即可实现遍历，利用pop()出栈实现
        while (stack.size()>0){
            System.out.println(stack.pop());
        }
    }
    
测试代码：
	System.out.println("逆序打印的链表为：");
    reversePrint(singleLinkedList.getHead());
~~~

**练习题：**

<font color='red'> 合并两个有序的单链表，合并之后的链表依然有序 </font>

解题思路： 假设有两个有序单链表List1、List2

1. 首先创建新的空链表，用于存放结果

2. 如果两个有序单链表均为空，结果链表为空；

3. 如果有一个有序单链表为空，则结果链表为另一个链表；

4. 如果两个有序单链表均不为空，则根据以下方法进行合并


 ![img](https://img-blog.csdnimg.cn/20181117144003674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdsaW4xOTk3MDk=,size_16,color_FFFFFF,t_70) 

5. 合并结束的条件：两个链表有一个为空

~~~
 // 合并两个有序的单链表，合并之后的链表依然有序
    public static void joinByOrder(HeroNode head1,HeroNode head2){
        HeroNode newHead = new HeroNode(0,"","");

        HeroNode cur1 = head1.next;
        HeroNode cur2 = head2.next;
        if (head1.next==null){
            newHead.next = head2.next;
        }else if (head2.next==null){
            newHead.next = head1.next;
        }

        HeroNode temp = newHead;
        while (cur1!=null || cur2!=null){
            if (cur1 == null && cur2 != null){
                temp.next = cur2;
                cur2 = cur2.next;
            }else if (cur1 != null && cur2 == null){
                temp.next = cur1;
                cur1 = cur1.next;
            }else{
                if (cur1.no < cur2.no){
                    temp.next = cur1;
                    cur1 = cur1.next;
                }else if (cur2.no < cur1.no){
                    temp.next = cur2;
                    cur2 = cur2.next;
                }
            }
            temp = temp.next;
        }

        System.out.println("合并后的有序链表为：");
        while (newHead.next!=null){
            System.out.println(newHead.next);
            newHead = newHead.next;
        }

    }
~~~

### 双向链表

#### 单向链表和双向链表

单向链表的缺点：

使用带head头的**双向链表**实现 –水浒英雄排行榜 

管理单向链表的缺点分析: 

- 单向链表，**查找的方向只能是一个方向**，而双向链表可以向前或者向后查找。 

- 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以**自我删除**，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会). 

- 示意图帮助理解删除

![1648429214658](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648429214658.png)

![1648429247364](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648429247364.png)

代码实现：

HeroNode类：

~~~
package DataStructures.DoubleLinkedList;

// 定义HeroNode，每个HeroNode对象就是一个节点
class HeroNode{
    public int no;
    public String name;
    public String nickname;
    // 指向下一个节点，默认为null
    public HeroNode next;
    // 指向上一个节点，默认为null
    public HeroNode pre;

    //    构造器
    public HeroNode(int no,String name,String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    //    重写toString方法
    @Override
    public String toString(){
        return "HeroNode [no="+no+", name="+name+", nickname="+nickname+"]";
    }
}
~~~

DoubleLinkedList类：

~~~
package DataStructures.DoubleLinkedList;

// 创建一个双向链表类
public class DoubleLinkedList {
    // 初始化一个头节点，不存放具体数据，不能随便使用
    private HeroNode head = new HeroNode(0,"","");

    // 返回头节点
    public HeroNode getHead(){
        return head;
    }

    // 遍历双向链表
    public void show(){
        // 判断链表是否为空
        if (head.next == null){
            System.out.println("链表为空！");
            return;
        }
        // 辅助节点
        HeroNode temp = head.next;
        while (temp!=null){
            System.out.println(temp);
            temp = temp.next;
        }
    }

    // 添加节点到双向链表
    public void add(HeroNode heroNode){
        // 辅助节点
        HeroNode temp = head;
        // 遍历链表，找到双向链表的最后一个节点
        while (temp.next!=null){
            temp = temp.next;
        }
        // 形成一个双向链表
        temp.next = heroNode;
        heroNode.pre = temp;
    }

    // 修改一个节点的内容
    public void update(HeroNode heroNode){
        // 判断是否为空
        if (head.next == null){
            System.out.println("链表为空！");
            return;
        }
        // 找到需要修改的节点，根据 no 编号
        // 辅助节点
        HeroNode temp = head.next;
        // 表示是否找到该节点
        Boolean flag = false;
        while (temp!=null){
            if (temp.no == heroNode.no){
                flag =true;
                break;
            }
            temp = temp.next;
        }
        if (flag){
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        }else {
            System.out.printf("没有找到编号为：%d的节点，修改失败！",heroNode.no);
        }
    }

    // 从双向链表中删除一个节点
    // 对于双向链表，直接找到需要删除的节点然后进行删除，而无需向单向链表找到要删除节点的上一个节点
    public void delete(int no){
        // 判断链表是否为空
        if (head.next == null){
            System.out.println("链表为空，无法删除！");
            return;
        }
        // 辅助节点
        HeroNode temp = head;
        // 标志是否找到要删除的节点
        Boolean flag = false;
        while (temp.next!=null){
            if (temp.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag){
            if (temp.next!=null){
                temp.pre.next = temp.next;
                temp.next.pre = temp.pre;
            }else {
                temp.pre.next = temp.next;
                // 这里代表要删除的节点是链表的最后一个节点，因此temp.next指向的是一个空指针
            }

        }else {
            System.out.printf("未找到编号为：%d 的节点，删除失败");
        }
    }
}
~~~

测试类：

~~~
package DataStructures.DoubleLinkedList;

public class Test {
    public static void main(String[] args) {
        System.out.println("双向链表的测试：");

        // 创建节点
        HeroNode h1 = new HeroNode(1,"李白","刺客");
        HeroNode h2 = new HeroNode(2,"韩信","刺客");
        HeroNode h3 = new HeroNode(3,"兰陵王","刺客");
        HeroNode h4 = new HeroNode(4,"狄仁杰","射手");
        HeroNode h5 = new HeroNode(5,"钟无艳","战士");
        HeroNode h6 = new HeroNode(6,"诸葛亮","法师");

        // 创建双向链表对象
        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();

        // 添加节点
        doubleLinkedList.add(h1);
        doubleLinkedList.add(h2);
        doubleLinkedList.add(h3);
        doubleLinkedList.add(h4);
        doubleLinkedList.add(h5);
        doubleLinkedList.add(h6);

        doubleLinkedList.show();

        // 修改
        HeroNode newHeroNode = new HeroNode(6,"诸葛亮","刺客");
        doubleLinkedList.update(newHeroNode);
        System.out.println("修改后的链表为：");
        doubleLinkedList.show();

        // 删除
        doubleLinkedList.delete(5);
        System.out.println("删除后的链表为：");
        doubleLinkedList.show();
    }
}
~~~

运行截图：

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648454384642.png" alt="1648454384642" style="zoom:50%;margin:0" />

练习：独立完成根据no编号顺序实现添加节点：

~~~
 // 根据编号顺序添加节点
    public void addByOrder(HeroNode heroNode){
        // 辅助节点
        HeroNode temp = head;
        Boolean flag = false;
        while (true){
            if (temp.next==null){
                break;
            }
            if (temp.next.no>heroNode.no){
                break;
            }
            else if (temp.next.no==heroNode.no){
                // 英雄已存在
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            System.out.printf("编号为：%d的英雄已存在，添加失败！");
        }else {
            heroNode.next = temp.next;
            temp.next = heroNode;
            heroNode.pre = temp;
        }
    }
~~~

测试代码：

~~~
 // 按序添加节点
        doubleLinkedList.addByOrder(h3);
        doubleLinkedList.addByOrder(h4);
        doubleLinkedList.addByOrder(h1);
        doubleLinkedList.addByOrder(h5);
        doubleLinkedList.addByOrder(h2);
        doubleLinkedList.addByOrder(h6);

        doubleLinkedList.show();
~~~

### 单向环形链表应用场景

**Josephu(约瑟夫、约瑟夫环) **问题

Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 

的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此

产生一个出队编号的序列。 

**提示**：<font color='red'>用一个不带头结点的循环链表来处理Josephu 问题： </font>

先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后

再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。



## 单向环形链表介绍

![1648456732840](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648456732840.png)

#### 使用环形单向链表来解决, **Josephu问题**

##### 约瑟夫问题示意图：

![1648457043868](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648457043868.png)

<font color='red'>单向环形链表完成约瑟夫问题</font>

##### 约瑟夫问题：创建环形链表的思路图解

![1648457122575](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648457122575.png)

实现代码：

Boy类：

~~~
package DataStructures.SingleCircleLinkedList;

// 新建一个Boy类，表示一个节点
public class Boy {
    private int no;
    // 指向下一个节点，默认为空
    private Boy next;

    // 构造方法
    public Boy(int no){
        this.no = no;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public Boy getNext() {
        return next;
    }

    public void setNext(Boy next) {
        this.next = next;
    }
}
~~~

单向环形列表类：

~~~
package DataStructures.SingleCircleLinkedList;

// 创建单向环形链表
public class SingleCircleLinkedList {
    // 创建一个first节点
    private Boy first = null;
    // 添加节点，构造成一个环形的链表
    public void addBoy(int nums){
        // 验证添加节点的个数
        if (nums < 1){
            System.out.println("nums值有误，添加失败！");
            return;
        }
        // 创建辅助节点
        Boy curBoy = null;
        // for循环创建环形链表
        for (int i = 1; i <= nums; i++){
            // 根据编号创建节点
            Boy boy = new Boy(i);
            // 如果是第一个节点
            if (i == 1){
                first = boy;
                // 构成环
                boy.setNext(first);
                // 让 curBoy 指向第一个节点，作为辅助节点
                curBoy = first;
            }else {
                curBoy.setNext(boy);
                // 形成环
                boy.setNext(first);
                curBoy = boy;
            }
        }
    }

    // 遍历单向环形链表
    public void showBoy(){
        // 判断链表是否为空
        if (first.getNext()==null){
            System.out.println("链表为空！");
            return;
        }
        Boy curBoy = first;
        while (true){
            System.out.printf("小孩的编号：%d\n",curBoy.getNo());
            if (curBoy.getNext() == first){
                // 遍历完毕
                break;
            }
            // curBoy 后移
            curBoy = curBoy.getNext();
        }

    }
}
~~~

测试类：

~~~
package DataStructures.SingleCircleLinkedList;

public class JosephTest {
    public static void main(String[] args) {
        SingleCircleLinkedList singleCircleLinkedList = new SingleCircleLinkedList();
        // 加入5个节点
        singleCircleLinkedList.addBoy(10);
        singleCircleLinkedList.showBoy();
    }
}
~~~

##### 约瑟夫问题：出圈的思路图解

![1648457163220](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648457163220.png)

代码实现：

~~~
// 约瑟夫问题解决
    /**
     * 根据用户的输入，生成一个小孩出圈的顺序
     * n = 5 , 即有5个人
     * k = 1, 从第一个人开始报数
     * m = 2, 数2下
     *
     * 1.  需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.
     * 补充： 小孩报数前，先让 first 和  helper 移动 k - 1次
     * 2.  当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次
     * 3.  这时就可以将first 指向的小孩节点 出圈
     * first = first .next
     * helper.next = first
     * 原来first 指向的节点就没有任何引用，就会被回收
     *
     * 出圈的顺序
     * 2->4->1->5->3
     */
     //@param startNo表示从第几个小孩开始数数
     //@param countNum表示数几下
     //@param nums表示最初有多少小孩在圈中
    public void goOutBoy(int startNo,int countNum,int nums){
        // 先校验链表节点个数
        if (first == null || startNo < 1 || startNo > nums){
            System.out.println("参数输入有误，请重新输入！");
        }

        // 创建辅助指针，帮助完成小孩出圈
        Boy helper = first;
        // 让helper指向最后一个节点
        while (true){
            if (helper.getNext() == first){
                // 说明helper到最后一个节点
                break;
            }
            helper = helper.getNext();
        }
        //小孩报数前，先让 first 和  helper 移动 startNo - 1次
        for (int j=0;j<startNo-1;j++){
            first = first.getNext();
            helper = helper.getNext();
        }
        //当小孩报数时，让first 和 helper 指针同时移动  countNum - 1 次，然后出圈
        // 这是一个循环操作，直到圈中只有一个节点
        while (true){
            // helper == first 说明圈中只有一个节点了
            if (helper == first){
                break;
            }
            //让first 和 helper 指针同时移动  countNum - 1 次，然后出圈
            for (int j =0;j<countNum-1;j++){
                first = first.getNext();
                helper = helper.getNext();
            }
            // 这是first指向的节点，就是要出圈的节点
            System.out.printf("小孩%d出圈\n",first.getNo());
            // 这时将first指向的小孩出圈
            first = first.getNext();
            helper.setNext(first);
        }
        System.out.printf("最后留在圈中的小孩编号为：%d",first.getNo());
    }
~~~

测试代码：

~~~
// 测试小孩出圈
singleCircleLinkedList.goOutBoy(1,2,5);
~~~

# 栈

栈的一个实际需求：

请输入一个表达式：

计算式：[**7\*2\*2-5+1-5+3-3**]

![1648460801725](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648460801725.png)

请问: 计算机底层是如何运算得到结果的？ 注意不是简单的把算式列出运算，因为我们看这个算式 7 * 2 * 2 - 

5, **但是计算机怎么理解这个算式的****(对计算机而言，它接收到的就是一个<font color='red'>字符串</font>)

<font color='cornflowerblue'>**我们讨论的是这个问题。-> 栈**</font>



### 栈的介绍

1. 栈的英文为(stack) 
2. 栈是一个<font color='red'>**先入后出**</font>(FILO-First In Last Out)的有序列表。 
3. 栈(stack)是<font color='red'>限制线性表中元素的插入和删除**只能在线性表的同一端**进行</font>的一种特殊线性表。<font color='orange'>允许插入和删除的一端，为变化的一端，称为**栈顶**(Top)，另一端为固定的一端，称为**栈底**(Bottom)。</font> 
4. 根据栈的定义可知，<font color='green'>最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</font>
5. 出栈(pop)和入栈(push)的概念(如图所示)

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648461132675.png" alt="1648461132675" style="zoom:50%;" /><img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648461144543.png" alt="1648461144543" style="zoom:50%;" />

#### 栈的应用场景：

1. 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 
2. 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。 
3. 表达式的转换[<font color='cornflowerblue'>中缀表达式转后缀表达式</font>]与求值(实际解决)。**面试经典问题** 
4. 二叉树的遍历。 
5. 图形的深度优先(depth一first)搜索法。

#### 1、栈的快速入门

用**数组模拟栈**的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就

用数组模拟栈的**出栈**，**入栈**等操作。

示意图：

![1648461336056](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648461336056.png)

![1648461435154](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648461435154.png)

ArrayStack类：

~~~
package DataStructures.Stack;

import DataStructures.SingleCircleLinkedList.Boy;

// 定义一个 ArrayStack表示栈
public class ArrayStack {
    // 栈的大小
    private int maxSize;
    // 数组模拟栈，数据放在该数组中
    private int[] stack;
    // 指向栈顶
    private int top = -1;

    // 构造器
    public ArrayStack(int maxSize){
        this.maxSize = maxSize;
        // 初始化栈
        stack = new int[this.maxSize];
    }

    // 判断栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }

    // 判断栈空
    public boolean isEmpty(){
        return top == -1;
    }

    // 入栈
    public void push(int value){
        // 判断是否栈满
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top]=value;
    }

    // 出栈并将栈顶数据返回
    public int pop(){
        // 判断栈是否空
        if (isEmpty()){
            // 抛出异常
            throw new RuntimeException("栈空~~~");
        }
        int value = stack[top];
        top--;
        return value;
    }

    // 显示栈的情况【遍历栈】，遍历时，需要从栈顶开始显示数据
    public void show(){
        if (isEmpty()){
            System.out.println("栈空");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top;i>=0;i--){
            System.out.printf("stack[%d] = %d\n",i,stack[i]);
        }
    }
}
~~~

测试类：

~~~
package DataStructures.Stack;

import java.util.Scanner;

// 测试类
public class ArrayStackTest {
    public static void main(String[] args) {
        // 创建ArrayStack对象---表示栈
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        // 控制是否退出菜单
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while (loop){
            System.out.println("show：显示栈");
            System.out.println("push：添加数据到栈（入栈）");
            System.out.println("pop：从栈取出数据（出栈）");
            System.out.println("exit：退出程序");
            System.out.println("请输入您的选择：");
            key = scanner.next();
            switch (key){
                case "show":
                    stack.show();
                    break;
                case "push":
                    System.out.println("请输入一个数：");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case "pop":
                    try {
                        int res = stack.pop();
                        System.out.printf("出栈的数据为：%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case "exit":
                    scanner.close();
                    loop = false;
                    break;
                default:
                    System.out.println("请重新输入您的选择：");
                    break;
            }
        }
        System.out.println("程序退出！");
    }
}
~~~

**链表来模拟栈**

#### 2、栈实现综合计算器

![1648601096152](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648601096152.png)

3+2*6-2  30+2*6-2  7*2*2-5+1-5+3-4

**实现思路：**

![1648605919331](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648605919331.png)

**存在问题：在处理多位数的时候，需使用以下思路：**

代码实现：

1、用数组模拟栈的代码：

~~~
package DataStructures.Stack.calculator;

// 定义一个 ArrayStack表示栈
public class ArrayStack {
    // 栈的大小
    private int maxSize;
    // 数组模拟栈，数据放在该数组中
    private int[] stack;
    // 指向栈顶
    private int top = -1;

    // 构造器
    public ArrayStack(int maxSize){
        this.maxSize = maxSize;
        // 初始化栈
        stack = new int[this.maxSize];
    }

    // 判断栈满
    public boolean isFull(){
        return top == maxSize - 1;
    }

    // 判断栈空
    public boolean isEmpty(){
        return top == -1;
    }

    // 入栈
    public void push(int value){
        // 判断是否栈满
        if (isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top]=value;
    }

    // 出栈并将栈顶数据返回
    public int pop(){
        // 判断栈是否空
        if (isEmpty()){
            // 抛出异常
            throw new RuntimeException("栈空~~~");
        }
        int value = stack[top];
        top--;
        return value;
    }

    // 显示栈的情况【遍历栈】，遍历时，需要从栈顶开始显示数据
    public void show(){
        if (isEmpty()){
            System.out.println("栈空");
            return;
        }
        //需要从栈顶开始显示数据
        for (int i = top;i>=0;i--){
            System.out.printf("stack[%d] = %d\n",i,stack[i]);
        }
    }

    // 查看栈顶的值
    public int peak(){
        return stack[top];
    }

    // 返回运算符的优先级，由程序员确定，优先级使用数字表示，数字越大，优先级越高
    public int priority(int oper){
        if (oper == '*' || oper == '/'){
            return 1;
        }else if (oper == '+' || oper == '-'){
            return 0;
        }else {
            return -1;
        }
    }

    // 判断是不是一个运算符
    public boolean isOper(char val){
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    // 计算方法
    public int cal(int num1,int num2,int oper){
        // res用于存放计算结果
        int res = 0;
        switch (oper){
            case '+':
                res = num1 + num2;
                break;
            case '-':
                res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }

}
~~~

2、计算类代码：**中缀表达式**

~~~
package DataStructures.Stack.calculator;

public class Calculator {
    public static void main(String[] args) {
        String expression = "7*2*2-5+1-5+3-4";
        // 创建两个栈，一个数栈、一个符号栈
        ArrayStack numStack = new ArrayStack(10);
        ArrayStack operStack = new ArrayStack(10);
        // 定义需要的相关变量
        // 用于扫描
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        // 将每次扫描得到的char保存到ch中
        char ch = ' ';
        // 用于拼接多位数
        String keepNum ="";
        // 开始循环扫描表达式
        while (true){
            // 依次得到expression的每一个字符
            ch = expression.substring(index,index+1).charAt(0);
            // 判断ch是什么，然后做相应的处理
            if (operStack.isOper(ch)){
                // 若为运算符
                // 判断当前的符号栈是否为空
                if (!operStack.isEmpty()){
                    // 处理
                    // 如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数
                    // 再从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
                    if (operStack.priority(ch) <= operStack.priority(operStack.peak())){
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        res = numStack.cal(num1,num2,oper);
                        // 把运算的结果入数栈
                        numStack.push(res);
                        // 把当前的符号入符号栈
                        operStack.push(ch);
                    }else {
                        // 如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈
                        operStack.push(ch);
                    }
                }else {
                    // 如果为空直接入符号栈
                    operStack.push(ch);
                }
            }else {
                // 如果是数，直接入数栈
                //numStack.push(ch - 48);
                //分析思路：
                // 1、处理多位数时，不能立即入栈
                // 2、在处理数时，需要查看一下index的后一位，如果是数就进行扫描并拼接，如果是符号就入栈
                // 3、需要定义一个字符串变量，用于拼接
                keepNum += ch;
                // 如果ch是表达式的最后一位，直接入栈
                if (index == expression.length() -1) {
                    numStack.push(Integer.parseInt(keepNum));
                }else{
                    // 判断下一个字符是不是数字，是则继续扫描，若是运算符则入栈
                    if (operStack.isOper(expression.substring(index+1,index+2).charAt(0))){
                        // 是操作符
                        numStack.push(Integer.parseInt(keepNum));
                        // *** 重点清空keepNum
                        keepNum = "";
                    }
                }
            }
            // index+1并判断是否扫描到expression末尾
            index++;
            if (index>=expression.length()){
                break;
            }
        }

        // 依次从栈中取出数据，数栈中最后一个数据就是所得的值
        while (true){
            // 符号栈为空，则计算结束，数栈中只有一个结果
            if (operStack.isEmpty()){
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1,num2,oper);
            // 把运算的结果入数栈
            numStack.push(res);
        }
        System.out.printf("表达式 %s = %d",expression,numStack.pop());
    }
}
~~~

## 栈的基本操作

> 栈是否为空
>
> - isEmpty();
>
> 查询栈顶元素，不变栈
>
> - peek();
>
> 弹出栈顶元素，改变栈
>
> - pop();
>
> 压入栈顶
>
> - push();
>
> 栈中元素的个数 
>
> - size();

### 栈的三种表达式

**<font color='red'>栈的三种表达式：前缀表达式、中缀表达式、后缀表达式</font>**

#### 1、前缀表达式

又称为波兰式，**前缀表达式的运算符位于操作数之前**

（3+4）*5-6对应的前缀表达式为：- * + 3 4 5 6

<font color='orange'>从右至左扫描</font>表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们

做相应的计算（<font color='green'>栈顶元素 和 次顶元素</font>），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出

的值即为表达式的结果。

例如：(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

1. 从右至左扫描，将6、5、4、3压入堆栈
2. 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
3. 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

#### 2、中缀表达式

中缀表达式就是常见的运算表达式，如(3+4)×5-6；

- 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作( 前面我们讲的案例就能看的这个问题 )，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)

#### 3、后缀表达式--逆波兰表达式

1. <font color='cornflowerblue'>后缀表达式又称逆波兰表达式</font>，与前缀表达式相似，只是运算符位于操作数之后
2. 中举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –
3. 再比如:

| 正常的表达式 | 逆波兰表达式  |
| ------------ | ------------- |
| a+b          | a b +         |
| a+(b-c)      | a b c - +     |
| a+(b-c)*d    | a b c – d * + |
| a+d*(b-c)    | a d b c - * + |
| a=1+3        | a 1 3 + =     |

##### 后缀表达式的计算机求值

<font color='orange'>从左至右扫描表达式</font>，<font color='cornflowerblue'>遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们</font>

<font color='cornflowerblue'>做相应的计算（次顶元素 和 栈顶元素），并将结果入栈</font>；重复上述过程直到表达式最右端，最后运算得出

的值即为表达式的结果

例如： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1. 从左至右扫描，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

### 逆波兰计算器

1. <font color='red'>输入一个逆波兰表达式( 后缀表达式) ，使用栈(Stack),，计算其结果：</font>

2. 支持小括号和多位数整数，因为这里我们主要讲的是数据结构，因此计算器进行简化，只支持对整数的计算。

3. 思路分析

   >  (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:
   >
   > 1. 从左至右扫描，将3和4压入堆栈；
   > 2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
   > 3. 将5入栈；
   > 4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
   > 5. 将6入栈；
   > 6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

4. 代码完成

~~~
package DataStructures.Stack.Poland;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
    public static void main(String[] args) {
        // 先定义逆波兰表达式
        // （3+4）*5-6 ---> 3 4 + 5 * 6 -
        // 为了方便，逆波兰表达式的数字和符号使用空格隔开
        String suffixExpression = "3 4 + 5 * 6 -";
        // 1、先将"3 4 + 5 * 6 -"放入到 ArrayList中

        // 2、将ArrayList传递给一个方法，遍历ArrayList，配合栈完成计算
        List<String> list = getListString(suffixExpression);
        System.out.println("list="+list);

        int res = calculate(list);
        System.out.println("计算的结果为："+res);
    }
    // 将一个逆波兰表达式，依次将数据和运算符放入到 ArrayList 中
    public static List<String> getListString(String suffixExpression){
        // 将 suffixExpression 分割
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<String>();
        for (String ele:split){
            list.add(ele);
        }
        return list;
    }

    // 完成对逆波兰表达式的运算
    // 1. 从左至右扫描，将3和4压入堆栈；
    // 2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
    // 3. 将5入栈；
    // 4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
    // 5. 将6入栈；
    // 6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
    public static int calculate(List<String> list){
        // 创建一个栈
        Stack<String> stack = new Stack<String>();
        // 遍历list
        for (String i:list){
            // 使用正则表达式取出数
            if (i.matches("\\d+")){
                // 匹配多位数
                // 入栈
                stack.push(i);
            }else {
                // pop出两个数并运算，再入栈
                int num2 = Integer.parseInt(stack.pop());
                int num1 = Integer.parseInt(stack.pop());
                int res = 0;
                if (i.equals("+")){
                    res = num1 + num2;
                }else if (i.equals("-")){
                    res = num1 - num2;
                }else if (i.equals("*")){
                    res = num1 * num2;
                }else if (i.equals("/")){
                    res = num1 / num2;
                }else{
                    throw new RuntimeException("运算符有误！");
                }
                // res入栈
                stack.push(""+res);
            }
        }
        // 最后留在stack中的就是运算结果
        return Integer.parseInt(stack.pop());
    }

}
~~~

#### 4、中缀表达式转换为后缀表达式

具体步骤如下:

1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2. <font color='orange'>从左至右扫描中缀表达式；</font>
3. 遇到操作数时，将其压s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：

- 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
- 否则，若优先级比栈顶运算符的高，也将运算符压入s1；
- 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；

5. 遇到括号时：

- 如果是左括号“(”，则直接压入s1
- 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，

**案例：**

将中缀表达式“ “1+((2+3) ×4)-5”转换为后缀表达式的过程如下：

| 扫描到的元素 | s2(栈底->栈顶)        | s1 (栈底->栈顶) | 说明                               |
| ------------ | --------------------- | --------------- | ---------------------------------- |
| 1            | 1                     | 空              | 数字，直接入栈                     |
| +            | 1                     | +               | s1为空，运算符直接入栈             |
| (            | 1                     | + (             | 左括号，直接入栈                   |
| (            | 1                     | + ( (           | 同上                               |
| 2            | 1 2                   | + ( (           | 数字                               |
| +            | 1 2                   | + ( ( +         | s1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3                 | + ( ( +         | 数字                               |
| )            | 1 2 3 +               | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +               | + ( ×           | s1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4             | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×           | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +         | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5       | -               | 数字                               |
| 到达最右端   | **1 2 3 + 4 × + 5 -** | 空              | s1中剩余的运算符                   |

结果为："1 2 3 + 4 × + 5 –"

**中缀表达式转后缀表达式的思路步骤分析：**

![1648623665819](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648623665819.png)

<font color='red'>代码实现中缀表达式转为后缀表达式</font>

~~~
  // 将中缀表达式转为对应的List
    public static List<String> toInfixExpressionList(String s){
        // 定义一个List，存放中缀表达式对应的内容
        List<String> list = new ArrayList<String>();
        // 这是一个指针，用于遍历字符串s
        int i=0;
        // 做对多位数的拼接工作
        String str;
        //每遍历到一个字符，就放入c
        char c;
        do{
            // 如果c是一个非数字，就需要加入到list中
            if ((c=s.charAt(i))<48 || (c=s.charAt(i))>57){
                list.add(""+c);
                // i后移实现遍历
                i++;
            }else{
                // 如果是数字，需要考虑多位数的问题
                // 先将str置空
                str = "";
                while (i < s.length() && (c=s.charAt(i))>=48 && (c=s.charAt(i))<=57){
                    // 进行拼接
                    str +=c;
                    i++;
                }
                list.add(str);
            }
        }while (i<s.length());
        return list;
    }

    // 将得到的中缀表达式对应的List => 后缀表达式对应的List
    // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]
    public static List<String> parseSuffixExpressionList(List<String> list){
        // 定义两个栈
        Stack<String> s1 = new Stack<String>(); // 符号栈
        // 说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出
        // 因此比较麻烦，这里我们就不用 Stack<String> 直接使用 List<String> s2
        //Stack<String> s2 = new Stack<String>(); // 存储中间结果的栈
        List<String> s2 = new ArrayList<String>(); // 储存中间结果的Lists2

        // 遍历list
        for (String item:list){
            // 如果是一个数，则入s2
            if (item.matches("\\d+")){
                s2.add(item);
            }else if (item.equals("(")){
                s1.push(item);
            }else if (item.equals(")")){
                //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
                while (!s1.peek().equals("(")){
                    // 将s1的内容弹出来加入到s2，直到遇到左括号
                    s2.add(s1.pop());
                }
                // 将 ( 弹出 s1
                s1.pop();
            }else {
                // 当item的优先级 <= s1栈顶的运算符的优先级
                // 将s1 栈顶的运算符弹出并加入到s2中，在此转到（4.1）与s1 中新的栈顶运算符相比较
                // 缺少一个比较优先级的方法
                while (s1.size() != 0 && Operation.getValue(s1.peek())>=Operation.getValue(item)){
                    s2.add(s1.pop());
                }
                // 还需要将item压入栈中
                s1.push(item);
            }
        }
        // 将s1中剩余的运算符依次弹出并加入s2中
        while (s1.size()!=0){
            s2.add(s1.pop());
        }

        return s2;
    }
~~~

测试代码：

~~~
 String expression = "1+((2+3)*4)-5";
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式对应的List："+infixExpressionList);
        List<String> parseSuffixExpressionList = parseSuffixExpressionList(infixExpressionList);
        System.out.println("后缀表达式对应的List："+parseSuffixExpressionList);
        System.out.printf("expression=%d\n",calculate(parseSuffixExpressionList));
~~~

##### 完整的逆波兰计算器

~~~
package com.atguigu.reversepolishcal;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.regex.Pattern;

public class ReversePolishMultiCalc {

	 /**
     * 匹配 + - * / ( ) 运算符
     */
    static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)";

    static final String LEFT = "(";
    static final String RIGHT = ")";
    static final String ADD = "+";
    static final String MINUS= "-";
    static final String TIMES = "*";
    static final String DIVISION = "/";

    /**
     * 加減 + -
     */
    static final int LEVEL_01 = 1;
    /**
     * 乘除 * /
     */
    static final int LEVEL_02 = 2;

    /**
     * 括号
     */
    static final int LEVEL_HIGH = Integer.MAX_VALUE;


    static Stack<String> stack = new Stack<>();
    static List<String> data = Collections.synchronizedList(new ArrayList<String>());

    /**
     * 去除所有空白符
     * @param s
     * @return
     */
    public static String replaceAllBlank(String s ){
        // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]
        return s.replaceAll("\\s+","");
    }

    /**
     * 判断是不是数字 int double long float
     * @param s
     * @return
     */
    public static boolean isNumber(String s){
        Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$");
        return pattern.matcher(s).matches();
    }

    /**
     * 判断是不是运算符
     * @param s
     * @return
     */
    public static boolean isSymbol(String s){
        return s.matches(SYMBOL);
    }

    /**
     * 匹配运算等级
     * @param s
     * @return
     */
    public static int calcLevel(String s){
        if("+".equals(s) || "-".equals(s)){
            return LEVEL_01;
        } else if("*".equals(s) || "/".equals(s)){
            return LEVEL_02;
        }
        return LEVEL_HIGH;
    }

    /**
     * 匹配
     * @param s
     * @throws Exception
     */
    public static List<String> doMatch (String s) throws Exception{
        if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty");
        if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number");

        s = replaceAllBlank(s);

        String each;
        int start = 0;

        for (int i = 0; i < s.length(); i++) {
            if(isSymbol(s.charAt(i)+"")){
                each = s.charAt(i)+"";
                //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 && 操作符优先级不是( )的优先级 及是 ) 不能直接入栈
                if(stack.isEmpty() || LEFT.equals(each)
                        || ((calcLevel(each) > calcLevel(stack.peek())) && calcLevel(each) < LEVEL_HIGH)){
                    stack.push(each);
                }else if( !stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek())){
                    //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈
                    while (!stack.isEmpty() && calcLevel(each) <= calcLevel(stack.peek()) ){
                        if(calcLevel(stack.peek()) == LEVEL_HIGH){
                            break;
                        }
                        data.add(stack.pop());
                    }
                    stack.push(each);
                }else if(RIGHT.equals(each)){
                    // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈
                    while (!stack.isEmpty() && LEVEL_HIGH >= calcLevel(stack.peek())){
                        if(LEVEL_HIGH == calcLevel(stack.peek())){
                            stack.pop();
                            break;
                        }
                        data.add(stack.pop());
                    }
                }
                start = i ;    //前一个运算符的位置
            }else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") ){
                each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1);
                if(isNumber(each)) {
                    data.add(each);
                    continue;
                }
                throw new RuntimeException("data not match number");
            }
        }
        //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列
        Collections.reverse(stack);
        data.addAll(new ArrayList<>(stack));

        System.out.println(data);
        return data;
    }

    /**
     * 算出结果
     * @param list
     * @return
     */
    public static Double doCalc(List<String> list){
        Double d = 0d;
        if(list == null || list.isEmpty()){
            return null;
        }
        if (list.size() == 1){
            System.out.println(list);
            d = Double.valueOf(list.get(0));
            return d;
        }
        ArrayList<String> list1 = new ArrayList<>();
        for (int i = 0; i < list.size(); i++) {
            list1.add(list.get(i));
            if(isSymbol(list.get(i))){
                Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i));
                list1.remove(i);
                list1.remove(i-1);
                list1.set(i-2,d1+"");
                list1.addAll(list.subList(i+1,list.size()));
                break;
            }
        }
        doCalc(list1);
        return d;
    }

    /**
     * 运算
     * @param s1
     * @param s2
     * @param symbol
     * @return
     */
    public static Double doTheMath(String s1,String s2,String symbol){
        Double result ;
        switch (symbol){
            case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break;
            case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break;
            case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break;
            case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break;
            default : result = null;
        }
        return result;

    }

    public static void main(String[] args) {
        //String math = "9+(3-1)*3+10/2";
        String math = "12.8 + (2 - 3.55)*4+10/5.0";
        try {
            doCalc(doMatch(math));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
~~~

# 递归

递归适于解决的问题：

1. 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)
2. 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
3. 将用栈解决的问题-->递归代码比较简洁

**递归需要遵守的重要规则：**

1. <font color='green'>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</font>
2. <font color='orange'>方法的局部变量是独立的，不会相互影响, 比如n变量</font>
3. 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
4. <font color='red'>递归必须向退出递归的条件逼近</font>，<font color='blue'>否则就是无限递归</font>,出现StackOverflowError，死龟了:)
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行2完毕。

#### 1、递归调用机制019

![1648686811377](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648686811377.png)

#### 2、示例代码

~~~
package DataStructures.recursion;

public class RecursionTest {

    public static void main(String[] args) {
        test(10);
        System.out.println("阶乘结果为："+factorial(10));
    }

    // 打印问题
    public static void test(int n){
        if (n>2){
            test(n-1);
        }
        //else{
        //    System.out.println("n="+n);
        //}
        System.out.println("n="+n);
    }
    // 阶乘问题
    public static int factorial(int n){
        if (n==1){
            return 1;
        }else {
            return factorial(n-1)*n;
        }
    }
}
~~~

### 递归-迷宫问题

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648687711215.png" alt="1648687711215" style="zoom:67%;margin:0" />

> 说明:
>
> 1. 小球得到的路径，和程序员设置的找路策略有关即：找路的 上下左右的顺序相关
> 2. 再得到小球路径时，可以先使用(下右上左)，再改成(上右下左)，看看路径是不是有变化
> 3. 测试回溯现象
> 4. 思考: 如何求出最短路径?

实现代码：

~~~
package DataStructures.recursion;

public class MiGong {
    public static void main(String[] args) {
        // 创建一个二维数组，模拟迷宫
        int[][] map = new int[8][7];
        // 使用1表示墙，无法通过
        // 上下全部置为1
        for (int i=0;i<7;i++){
            map[0][i]=1;
            map[7][i]=1;
        }
        // 左右全部置为1
        for (int i=0;i<8;i++){
            map[i][0]=1;
            map[i][6]=1;
        }
        // 设置挡板
        map[3][1]=1;
        map[3][2]=1;

        show(map);

        // 使用递归回溯给小球找路
        setWay(map,1,1);
        System.out.println("小球走过并标识过的地图：");
        show(map);

    }
    // 展示数组
    public static void  show(int[][] map){
        // 输出数组
        for (int[] row:map){
            for (int i=0;i<row.length;i++){
                System.out.printf("%d\t",row[i]);
            }
            System.out.println();
        }
    }

    // 使用递归回溯给小球找路
    // 如果小球能到达map[6][5]位置，则说明通路找到
    // map[i][j]为0表示未走过，1表示墙，2表示通路，3表示探测过但不能走通
    // 策略：下->右->上->左，如果该点走不通再回溯
    /**
     * @param map 表示地图
     * @param i 表示从哪个位置开始找
     * @param j (i,j)为出发点
     * @return 如果找到通路返回true，否则返回false
     */
    public static boolean setWay(int[][] map,int i,int j){
        if (map[6][5]==2){
            // 通路已经找到
            return true;
        }else {
            if (map[i][j]==0){
                // 若当前这个点未走过，则按策略走
                map[i][j]=2; // 假定该点可以走通
                if (setWay(map,i+1,j)){
                    // 向下走
                    return true;
                }else if(setWay(map,i,j+1)){
                    return true;
                }else if (setWay(map,i-1,j)){
                    return true;
                }else if (setWay(map,i,j-1)){
                    return true;
                }else {
                    // 说明该点走不通
                    map[i][j]=3;
                    return false;
                }
            }else {
                // 1表示墙，2表示通路，3表示探测过但不能走通
                return false;
            }
        }
    }
}
~~~

### 递归-八皇后问题（回溯）

**八皇后问题介绍：**

八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于

1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即： **任意两个皇后都不能处于同一**

**行、同一列或同一斜线上，问有多少种摆法（92） 。**

#### 八皇后问题算法思路分析：

1. 第一个皇后先放第一行第一列
2. 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
3. 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4. 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.
5. 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤

> 说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决
>
> 问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1
>
> 个皇后，放在第i+1行的第val+1列

<font color='green'>解题思路：</font>

![1648691023211](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648691023211.png)

代码实现：

~~~
package DataStructures.recursion;

public class Queue8 {
    // 定义一个max，表示共有的皇后数
    int max =8 ;
    // 放置皇后的位置
    int[] array = new int[max];
    static int count =0;
    public static void main(String[] args) {
        Queue8 queue8 = new Queue8();
        queue8.check(0);
        System.out.println("一共有："+count+"种解法！");
    }
    // 编写一个方法，放置第n个皇后
    private void check(int n){
        if (n == max){
            print();
            return;
        }
        // 若没有就依次放入皇后，并判断是否冲突
        for (int i=0;i<max;i++){
            // 先把当前的皇后放置到该行的第一列
            array[n]=i;
            // 判断当放置第n个皇后到i列时，是否冲突
            if (judge(n)){
                // 不冲突，接着放n+1个皇后，开始递归
                check(n+1);
             }
            // 冲突则继续执行array[n]=i，即将第n个皇后，放置在本行的后移的一个位置
        }
    }

    // 查看放置第n个皇后时，检测该皇后是否与已摆放的皇后冲突
    /**
     *
     * @param n 表示第n个皇后
     * @return
     */
    private boolean judge(int n){
        for (int i=0;i<n;i++){
            // 1、array[i]==array[n]：判断第n个皇后是否和前面的n-1个皇后在同一列
            // 2、Math.abs(n-i)==Math.abs(array[n]-array[i])表示判断第n个皇后是否和第i个皇后在同一斜线上
            // n表示行数，array[n]表示列数
            if (array[i]==array[n] || Math.abs(n-i)==Math.abs(array[n]-array[i])){
                return false;
            }
        }
        return true;
    }

    // 将皇后摆放的位置输出
    private void print(){
        count++;
        for (int i:array){
            System.out.print(i+" ");
        }
        System.out.println();
    }
}
~~~

# 排序算法

### 1、排序算法介绍

<font color='blue'>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</font>

排序的分类：

1. <font color='green'>内部排序：</font>指将需要处理的所有数据都加载到内部存储器中进行排序。
2. <font color='green'>外部排序法：</font>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。
3. 常见的排序算法分类( 见下图)

![1648694564202](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648694564202.png)

### 2、算法的时间复杂度

**<font color='green'>度量一个程序( ( 算法) ) 执行时间的两种方法：</font>**

1. 事后统计的方法
   这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，<font color='red'>要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</font>
2. 事前估算的方法
   通过<font color='orange'>分析某个算法的时间复杂度</font>来判断哪个算法更优。

#### 1、语句频度

**时间频度：**<font color='blue'>一个算法花费的时间与算法中语句的执行次数成正比例</font>，哪个算法中语句执行次数多，它花费时

间就多。 <font color='green'>**一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。**</font>

##### 举例说明：

比如计算1-100所有数字之和，我们设计两种算法：

~~~
public int sum(){
        int total=0;
        int end=100;
        for (int i=1;i<=end;i++){
            total+=i;
        }
        return total;
    }
~~~

时间复杂度：T(n) = n+1

~~~
 public int total(int end){
        return (1+end)*end/2;
    }
~~~

时间复杂度：T(n)=1

##### 忽略常数项

|      | T(n)=2n+20 | T(n)=2*n | T(3n+10) | T(3n) |
| ---- | ---------- | -------- | -------- | ----- |
| 1    | 22         | 2        | 13       | 3     |
| 2    | 24         | 4        | 16       | 6     |
| 5    | 30         | 10       | 25       | 15    |
| 8    | 36         | 16       | 34       | 24    |
| 15   | 50         | 30       | 55       | 45    |
| 30   | 80         | 60       | 100      | 90    |
| 100  | 220        | 200      | 310      | 300   |
| 300  | 620        | 600      | 910      | 900   |

![1648695664068](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648695664068.png)

结论：

1. 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略
2. 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略

<font color='red'>所以，在统计时间频度时，常数项可以忽略</font>

##### 忽略低次项

|      | T(n)=2n^2+3n+10 | T(2n^2) | T(n^2+5n+20) | T(n^2) |
| ---- | --------------- | ------- | ------------ | ------ |
| 1    | 15              | 2       | 26           | 1      |
| 2    | 24              | 8       | 34           | 4      |
| 5    | 75              | 50      | 70           | 25     |
| 8    | 162             | 128     | 124          | 64     |
| 15   | 505             | 450     | 320          | 225    |
| 30   | 1900            | 1800    | 1070         | 900    |
| 100  | 20310           | 20000   | 10520        | 10000  |

![1648695854818](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648695854818.png)

结论：

1. 2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10
2. n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20

<font color="red">所以，在统计时间频度时，低次项可以忽略</font>

##### 忽略系数

|      | T(3n^2+2n) | T(5n^2+7n) | T(n^3+5n) | T(6n^3+4n) |
| ---- | ---------- | ---------- | --------- | ---------- |
| 1    | 5          | 12         | 6         | 10         |
| 2    | 16         | 34         | 18        | 56         |
| 5    | 85         | 160        | 150       | 770        |
| 8    | 208        | 376        | 552       | 3104       |
| 15   | 705        | 1230       | 3450      | 20310      |
| 30   | 2760       | 4710       | 27150     | 162120     |
| 100  | 30200      | 50700      | 1000500   | 6000400    |

![1648695967221](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648695967221.png)

结论：

1. 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明这种情况下, 5和3可以忽略。
2. 而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键

### 2、问题规模

问题规模是算法求解问题输入量的多少，是问题大小的本质表示，一般用整数n表示，<font color='blue'>n越大，算法的执行时间越长。</font>

<font color='red'>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行的次数和执行一次所需时间的乘积；</font>

## 时间复杂度

1. 一般情况下，<font color='green'>算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示</font>，若有某个辅助函数f(n)，使得当n趋近于无穷大时，<font color='blue'>T(n) / f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。</font>记作 T(n)=Ｏ( f(n) )，**<font color='orange'>称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。</font>**
2. T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。<font color='green'>（常数项可以忽略，低次项可以忽略，系数可以忽略）</font>
3. 计算时间复杂度的方法：

> - 用<font color='red'>常数1代替运行时间中的所有加法常数</font> T(n)=n²+7n+6 => T(n)=n²+7n+1
> - 修改后的运行次数函数中，<font color='orange'>只保留最高阶项</font> T(n)=n²+7n+1 => T(n) = n²
> - <font color='green'>去除最高阶项的系数 </font>T(n) = n² => T(n) = n² => O(n²)

### 常见的时间复杂度

> 1. 常数阶O(1)
> 2. 对数阶O(log 2 n)
> 3. 线性阶O(n)
> 4. 线性对数阶O(nlog 2 n)
> 5. 平方阶O(n^2)
> 6. 立方阶O(n^3)
> 7. k次方阶O(n^k)
> 8. 指数阶O(2^n)

![1648696713232](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648696713232.png)

> 1. 常见的算法时间复杂度由小到大依次为：Ο(1) ＜Ο(log 2 n) ＜Ο(n) ＜Ο(nlog 2 n) ＜Ο(n 2 )＜ Ο(n 3 ) ＜ Ο(n k ) ＜Ο(2 n ) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低
> 2. 从图中可见，我们应该尽可能避免使用指数阶的算法

#### 1、常数阶O(1)

无论代码执行了多少行，<font color='red'>只要是没有循环等复杂结构</font>，那这个代码的时间复杂度就都是O(1)

![1648700862115](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648700862115.png)

#### 2、对数阶O(log 2 n)

说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 

2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x =log 2 n也就是说当循环 log 2 n 次以后，

这个代码就结束了。因此这个代码的时间复杂度为：O(log 2 n) 。 <font color='blue'>O(log 2 n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log 3 n) 。</font>

![1648700940723](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648700940723.png)

![1648700959296](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648700959296.png)

#### 3、线性阶O(n)

![1648701068647](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648701068647.png)

说明：这段代码，<font color='green'>for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的</font>，因此这类代码

都可以用O(n)来表示它的时间复杂度

#### 4、线性对数阶O(nlogN)

![1648701120279](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648701120279.png)

说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间

复杂度就是 n * O(logN)，也就是了O(nlogN)

#### 5、平方阶O(n²)

![1648701198755](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648701198755.png)

说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段

代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²) 如果将其中一层循环的n改成m，那它*

*的时间复杂度就变成了 O(m*n)

#### 6、立方阶O(n³)、K 次方阶O(n^k)

说明：参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似

### 平均时间复杂度和最坏时间复杂度

#### 1、平均时间复杂度

平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。

#### 2、最坏时间复杂度

<font color='red'>最坏情况下的时间复杂度称最坏时间复杂度。</font>**一般讨论的时间复杂度均是最坏情况下的时间复杂度。**这样做

的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间

不会比最坏情况更长。

**<font color='green'>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图：) 。</font>**

![1648701470217](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648701470217.png)

## 空间复杂度

1. 类似于时间复杂度的讨论，<font color='orange'>一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间</font>，它也是问题规模n的函数。
2. **空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。**有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。
3. 在<font color='green'>做算法分析时， 主要讨论的是时间复杂度</font>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间。

# 冒泡排序

**<font color='red'>冒泡排序（Bubble Sorting）的基本思想是：</font>**通过**对待排序序列从前向后（从下标较小的元素开始）**,**依次比**

**较相邻元素的值**，**若发现逆序则交换，使值较大的元素逐渐从前移向后部**，就像水底下的气泡一样逐渐向上

冒。

> 因为排序的过程中，各元素不断接近自己的位置， 如果一趟比较下来没有进行过交换，就说明序列有序 ，因此<font color='green'>要在排序过程中设置一个标志flag 判断元素是否进行过交换</font>。从而减少不必要的比较。( 这里说的优化，可以在冒泡排序写好后，再进行)

##### 冒泡排序图解：

![1648702237298](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648702237298.png)

##### 代码实现：

将五个无序的数：3, 9, -1, 10, -2，使用冒泡排序法将其排成一个<font color='green'>从小到大</font>的序列

实现代码：

~~~
int [] arr = new int[]{3, 9, -1, 10, -2};

// 第一趟排序：将最大的数排在最后一位
// 临时变量
int temp =0;
for (int j=0;j<arr.length-1;j++){
	for (int i=0;i<arr.length-1-j;i++){
    	if (arr[i] > arr[i+1]){
        	 temp = arr[i];
             arr[i] = arr[i+1];
             arr[i+1] = temp;
          }
     }
 }
System.out.println("冒泡排序后的数组为：");
System.out.println(Arrays.toString(arr));
~~~

优化代码：

设置flag，查看每次排序是否交换过：

~~~
int [] arr = new int[]{3, 9, -1, 10, -2};

// 第一趟排序：将最大的数排在最后一位
// 临时变量
int temp = 0;
// 标识变量，表示是否进行过交换
boolean flag = false;
for (int j=0;j<arr.length-1;j++){
    for (int i=0;i<arr.length-1-j;i++){
        if (arr[i] > arr[i+1]){
            flag=true;
            temp = arr[i];
            arr[i] = arr[i+1];
            arr[i+1] = temp;
        }
    }
    if (!flag){
        //在一趟排序中，一次交换都没有发生过
        break;
    }else {
        // 重置flag进行下一次循环的判断
        flag=false;
    }
    System.out.printf("第%d次排序后的数组为：\n",j+1);
    System.out.println(Arrays.toString(arr));
}
~~~

![1648704691962](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648704691962.png)

# 选择排序

<font color='red'>选择式排序也属于内部排序法</font>，**是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达**

**到排序的目的。**

#### 1、选择排序思想

> 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取
>
> 最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中
>
> 选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从
>
> arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，**总共通过n-1次**，得到一个按排序码从小到大排列的有序
>
> 序列。

#### 2、选择排序思路图解

![1648706035679](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648706035679.png)

#### 3、代码实现

~~~
public static void SelectSort(int[] arr){
        int temp = 0;
        for (int i=0;i<arr.length;i++){
            for (int j=i+1;j<arr.length;j++){
                if (arr[i]>arr[j]){
                    temp=arr[i];
                    arr[i]=arr[j];
                    arr[j]=temp;
                }
            }
        }
    }
~~~

~~~
int[] arr = new int[]{101,34,119,1};
SelectSort(arr);
System.out.println("选择排序后："+ Arrays.toString(arr));
~~~

**选择排序优化：**

~~~
for (int i=0;i<arr.length;i++){
            int minIndex=i;
            int min = arr[i];
            for (int j=i+1;j<arr.length;j++){
                if (min > arr[j]){
                    min=arr[j];
                    minIndex=j;
                }
            }
            if (minIndex!=i){
                arr[minIndex]=arr[i];
                arr[i]=min;
            }
        }
~~~

# 快速排序

快速排序（Quick Sort）是由冒泡排序改进而得到的。在冒泡排序中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。<font color='green'>如果能通过两个（不相邻）记录的一次交换，消除多个逆序，则会大大的加快排序的速度，即快速排序法。</font>

#### 1、算法步骤

在待排序的n个记录中任取一个记录（通常选取第一个）作为枢轴，设其关键字为pivotkey，经过一趟排序后，把所有的关键字小于pivotkey的记录交换到前面，把所有的关键字大于pivotkey的记录交换到后面，结果将待排序记录分成两个子表，最后将枢轴放置在分界处的位置，然后，分别对左右子表重复上述操作，知道每一个子表中只有一个记录时，排序完成。

#### 2、基本思想

> 基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部
>
> 分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进
>
> 行，以此达到整个数据变成有序序列。



#### 3、图解

![1648713900708](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648713900708.png)

#### 4、实例

要求: 对 [-9,78,0,23,-567,70] 进行 从小到大的排序，要求使用快速排序法。【 测试8w和800w 】

说明[ 验证分析 ]:

1. 如果取消左右递归，结果是 -9 -567 0 23 78 70
2. 如果取消右递归, 结果是 -567 -9 0 23 78 70
3. 如果取消左递归, 结果是 -9 -567 0 23 70 78

**实现代码：**

~~~
// 快速排序
    public static void QuickSort(int[] arr,int left,int right){
        int l=left; // 左下标
        int r = right; // 右下标
        // pivot是中轴值
        int pivot = arr[(left+right)/2];
        int temp=0;

        // while 循环的目的是让比pivot小的值放到左边，比pivot大的值放到右边
        while (l<r){
            // 在pivot左边找到大于等于pivot的值才退出
            while (arr[l]<pivot){
                l+=1;
            }
            // 在pivot右边找到小于等于pivot的值才退出
            while (arr[r]>pivot){
                r-=1;
            }
            // pivot左右两边的值已经按照左边全部是小于等于pivot的数，右边全部是大于等于pivot的数
            if (l>=r){
                break;
            }
            // 交换
            temp=arr[l];
            arr[l]=arr[r];
            arr[r]=temp;

            // 如果交换后，arr[l]==pivot的值，r--,前移
            if (arr[l]==pivot){
                r--;
            }
            if (arr[r]==pivot){
                l++;
            }
        }
        // 如果 l==r ，必须l++,r--，否则会出现栈溢出
        if (l==r){
            l++;
            r--;
        }
        // 向左递归
        if (left<r){
            QuickSort(arr,left,r);
        }
        // 向右递归
        if (right>r){
            QuickSort(arr,l,right);
        }
    }
~~~

# 插入排序

#### 1、插入排序介绍

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目

的。

#### 2、插入排序法思想

<font color='orange'>插入排序（Insertion Sorting）</font>的基本思想是：把n个待排序的元素看成为<font color='green'>一个有序表和一个无序表</font>，**开始时**

**有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把**

**它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。**

![1648708076625](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648708076625.png)

101, 34, 119, 1  请从小到大排序：

代码实现：

![1650890052689](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650890052689.png)

优化：

~~~
// 判断是否需要赋值
if (insertIndex+1!=i){
    arr[insertIndex+1]=insertVal;
}
~~~

#### 3、存在问题

结论 : 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。

希尔排序可以解决此问题。

# 希尔排序

#### 1、希尔排序介绍

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。<font color='red'>希尔排序也是一种插入排序</font>，它是简单插入

排序经过改进之后的一个 更高效的版本，**也称为缩小增量排序。**

#### 2、希尔排序基本思想

希尔排序是把记录**按下标的一定增量分组**，<font color='red'>对每组使用直接插入排序算法排序</font>；随着增量逐渐减少，每组包

含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

![1648711249943](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648711249943.png)

![1648711379266](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648711379266.png)

#### 3、希尔排序实例

> 有一群小牛, 考试成绩分别是 {8,9,1,7,2,3,5,4,6,0} 请从小到大排序。请分别使用
>
> 1. 希尔排序时， 对有序序列在插入时采用交换法, 并测试排序速度.
> 2. 希尔排序时， 对有序序列在插入时采用移动法, 并测试排序速度

#### 4、代码实现

##### 对有序序列在插入时采用交换法

gap是步长，等于arr.length/2

~~~
public static void ShellSort(int[] arr){
        int temp=0;
        for (int gap = arr.length/2;gap>0;gap/=2){
            for (int i=gap;i<arr.length;i++){
                // 遍历各组中所有的元素
                for (int j=i-gap;j>=0;j-=gap){
                    // 如果当前元素大于加上步长后的那个元素，说明交换
                    if (arr[j]>arr[j+gap]){
                        temp = arr[j];
                        arr[j]=arr[j+gap];
                        arr[j+gap]=temp;
                    }
                }
            }
            System.out.println("每轮排序后："+Arrays.toString(arr));
        }
    }
~~~

**缺点：速度较慢**

##### 对有序序列在插入时采用移动法

实现代码：

~~~
// 希尔排序-->移步法
    public static void ShellSort(int[] arr){
        // 增量gap，并逐步的缩小增量
        for (int gap = arr.length/2;gap>0;gap/=2){
            // 从gap个元素开始，逐个对其所在的组进行直接插入排序
            for (int i=gap;i<arr.length;i++){
                int j = i;
                int temp = arr[i];
                if (arr[j]<arr[j-gap]){
                    while (j-gap>=0 && temp < arr[j-gap]){
                        // 移动
                        arr[j] = arr[j-gap];
                        j -= gap;
                    }
                    // 退出while循环，代表给temp找到了插入的位置
                    arr[j]=temp;
                }
            }
        }
    }
~~~

**优点：速度大大提高**

# 归并排序

#### 1、归并排序介绍

<font color='orange'>归并排序（ MERGE-SORT ）是利用归并的思想实现的排序方法，</font>该算法采用经典的分治（ divide-and-

conquer ）策略（分治法将问题 分 (divide) 成一些小的问题然后递归求解，而 治 (conquer) 的阶段则将分的阶

段得到的各答案"  修补"  在一起，即分而治之) ) 。

#### 2、示意图

![1648716401252](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648716401252.png)

> 说明：
>
> 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们**<font color='green'>采用递归去实现</font>**（也可采用迭代的方式去
>
> 实现）。<font color='green'>分阶段可以理解为就是递归拆分子序列的过程。</font>

> 治阶段：我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将
>
> [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤：

![1648716523093](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648716523093.png)

![1648716562776](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648716562776.png)

#### 3、实例

给你一个数组，val arr = Array(9,8,7,6,5,4,3,2,1)，请使用归并排序完成排序。

![1650890112010](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650890112010.png)

运行截图：

![1648720606519](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648720606519.png)

# 基数排序

#### 1、基数排序介绍

1. **基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”**（bucket sort）或bin sort，顾名思义，<font color='green'>它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。</font>
2. <font color='blue'>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</font>
3. 基数排序(Radix Sort)是 桶排序的扩展
4. 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：**将整数按位数切割成不同的数字，然后按每个位数分别比较。**

#### 2、基本思想

1. 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
2. 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤

#### 3、图文说明

将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。

![1648721046596](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648721046596.png)

![1648721699525](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648721699525.png)

#### 4、代码实现

~~~
package DataStructures.Sort;

import java.util.Arrays;

public class RadixSortTest {
    public static void main(String[] args) {
        int[] arr = {53, 3, 542, 748, 14, 214};
        RadixSort(arr);
    }

    // 基数排序方法
    public static void RadixSort(int[] arr){
        // 得到数组中最大数的位数
        int max = arr[0];// 假设第一位为最大
        for (int k=0;k<arr.length;k++){
            if (arr[k]>max){
                max=arr[k];
            }
        }
        // 得到最大数的位数
        int maxLength = (max+"").length();

        //定义一个二维数组表示10个桶，每个桶就是一个一维数组
        // 为了防止放数的时候，数据溢出，则每个桶的大小为arr.length
        // 基数排序是使用空间换时间的经典算法
        int [][] bucket = new int[10][arr.length];

        // 为了记录每个桶中实际存放了多少数据，我们定义一个一维数组来记录各个桶每次放入的数据个数
        int[] bucketElementCounts = new int[10];

        for (int i=0;i<maxLength;i++){
            //依次对个、十、百位的数进行排序处理
            for (int j=0;j<arr.length;j++){
                // 取出每个元素的个位(10^i)
                int digitOfElement = arr[j]/(int)(Math.pow(10,i))%10;
                // 放入对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            // 按照这个桶的顺序（一维数组的下标一次取出数据，放入原来的数组中）
            int index=0;
            // 遍历每一个桶，并将桶中的数据，放入到原数组
            for (int k=0;k<bucketElementCounts.length;k++){
                // 如果桶中有数据，才放入到原数组中
                if (bucketElementCounts[k]!=0) {
                    // 说明对应的第K个桶中有数据
                    // 循环第K个桶，即第K个一维数组，放入数据到原数组
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        // 取出元素，放到arr中
                        arr[index++] = bucket[k][l];
                    }
                }
                // 将桶中的数据置为0，方便下一次遍历的使用
                bucketElementCounts[k]=0;

            }

            System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr = "+ Arrays.toString(arr));

        }
    }
}
~~~

![1648728516401](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648728516401.png)

**基数排序会耗费额外的内存**

#### 总结

> 基数排序的说明: :
>
> 1. 基数排序是对传统桶排序的扩展，速度很快.
> 2. 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时,容易造成 OutOfMemoryError 
> 3. 基数排序时稳定的。[ 注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前， 则称这种排序算法是稳定的；否则称为不稳定的 ]
> 4. 有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考：https://code.i-harness.com/zh-CN/q/e98fa9

## 常用排序算法总结和对比

![1648728644468](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648728644468.png)

> **<font color='red'>相关术语解释</font>**：
>
> 1. 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
> 2. 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
> 3. 内排序：所有排序操作都在内存中完成；
> 4. 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
> 5. 时间复杂度： 一个算法执行所耗费的时间。
> 6. 空间复杂度：运行完一个程序所需内存的大小。
> 7. n: 数据规模
> 8. k: “桶”的个数
> 9. In-place: 不占用额外内存
> 10. Out-place: 占用额外内存数据结构和算法

# 查找算法

在 java 中，我们常用的查找有四种: :

1. 顺序(线性) 查找
2. 二分查找 / 折半查找
3. 插值查找
4. 斐波那契查找

## 线性查找算法

> 顺序查找过程：从表的一段开始，依次将记录的关键字和给定的值进行比较，若某个记录的关键字和给
>
> 定的值相等，则查找成功；反之，若扫描整个表后，仍未找到关键字和给定值相等的记录，则查找失
>
> 败。

- **顺序查找方法既适用于线性表的顺序存储结构，有适用于线性表的链式存储结构**
- 可以给顺序查找设置监视哨

有一个数列： {1,8, 10, 89, 1000,1234} ，判断数列中是否包含此名称【 顺序查找 】 要求 : 如果找到了，就

提示找到，并给出下标值。

**代码实现：**

~~~
package DataStructures.Search;

public class SequentialSearch {
    public static void main(String[] args) {
        int[] arr = {1,8, 10, 89, 1000,1234};
        int index = orderFind(arr,89);
        if (index==-1){
            System.out.println("未找到该值！");
        }else {
            System.out.println("找到，下标为:"+index);
        }
    }
    public static int orderFind(int[] arr,int val){
        for (int i=0;i<arr.length;i++){
            if (arr[i]==val){
                return i;
            }
        }
        return -1;
    }
}
~~~

拓展：找到一个数组中所有的与val相等的数

```
int[] arr1 = {1,8, 10, 89, 1000, 1000 ,1234};
```

~~~
public static int[] orderFindAll(int[] arr,int val){
        int[] indexs= new int[arr.length];
        int index=0;
        for (int i=0;i<arr.length;i++){
            if (arr[i]==val){
                indexs[index++]=i;
            }
        }
        return indexs;
    }
~~~

## 二分查找算法



> 二分查找也称为折半查找，它是一种效率较高的查找方法；<font color='red'>二分查找要求线性表必须是采用顺序存储结构，而且表中的元素按照关键字有序的排列。</font>
>
> 二分查找的过程：从表中的中间记录开始，如果给定的值和中间记录的关键字相等，则查找成功；如果给定值大于或小于中间记录的关键字，则在表中大于或小于中间记录的那一半中查找，这样重复操作，直到查找成功，或者在某一步中查找区间为空，则代表查找失败。

- 二分查找每一次查找比较都使查找范围缩小一半，使得查找效率相比于顺序查找有所提高；

- <font color='green'>二分查找的思路图解：</font>

  ![1648798066961](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648798066961.png)

> 请对一个 有序数组 进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示" " 没有这个数" " 。

~~~
// 非递归的方法
    public static int binaryFind1(int[] arr,int val){
        int left =0;
        int right = arr.length-1;
        while (left<right){
            int mid = (left+right)/2;
            if (val < arr[mid]){
                // 向左边查找
                right = mid-1;
            }else if (val > arr[mid]){
                // 向右边查找
                left = mid+1;
            }else{
                return mid;
            }
        }

        return -1;
    }
~~~

**递归的思路：**

~~~
public static int binaryFind(int[] arr,int left,int right,int val){
        if (left > right){
            // 表示递归了整个数组，但是没有找到
            return -1;
        }
        int mid = (left+right)/2;
        if (arr[mid]==val){
            return mid;
        }else if (val<arr[mid]){
            // 向左递归
            return binaryFind(arr,left,mid-1,val);
        }else {
            // 向右递归
            return binaryFind(arr,mid+1,right,val);
        }
    }
~~~

思考：

> {1,8, 10, 89, 1000, 1000 ,1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000。

实现代码：

~~~
// 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000。
// 将所有满足1000的元素下标放入ArrayList中
    public static ArrayList<Integer> binaryFindAll(int[] arr, int left, int right, int val){
        if (left > right){
            // 表示递归了整个数组，但是没有找到，返回空列表
            return new ArrayList<Integer>();
        }
        int mid = (left+right)/2;
        if (arr[mid]==val){
            ArrayList<Integer> resIndexList = new ArrayList<Integer>();
            int temp = mid-1;
            while (true){
                if (temp<0||arr[temp]!=val){
                    break;
                }
                // 否则将temp放入集合中
                resIndexList.add(temp);
                // temp左移
                temp--;
            }
            resIndexList.add(mid);
            temp=mid+1;
            while (true){
                if (temp>arr.length-1||arr[temp]!=val){
                    break;
                }
                resIndexList.add(temp);
                temp++;
            }
            return resIndexList;
        }else if (val<arr[mid]){
            // 向左递归
            return binaryFindAll(arr,left,mid-1,val);
        }else {
            // 向右递归
            return binaryFindAll(arr,mid+1,right,val);
        }
    }
~~~

## 插值查找算法

1、原理

> 1. 插值查找算法类似于二分查找，不同的是插值查找每次从**自适应mid**处开始查找。
> 2. 将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right。key 就是前面我们讲的 findVal

![1648805050312](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648805050312.png)

> 3. int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/*插值索引*/
>
>    对应前面的代码公式：
>
>    int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
>
> 4. 举例说明插值查找算法 1-100 的数组

##### 插值mid公式：

> <font color='red'>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low])</font>

**插值查找算法 1-100 的数组**

![1648805203537](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648805203537.png)

代码实现：

~~~
package DataStructures.Search;

import java.util.Arrays;

public class InsertSearch {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for (int i=0;i<100;i++){
            arr[i]=i+1;
        }
        System.out.println(Arrays.toString(arr));
        int index = insertFind(arr,0,arr.length-1,100);
        if (index==-1){
            System.out.println("未找到！");
        }else {
            System.out.println("找到了，下标为："+index);
        }
    }

    /**
     * 插值查找也要求数组是有序的
     * @param arr 数组
     * @param left  左边的索引
     * @param right 右边的索引
     * @param val 要查找的值
     * @return 如果找到返回对应的下标，如果没有找到返回-1
     */
    public static int insertFind(int[] arr,int left,int right,int val){
        int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left]);
        if (left > right || val < arr[0] || val > arr[arr.length-1]){
            // 未找到
            return -1;
        }
        if (val < arr[mid]){
            return insertFind(arr,left,mid-1,val);
        }else if (val > arr[mid]){
            return insertFind(arr,mid+1,right,val);
        }else {
            return mid;
        }
    }
}
~~~

**插值查找应用案例 ：**

请对一个有序数组进行插值查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出

下标，如果没有就提示"没有这个数

~~~
public static int insertFind(int[] arr,int left,int right,int val){
        System.out.println("调用了~");
        int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left]);
        if (left > right || val < arr[0] || val > arr[arr.length-1]){
            // 未找到
            return -1;
        }
        if (val < arr[mid]){
            return insertFind(arr,left,mid-1,val);
        }else if (val > arr[mid]){
            return insertFind(arr,mid+1,right-1,val);
        }else {
            return mid;
        }
    }
~~~

测试主类代码：

~~~
int[] arr = {1,8, 10, 89, 1000, 1234};
        //System.out.println(Arrays.toString(arr));
        int index = insertFind(arr,0,arr.length-1,1000);
        if (index==-1){
            System.out.println("未找到！");
        }else {
            System.out.println("找到了，下标为："+index);
        }
~~~

插值查找注意事项：

> 1. 对于<font color='blue'>数据量较大</font>， <font color='green'>关键字分布比较均匀</font>的查找表来说，<font color='green'>采用插值查找，速度较快。</font>
> 2. 关键字分布不均匀的情况下，该方法不一定比折半查找要好

### 斐波那契( 黄金分割法)查找算法

#### 1、基本介绍

> 1、黄金分割点是指把一条<font color='blue'>线段</font>分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。
>
> 取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此<font color='green'>称为黄金分割，也称为中外</font>
>
> 比。这是一个神奇的数字，会带来意向不大的效果。

> 2、<font color='blue'>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } </font>发现斐波那契数列的两个相邻数的比例，无限接近黄金
>
> 分割值0.618

#### 2、斐波那契(黄金分割法) 原理

斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位

于黄金分割点附近，即<font color='red'>mid=low+F(k-1)-1</font><font color='blue'>（F代表斐波那契数列）</font>，如下图所示

![1648811014965](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648811014965.png)

对F(k-1)-1的理解：

> 1. 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1 ）= （F[k-1]-1 ）+ （F[k-2]-1 ）+1 。该式说明：**只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1**
> 2. 类似的，每一子段也可以用相同的方式分割
> 3. 但**顺序表长度n不一定刚好等于F[k]-1**，所以需要将原来的顺序表<font color='blue'>长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可</font>，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。

![1648811221957](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648811221957.png)

#### 3、斐波那契案例

请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且

求出下标，如果没有就提示" 没有这个数 "。

代码实现：

~~~
package DataStructures.Search;

import java.util.Arrays;

public class FibonacciSearch {
    public static int maxSize =20;
    public static void main(String[] args) {
        int[] arr = {1,8, 10, 89, 1000, 1234};

        System.out.println("index = "+fibSearch(arr,1234));
    }

    // 后面要使用Fibonacci数列，所以要先获取到Fibonacci数列
    public static int[] fib(){
        int[] f = new int[maxSize];
        f[0]=1;
        f[1]=1;
        for (int i=2;i<maxSize;i++){
            f[i]=f[i-1]+f[i-2];
        }
        return f;
    }

    /**
     * 使用非递归的方式编写算法
     * @param a 数组
     * @param key  查找的关键值
     * @return 如果找到则返回对应下标，否则返回-1
     */
    // 编写斐波那契查找算法
    public static int fibSearch(int[] a,int key){
        int low=0;
        int high = a.length-1;
        // 表示斐波那契分割数值的下标
        int k=0;
        // 存放mid值
        int mid=0;
        // 获取到斐波那契数列
        int[] f =fib();
        // 获取到斐波那契分割数值的下标，即k
        while (high > f[k] -1){
            k++;
        }
        // 因为 f[k] 值可能大于 a 的长度，因此我们需要Arrays类，构造一个新的数值，并指向temp[]
        // 默认：不足的部分会使用0填充
        int[] temp = Arrays.copyOf(a,f[k]);
        // 需要：新构建的数组不足的部分用a数组最后一个数填充
        for (int i=high+1;i<temp.length;i++){
            temp[i]=a[high];
        }

        // 使用while循环处理找到key
        while (low <= high){
            mid = low + f[k-1] - 1;
            if (key < temp[mid]){
                // 向左查找
                high = mid-1;
                // 1.全部元素 = 前面的元素 + 后面的元素
                // 2.f[k] = f[k-1] + f[k-2]
                // 前面有 f[k-1]个元素，所以可以继续拆分：f[k-1]=f[k-2]+f[k-3]
                // 即在 f[k-1]的前面继续查找 k--
                // 即下次循环 mid = f[k-1-1]-1
                k--;
            }else if (key > temp[mid]){
                // 向右查找
                low = mid+1;
                // k-=2的原因：
                // 1.全部元素 = 前面的元素 + 后面的元素
                // 2.f[k] = f[k-1] + f[k-2]
                // 后面有 f[k-2]个元素，所以继续拆分：f[k-1] = f[k-3]+f[k-4]
                // 即在 f[k-2]前面继续查找 k-=2
                // 即下次循环 mid = f[k-1-2]-1;
                k -=2;
            }else {
                // 找到
                if (mid <= high){
                    return mid;
                }else {
                    return high;
                }
            }
        }
        return -1;
    }
}
~~~

# 哈希表

## 哈希表（散列）

![1648818641299](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648818641299.png)

##### Google面试题：

有一个公司，当有新的员工来报道时，要求将该员工的信息加入(id, 性别, 年龄,住址..)，当输入该员工的id 时，要求查找到该员工的所有信息。

要求：不使用数据库, 尽量节省内存, 速度越快越好=> 哈希表( 散列)

**添加时 ，保证按照id 从低到高插入** 

[ 课后思考：如果id 不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]

1. 使用链表来实现哈希表， 该链表不带表头  **[即: 链表的第一个结点就存放雇员信息]**

2. 思路分析并画出示意图

![1648819361862](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648819361862.png)

3. 代码实现[增、删、改、查( 显示所有员工， 按id查询)]

~~~
package DataStructures.Hash;

import java.util.EnumMap;
import java.util.Scanner;

public class HashTabDemo {
    public static void main(String[] args) {
        // 创建哈希表
        HashTab hashTab = new HashTab(7);

        // 简单的菜单
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true){
            System.out.println("----------------------");
            System.out.println("add：添加雇员");
            System.out.println("list：显示雇员");
            System.out.println("find：查找雇员");
            System.out.println("del：删除雇员");
            System.out.println("update：更新雇员");
            System.out.println("exit：退出系统");
            System.out.println("----------------------");

            key = scanner.next();
            switch (key){
                case "add":
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    // 创建雇员
                    Employee employee = new Employee(id,name);
                    hashTab.add(employee);
                    break;
                case "list":
                    hashTab.list();
                    break;
                case "find":
                    System.out.println("请输入id");
                    int id1 = scanner.nextInt();
                    hashTab.findEmpById(id1);
                    break;
                case "del":
                    System.out.println("请输入id");
                    int id2 = scanner.nextInt();
                    hashTab.delEmpById(id2);
                    break;
                case "update":
                    System.out.println("请输入id");
                    int id3 = scanner.nextInt();
                    System.out.println("请输入name");
                    String name2 = scanner.next();
                    employee = new Employee(id3,name2);
                    hashTab.update(employee);
                    break;
                case "exit":
                    scanner.close();
                    System.exit(0);
            }
        }
    }

}
// 创建HashTab管理多条链表
class HashTab{
    private EmpLinkedList[] empLinkedListarr;
    // 表示共有多少条链表
    private int size;

    // 构造器
    public HashTab(int size){
        // 表示共有多少条链表
        this.size = size;
        // 初始化empLinkedListarr
        empLinkedListarr = new EmpLinkedList[size];
        //***这时不要忘记分别初始化每一条链表
        for (int i=0;i<size;i++){
            empLinkedListarr[i] = new EmpLinkedList();
        }
    }
    // 添加雇员
    public void add(Employee employee){
        // 根据员工的id得到该员工应当添加到哪条链表
        int empLinkedListNo = hashFun(employee.id);
        // 将employee添加到对应的链表中
        empLinkedListarr[empLinkedListNo].add(employee);

    }

    // 显示雇员，遍历所有的链表即遍历hashTab
    public void list(){
        for (int i=0;i<size;i++){
            empLinkedListarr[i].list(i);
        }
    }

    // 查找雇员--根据输入的id
    public void findEmpById(int id){
        // 使用散列函数确定到哪条链表查找雇员
        int empLinkedListNo = hashFun(id);
        Employee employee = empLinkedListarr[empLinkedListNo].findById(id);
        if (employee!=null){
            System.out.printf("在第%d条链表中找到该雇员，雇员信息为->id=%d name=%s\n",empLinkedListNo+1,id,employee.name);
        }else {
            System.out.println("未找到该雇员！");
        }
    }

    // 删除雇员--根据id
    public void delEmpById(int id){
        // 使用散列函数确定到哪条链表查找雇员
        int empLinkedListNo = hashFun(id);
        empLinkedListarr[empLinkedListNo].delById(id);
    }

    // 更新链表雇员信息
    public void update(Employee employee){
        int empLinkedListNo = hashFun(employee.id);
        empLinkedListarr[empLinkedListNo].update(employee);
    }
    // 编写一个散列函数，使用一个简单的取模法
    public int hashFun(int id){
        return id%size;
    }
}

class Employee{
    public int id;
    public String name;
    // next默认为空
    public Employee next;

    public Employee(int id, String name) {
        super();
        this.id = id;
        this.name = name;
    }
}

// 创建EmpLinkedList，表示链表
class EmpLinkedList{
    // 头指针，指向第一个雇员，默认为空
    private Employee head;
    // 对雇员的操作
    //1、添加雇员到链表
    // 假定添加雇员的时候直接添加在链表的最后，即id是自增长的
    public void add(Employee employee){
        // 如果是添加第一个雇员
        if (head == null){
            head=employee;
            return;
        }
        // 不是第一个雇员，则使用一个辅助指针，帮助定位到最后
        Employee curEmp = head;
        while (true){
            if (curEmp.next == null){
                // 说明到链表最后
                break;
            }
            // 后移，直到链表最后
            curEmp = curEmp.next;
        }
        // 将employee加入到链表最后
        curEmp.next = employee;
    }
    // 遍历链表的雇员信息
    public void list(int no){
        if (head==null){
            // 说明链表为空
            System.out.println("第"+(no+1)+"条链表为空！");
            return;
        }
        System.out.printf("第%d条链表的信息为：",no+1);
        // 辅助作用
        Employee curEmp = head;
        while (true){
            System.out.printf("=>id=%d name=%s\t",curEmp.id,curEmp.name);
            if (curEmp.next==null){
                // 到链表最后
                break;
            }
            // 后移，遍历
            curEmp = curEmp.next;
        }
        System.out.println();
    }

    // 根据id查找雇员
    // 找到则返回Employee，未找到则返回空
    public Employee findById(int id){
        // 判断链表是否为空
        if (head==null){
            return null;
        }
        // 辅助指针
        Employee curEmp = head;
        while (true){
            if (curEmp.id == id){
                // 找到，此时curEmp就指向要查找的雇员
                break;
            }
            if (curEmp.next==null){
                // 遍历完链表，且没有找到
                curEmp = null;
                break;
            }
            curEmp = curEmp.next;
        }
        return curEmp;
    }

    // 根据id删除雇员信息
    public void delById(int id){
        if (head==null){
            // 链表为空
            System.out.println("链表为空！");
            return;
        }
        Employee curEmp =head;
        if (curEmp==head && curEmp.id==id){
            head = head.next;
        }else{
            curEmp = head;
            // 表示是否找到该节点
            boolean flag = false;
            while (true) {
                if (curEmp.next == null) {
                    // 未找到要删除的雇员
                    break;
                }
                if (curEmp.next.id == id) {
                    flag = true;
                    break;
                }
                curEmp = curEmp.next;

            }
            // 删除节点
            if (flag) {
                curEmp.next = curEmp.next.next;
                System.out.println("删除成功！");
            } else {
                System.out.printf("未找到id=%d的雇员", id);
            }
    }

    }
    // 更新雇员信息
    public void update(Employee employee){
        if (head==null){
            System.out.println("链表为空！");
            return;
        }
        Employee curEmp =head;
        boolean flag = false;
        while (true){
            if (curEmp.id == employee.id){
                flag = true;
                break;
            }
            if (curEmp.next==null){
                break;
            }
            curEmp = curEmp.next;
        }
        if (flag){
            curEmp.name = employee.name;
            System.out.println("修改成功！");
        }else {
            System.out.printf("未找到id=%d的雇员，修改失败！",employee.id);
        }
    }
}
~~~

#### 1、概念

> **<font color='red'>散列表（Hash table，也叫哈希表）</font>，是根据关键码值(Key value)而直接进行访问的数据结构。**也就是
>
> 说，它<font color='green'>通过把关键码值映射到表中一个位置来访问记录</font>，以加快查找的速度。**这个映射函数叫做散列函**
>
> **数，存放记录的数组叫做散列表。**

![1648818507410](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648818507410.png)

> hash函数就是根据key计算出应该存储地址的位置，而哈希表是<font color='red'>基于哈希函数</font>建立的一种查找表 

> 散列函数：  是把任意长度的[输入](https://baike.baidu.com/item/输入/5481954)（又叫做预映射pre-image）通过散列算法变换成固定长度的[输出](https://baike.baidu.com/item/输出/11056752)，该输出就是散列值。 
>
> 散列（Hashing）通过散列函数将要检索的项与索引（散列，散列值）关联起来，生成一种便于搜索的数据结构（散列表）。 

**哈希表 = 数组 + 链表**

##### 哈希冲突：

如果两个不同的输入得到相同的哈希值，则称为发生了哈希冲突。

输入关键字x，使用哈希函数f(x)计算出哈希值y，然后使用哈希值y来找特定的数组下标，并在对应位置插入新的数据。

##### 哈希表支持的操作

> add(Key e,Value v)：将一对新的键值对加入哈希表
>
> get(Key k)：通过特定的关键字拿到其所对应的数值
>
> remove(Key k)：通过关键字，删除哈希表中的键值对
>
> getSize()：当前键值对的数量
>
> isEmpty()：查看哈希表是否为空

# 树结构基础部分

## 二叉树

1、为什么需要树这种数据结构

1. 数组存储方式的分析
   优点：通过下标方式访问元素，速度快。 对于有序数组，还可使用二分查找提高检索速度。
   缺点：如果要检索具体某个值，或者插入值(按一定顺序) 会整体移动，效率较低 [ 示意图 ]

   ![1648876878777](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648876878777.png)

2. 链式存储方式的分析
   优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。
   缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)

   ![1648877726944](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648877726944.png)

3. **树存储方式的分析**
   <font color='blue'>能提高数据存储、读取的效率</font>, 比如利用二叉排序树 (Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度 。

   案例: [7, 3, 10, 1, 5, 9, 12]

   ![1648878654128](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648878654128.png)

### 树示意图

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210319015701606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70#pic_center) 

![1648878972326](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648878972326.png)

> 树的常用术语(结合示意图理解):
>
> 1. 节点
> 2. 结点的度：节点拥有的子树数称为结点的度
> 3. 树的度：树的度就是树内各结点度的最大值
> 4. 根节点
> 5. 父节点
> 6. 子节点
> 7. 叶子节点 (没有子节点的节点)：度为0的结点
> 8. 节点的权(节点值)
> 9. 路径(从root节点找到该节点的路线)
> 10. 层
> 11. 子树
> 12. 树的高度(最大层数)：深度，树中节点的最大层数
> 13. 森林 ：多颗子树构成森林
> 14. 堂兄弟：双亲在同一层的结点互为堂兄弟

#### 1、树的概念

树是n(n>=0)个结点的有限集。可以为空树(n=0)或非空树，对于非空树：

> 1. 有且仅有一个称之为根的结点
> 2. 除根结点之外的其他结点可分为m(m>0)个互不相交的有限集T1，T2，T3，T4......，称之为树的子树

#### 2、有序树和无序树

<font color='blue'> 如果将树中结点的各子树看成从左至右是有次序的，则称该树为有序树，否则为无序树。 </font>

### 二叉树概念

1. 树有很多种，<font color='green'>每个节点最多只能有两个子节点 的一种形式称为二叉树。</font>
2. <font color='red'>二叉树的子节点分为左节点和右节点。</font>

![1648879101540](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648879101540.png)

3. 如果该<font color='orange'>二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</font>

4. <font color='blue'>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。</font>

![1648879172931](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648879172931.png)

### 二叉树的遍历

分别通过前序、中序、后序对下面的二叉树进行遍历：

![1648879328053](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648879328053.png)

<font color='red'>前序遍历：</font>先输出父节点，再遍历左子树和右子树

<font color='red'>中序遍历：</font>先遍历左子树，再输出父节点，再遍历右子树

<font color='red'>后序遍历：</font>先遍历左子树，再遍历右子树，最后输出父节点

**小结：看输出父节点的顺序，就确定是前序，中序还是后序**

![1648880334383](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648880334383.png)

实现代码：

~~~
package DataStructures.Tree;

public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊义");
        HeroNode node4 = new HeroNode(4,"林冲");

        // 先手动创建二叉树，后面学习以递归的方式创建二叉树
        binaryTree.setRoot(root);
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);

        System.out.println("前序遍历为：");
        binaryTree.preOrder();
        
        System.out.println("中序遍历为：");
        binaryTree.infixOrder();
        
        System.out.println("后序遍历为：");
        binaryTree.postOrder();
    }
}
// 定义BinaryTree 二叉树
class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行前序遍历！");
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.root!=null){
            this.root.infixOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行中序遍历！");
        }
    }

    // 后序遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行后序遍历！");
        }
    }
}

// 先创建结点
class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    // 构造器，左右节点默认为空
    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    // 编写前序遍历
    public void preOrder(){
        // 先输出父结点（当前结点）
        System.out.println(this);
        // 递归向左子树前序遍历
        if (this.left!=null){
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right!=null){
            this.right.preOrder();
        }
    }
    // 中序遍历
    public void infixOrder(){
        // 递归向左子树中序遍历
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right!=null){
            this.right.infixOrder();
        }
    }
    // 后序遍历
    public void postOrder(){
        // 递归向左后序遍历
        if (this.left!=null){
            this.left.postOrder();
        }
        // 递归向右后序遍历
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}
~~~

![1648882918870](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648882918870.png)

![1648883105591](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648883105591.png)

输出效果：

![1648883137170](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648883137170.png)

### 二叉树的查找

#### 1、查找指定结点

> 要求：
>
> 1. 请编写前序查找，中序查找和后序查找的方法。
> 2. 并分别使用三种查找方式，查找 heroNO = 5 的节点
> 3. 并分析各种查找方式，分别比较了多少次

**思路图解：**

![1648883340315](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648883340315.png)

**实现代码：**

~~~
package DataStructures.Tree;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.zip.DataFormatException;

public class BinaryTreeSearch {
    public static void main(String[] args) {
        BinaryTree1 binaryTree1 = new BinaryTree1();
        HeroNode1 root = new HeroNode1(1,"宋江");
        HeroNode1 node2 = new HeroNode1(2,"吴用");
        HeroNode1 node3 = new HeroNode1(3,"卢俊义");
        HeroNode1 node4 = new HeroNode1(4,"林冲");
        HeroNode1 node5 = new HeroNode1(5,"关胜");

        // 先手动创建二叉树，后面学习以递归的方式创建二叉树
        binaryTree1.setRoot(root);
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:S").format(new Date()));

        System.out.println("前序遍历查找：");
        binaryTree1.preOrderSearch(5);

        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:S").format(new Date()));

        System.out.println("中序遍历查找：");
        binaryTree1.infixOrderSearch(5);

        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:S").format(new Date()));

        System.out.println("后序遍历查找：");
        binaryTree1.postOrderSearch(5);

        System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:S").format(new Date()));
    }
}
// 定义BinaryTree 二叉树
class BinaryTree1{
    private HeroNode1 root;

    public void setRoot(HeroNode1 root) {
        this.root = root;
    }

    // 前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行前序遍历！");
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.root!=null){
            this.root.infixOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行中序遍历！");
        }
    }

    // 后序遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行后序遍历！");
        }
    }

    // 前序遍历查找
    public void preOrderSearch(int no){
        if (this.root!=null){
            HeroNode1 resNode = this.root.preOrderSaerch(no);
            System.out.println("找到id为"+no+"的结点为："+resNode);
        }else {
            System.out.println("当前二叉树为空，前序查找失败！");
        }
    }
    // 中序遍历查找
    public void infixOrderSearch(int no){
        if (this.root!=null){
            HeroNode1 resNode = this.root.infixOrderSearch(no);
            System.out.println("找到id为"+no+"的结点为："+resNode);
        }else {
            System.out.println("当前二叉树为空，中序查找失败！");
        }
    }
    // 后序遍历查找
    public void postOrderSearch(int no){
        if (this.root!=null){
            HeroNode1 resNode = this.root.postOrderSearch(no);
            System.out.println("找到id为"+no+"的结点为："+resNode);
        }else {
            System.out.println("当前二叉树为空，后序查找失败！");
        }
    }
}

// 先创建结点
class HeroNode1{
    private int no;
    private String name;
    private HeroNode1 left;
    private HeroNode1 right;

    // 构造器，左右节点默认为空
    public HeroNode1(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode1 getLeft() {
        return left;
    }

    public void setLeft(HeroNode1 left) {
        this.left = left;
    }

    public HeroNode1 getRight() {
        return right;
    }

    public void setRight(HeroNode1 right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode1{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }

    // 编写前序遍历
    public void preOrder(){
        // 先输出父结点（当前结点）
        System.out.println(this);
        // 递归向左子树前序遍历
        if (this.left!=null){
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right!=null){
            this.right.preOrder();
        }
    }
    // 中序遍历
    public void infixOrder(){
        // 递归向左子树中序遍历
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right!=null){
            this.right.infixOrder();
        }
    }
    // 后序遍历
    public void postOrder(){
        // 递归向左后序遍历
        if (this.left!=null){
            this.left.postOrder();
        }
        // 递归向右后序遍历
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }

    // 前序遍历查找

    /**
     *
     * @param no 查找no
     * @return 如果找到就返回该结点，否则返回null
     */
    public HeroNode1 preOrderSaerch(int no){
        System.out.println("进入前序遍历查找");
        if (this.no == no){
            return this;
        }
        // 判断当前结点的左节点是否为空，若不为空，则递归前序查找
        HeroNode1 resNode = null;
        if (this.left!=null){
            resNode = this.left.preOrderSaerch(no);
        }
        if (resNode!=null){
            // 说明左子树找到
            return resNode;
        }
        //1.左递归前序查找，找到结点，则返回，否继续判断，
        //2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找
        if (this.right!=null){
            resNode = this.right.preOrderSaerch(no);
        }
        return resNode;
    }

    // 中序遍历查找
    public HeroNode1 infixOrderSearch(int no){
        HeroNode1 resNode = null;
        if (this.left!=null){
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        System.out.println("进入中序遍历查找");
        if (this.no==no){
            return this;
        }
        if (this.right!=null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }

    // 后序遍历查找
    public HeroNode1 postOrderSearch(int no){
        HeroNode1 resNode = null;
        if (this.left!=null){
            resNode = this.left.postOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        if (this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if (resNode!=null){
            return resNode;
        }
        System.out.println("进入后序遍历查找");
        if (this.no==no){
            resNode = this;
        }
        return resNode;
    }
}
~~~

![1648887493133](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648887493133.png)

#### 2、删除结点

> 要求：
>
> 1. 如果删除的节点是叶子节点，则删除该节点
> 2. 如果删除的节点是非叶子节点，则删除该子树.
> 3. 测试，删除掉 5号叶子节点 和 3号子树.

**思路图解：**

![1648888603119](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648888603119.png)

**实现代码：**

~~~html
package DataStructures.Tree;

public class BinaryTreeDelete {
    public static void main(String[] args) {
        BinaryTree2 binaryTree2 = new BinaryTree2();
        HeroNode2 root = new HeroNode2(1,"宋江");
        HeroNode2 node2 = new HeroNode2(2,"吴用");
        HeroNode2 node3 = new HeroNode2(3,"卢俊义");
        HeroNode2 node4 = new HeroNode2(4,"林冲");
        HeroNode2 node5 = new HeroNode2(5,"关胜");

        // 先手动创建二叉树，后面学习以递归的方式创建二叉树
        binaryTree2.setRoot(root);
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        System.out.println("删除前，前序遍历：");
        binaryTree2.preOrder();
        binaryTree2.delNode(3);
        System.out.println("删除后，前序遍历：");
        binaryTree2.preOrder();
    }
}
// 定义BinaryTree 二叉树
class BinaryTree2{
    private HeroNode2 root;

    public void setRoot(HeroNode2 root) {
        this.root = root;
    }

    // 递归删除节点
    public void delNode(int no){
        if (root!=null){
            //如果只有一个root结点, 这里立即判断root是不是就是要删除结点
            if (root.getNo() == no){
                root = null;
            }else {
                root.delNode(no);
            }
        }else {
            System.out.println("这是一个空树，无法删除！");
        }
    }

    // 前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行前序遍历！");
        }
    }
}

// 先创建结点
class HeroNode2{
    private int no;
    private String name;
    private HeroNode2 left;
    private HeroNode2 right;

    // 构造器，左右节点默认为空
    public HeroNode2(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode2 getLeft() {
        return left;
    }

    public void setLeft(HeroNode2 left) {
        this.left = left;
    }

    public HeroNode2 getRight() {
        return right;
    }

    public void setRight(HeroNode2 right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode2{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    // 递归删除结点
    // 1、如果删除的节点是叶子节点，则删除该节点
    // 2、如果删除的结点是非叶子节点，则删除该子树
    public void delNode(int no){
        //思路
		/*
		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.
			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
			5. 如果第4步也没有删除结点，则应当向右子树进行递归删除.
		 */
        //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
		if (this.left!=null && this.left.no == no){
		    this.left=null;
		    return;
        }
        //3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
        if (this.right!=null && this.right.no==no){
            this.right=null;
            return;
        }
        //4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
        if (this.left!=null){
            this.left.delNode(no);
        }
        //5. 如果第4步也没有删除结点，则应当向右子树进行递归删除.
        if (this.right!=null){
            this.right.delNode(no);
        }
    }

    // 编写前序遍历
    public void preOrder(){
        // 先输出父结点（当前结点）
        System.out.println(this);
        // 递归向左子树前序遍历
        if (this.left!=null){
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right!=null){
            this.right.preOrder();
        }
    }
}
~~~

![1648890378903](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648890378903.png)

> 如果要删除的节点是非叶子节点，现在我们不希望将该非叶子节点为根节点的子树删除， 需要指定规则, 假如规定如下:
>
> 1. 如果该非叶子节点A只有一个子节点B，则子节点B替代节点A
> 2. 如果该非叶子节点A有左子节点B和右子节点C，则让左子节点B替代节点A。
> 3. 请大家思考，如何完成该删除功能，老师给出提示.( 课后练习)
> 4. 后面在讲解二叉排序树时，在给大家讲解具体的删除方法



### 二叉树的存储结构

二叉树一般可以使用两种存储结构，一种顺序结构，一种链式结构

#### 1、顺序存储

从数据存储来看，<font color='red'> 数组存储方式和树的存储方式可以相互转换</font>，即数组可以转换成树，树也可以转换成数组

![1648890790424](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648890790424.png)

> 要求：
>
> 1. 右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]
> 2. 要求在遍历数组 arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历

1、顺序存储二叉树的概念

> <font color='blue'>顺序存储二叉树的特点：</font>
>
> 1. **顺序二叉树通常只考虑完全二叉树**
> 2. <font color='orange'>第n个元素的左子节点为 2 * n + 1</font>
> 3. <font color='green'>第n个元素的右子节点为 2 * n + 2</font>
> 4. <font color='red'>第n个元素的父节点为 (n-1) / 2</font>
> 5. n：表示二叉树中的第几个元素（按0开始编号，如图所示）
>
> <img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648891171727.png" alt="1648891171727" style="zoom:50%;" />

> 需求：
>
> 给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前序遍历的方式进行遍历。前序遍历的结果应当为 1,2,4,5,3,6,7

代码实现：

~~~
package DataStructures.Tree;

public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7};

        // 创建一个ArrayBinaryTree
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        arrayBinaryTree.preOrder();

    }
}

// 编写一个ArrayBinaryTree，实现顺序存储二叉树的遍历
class ArrayBinaryTree{
    // 存储数据结点的数组
    private int[] arr;

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }
    // 重载preOrder方法
    public void preOrder(){
        this.preOrder(0);
    }

    // 编写方法，完成顺序存储二叉树的前序遍历

    /**
     *
     * @param index  数组的下标
     */
    public void preOrder(int index){
        // 如果数组为空或arr.length==0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能前序遍历！");
        }
        // 输出当前元素
        System.out.print(arr[index]+" ");
        // 向左递归遍历
        if ((index*2+1)<arr.length){
            preOrder(index*2+1);
        }
        if ((index*2+2)<arr.length){
            preOrder(index*2+2);
        }
    }
}
~~~

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648891934316.png" alt="1648891934316" style="zoom:50%;" />

练习：顺序存储二叉树的中序、后序遍历

~~~
package DataStructures.Tree;

public class ArrayBinaryTreeDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7};

        // 创建一个ArrayBinaryTree
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        System.out.println("前序遍历为：");
        arrayBinaryTree.preOrder();
        System.out.println();
        System.out.println("中序遍历为：");
        arrayBinaryTree.infixOrder();
        System.out.println();
        System.out.println("后序遍历为：");
        arrayBinaryTree.postOrder();

    }
}

// 编写一个ArrayBinaryTree，实现顺序存储二叉树的遍历
class ArrayBinaryTree{
    // 存储数据结点的数组
    private int[] arr;

    public ArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }
    // 重载preOrder方法
    public void preOrder(){
        this.preOrder(0);
    }
    public void infixOrder(){
        this.infixOrder(0);
    }
    public void postOrder(){
        this.postOrder(0);
    }

    // 编写方法，完成顺序存储二叉树的前序遍历

    /**
     *
     * @param index  数组的下标
     */
    public void preOrder(int index){
        // 如果数组为空或arr.length==0
        if (arr == null || arr.length == 0){
            System.out.println("数组为空，不能前序遍历！");
            return;
        }
        // 输出当前元素
        System.out.print(arr[index]+" ");
        // 向左递归遍历
        if ((index*2+1)<arr.length){
            preOrder(index*2+1);
        }
        if ((index*2+2)<arr.length){
            preOrder(index*2+2);
        }
    }

    // 中序
    public void infixOrder(int index){
        if (arr==null || arr.length==0){
            System.out.println("数组为空，不能中序遍历");
            return;
        }
        if ((index*2+1)<arr.length){
            infixOrder(index*2+1);
        }
        System.out.print(arr[index]+" ");
        if ((index*2+2)<arr.length){
            infixOrder(index*2+2);
        }
    }

    // 后序
    public void postOrder(int index){
        if (arr==null || arr.length==0){
            System.out.println("数组为空，不能后序遍历");
            return;
        }
        if ((index*2+1)<arr.length){
            infixOrder(index*2+1);
        }
        if ((index*2+2)<arr.length){
            infixOrder(index*2+2);
        }
        System.out.print(arr[index]+" ");
    }
}
~~~

顺序结构存储就是使用数组来存储，一般使用数组只适合表示完全二叉树，因为不是完全二叉树会有空间的

浪费。而现实中使用中只有堆才会使用数组来存储。二叉树顺序存储在物理上是一个数组，在逻辑上是一颗

二叉树。 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210319155355766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70#pic_center) 

##### 中序线索化二叉树

将数列{1，3，6，8，10，14}构建成一棵二叉树。

![1648896650832](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648896650832.png)

> 问题分析：
>
> 1. 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 }
> 2. 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上.
> 3. 如果我们**希望充分的利用 各个节点的左右指针**， 让各个节点可以指向自己的前后节点，怎么办?
> 4. 解决方案-线索二叉树

###### 线索二叉树基本介绍

1. <font color='green'>n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。</font><font color='red'>利用二叉链表中的空指针域，存放指向该结点在**某种遍历次序下的前驱和后继结点的指针**（这种附加的指针称为"线索"）</font>
2. 这种**加上了线索的二叉链表称为线索链表**，**相应的二叉树称为线索二叉树(Threaded BinaryTree)**。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
3. 一个结点的前一个结点，称为<font color='blue'>前驱结点</font>
4. 一个结点的后一个结点，称为<font color='blue'>后继结点</font>

应用案例说明：

> 将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}

思路分析：

![1648897096954](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648897096954.png)

> **说明：当线索化二叉树后，Node 节点的属性 left 和 right ，有如下情况：**
>
> 1. left 指向的是左子树，也可能是指向的前驱节点。比如 ① 节点 left 指向的左子树，而 ⑩ 节点的 left指向的就是前驱节点。
> 2. right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点。

实现代码：

~~~
package DataStructures.Tree;

public class ThreadedBinaryTreeDemo {
    public static void main(String[] args) {
        // 测试中序线索二叉树
        HeroNode3  root = new HeroNode3(1,"tom");
        HeroNode3  node2 = new HeroNode3(3,"jack");
        HeroNode3  node3 = new HeroNode3(6,"smith");
        HeroNode3  node4 = new HeroNode3(8,"marry");
        HeroNode3  node5 = new HeroNode3(10,"king");
        HeroNode3  node6 = new HeroNode3(14,"dim");

        // 手动创建
        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        // 测试线索化
        ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
        threadedBinaryTree.setRoot(root);
        threadedBinaryTree.threadedNodes();
        // 测试：以10号节点做测试
        HeroNode3 leftNode = node5.getLeft();
        HeroNode3 rightNode = node5.getRight();
        System.out.println("10号结点的前驱结点是 ="  + leftNode); //3
        System.out.println("10号结点的后继结点是="  + rightNode); //1
    }
}
// 定义实现了线索化功能的二叉树
class ThreadedBinaryTree{

    private HeroNode3 root;
    // 为了实现线索化，需要创建要指向当前结点的前驱结点的指针
    // 在递归进行线索化时，pre总是保留前一个结点
    private HeroNode3 pre = null;

    public void setRoot(HeroNode3 root) {
        this.root = root;
    }

    // 重载线索化方法
    public void threadedNodes(){
        this.threadedNodes(root);
    }
    // 编写对二叉树进行中序线索化的方法
    /**
     *
     * @param node 就是当前需要线索化的结点
     */
    public void threadedNodes(HeroNode3 node){
        // 如果node == null，不能线索化
        if (node==null){
            return;
        }
        //1、先线索化左子树
        threadedNodes(node.getLeft());
        //2、线索化当前结点 ***

        // 处理当前结点的前驱结点
        if (node.getLeft()==null){
            // 让当前结点的左指针指向前驱结点
            node.setLeft(pre);
            // 修改当前结点的左指针的类型，指向前驱节点
            node.setLeftTye(1);
        }
        // 处理当前结点的后继结点，是在递归的时候（下一次处理）
        if(pre!=null && pre.getRight()==null){
            // 让前驱结点的右指针指向当前结点
            pre.setRight(node);
            // 修改前驱结点的右指针类型
            pre.setRightType(1);
        }

        // !!! 每处理一个结点后，让当前结点的是下一个结点的前驱结点
        pre = node;
        //3、线索化右子树
        threadedNodes(node.getRight());
    }
    // 前序遍历
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行前序遍历！");
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.root!=null){
            this.root.infixOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行中序遍历！");
        }
    }

    // 后序遍历
    public void postOrder(){
        if (this.root!=null){
            this.root.postOrder();
        }else {
            System.out.println("当前二叉树为空，无法进行后序遍历！");
        }
    }
}

// 创建HeroNode3
class HeroNode3{
    private int no;
    private String name;
    private HeroNode3 left;
    private HeroNode3 right;

    // 定义前驱结点和后继结点
    // 如果leftTyep=0则表示指向的是左子树，leftType=1则表示指向前驱节点
    // 如果rightType=0则表示指向的是右子树，rightType=1则表示指向后继节点
    private int leftTye;
    private int rightType;

    public int getLeftTye() {
        return leftTye;
    }

    public void setLeftTye(int leftTye) {
        this.leftTye = leftTye;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }


    // 构造器，左右节点默认为空
    public HeroNode3(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode3 getLeft() {
        return left;
    }

    public void setLeft(HeroNode3 left) {
        this.left = left;
    }

    public HeroNode3 getRight() {
        return right;
    }

    public void setRight(HeroNode3 right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode3{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
    // 递归删除结点
    // 1、如果删除的节点是叶子节点，则删除该节点
    // 2、如果删除的结点是非叶子节点，则删除该子树
    public void delNode(int no){
        //思路
		/*
		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.
			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
			5. 如果第4步也没有删除结点，则应当向右子树进行递归删除.
		 */
        //2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
        if (this.left!=null && this.left.no == no){
            this.left=null;
            return;
        }
        //3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
        if (this.right!=null && this.right.no==no){
            this.right=null;
            return;
        }
        //4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
        if (this.left!=null){
            this.left.delNode(no);
        }
        //5. 如果第4步也没有删除结点，则应当向右子树进行递归删除.
        if (this.right!=null){
            this.right.delNode(no);
        }
    }

    // 编写前序遍历
    public void preOrder(){
        // 先输出父结点（当前结点）
        System.out.println(this);
        // 递归向左子树前序遍历
        if (this.left!=null){
            this.left.preOrder();
        }
        // 递归向右子树前序遍历
        if (this.right!=null){
            this.right.preOrder();
        }
    }
    // 中序遍历
    public void infixOrder(){
        // 递归向左子树中序遍历
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        // 递归向右子树中序遍历
        if (this.right!=null){
            this.right.infixOrder();
        }
    }
    // 后序遍历
    public void postOrder(){
        // 递归向左后序遍历
        if (this.left!=null){
            this.left.postOrder();
        }
        // 递归向右后序遍历
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}
~~~

###### 遍历线索化二叉树

> 说明：对前面的中序线索化的二叉树， 进行遍历
>
> 分析：因为线索化后，各个结点指向有变化，因此**原来的遍历方式不能使用**，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。

核心代码：

~~~
// 遍历中序线索化二叉树
    public void infixThreadOrder(){
        // 定义一个变量，存储当前遍历的结点，从root开始
        HeroNode3 node = root;
        while (node!=null){
            // 循环的找到 leftType等于1的结点，第一个找到的就是第一个结点
            // 后面随着遍历而变化，
            while (node.getLeftTye()==0){
                node = node.getLeft();
            }
            // 打印当前结点
            System.out.println(node);
            // 如果当前结点的右指针指向的是后继结点，就一直输出
            while (node.getRightType()==1){
                // 获取到当前结点的后继结点
                node = node.getRight();
                System.out.println(node);
            }
            // 替换遍历的结点
            node = node.getRight();
        }
    }
~~~

**中序线索化二叉树的思路**：

> 1、先线索化左子树
> 2、找到线索化的起始点—当前节点的左节点为空 node.getLeft() == null
> 3、然后把当前节点右指针指向前驱结点
> 4、在处理后继结点，并把前驱结点的右指针设置为当前节点
> 5、最后把当前节点设置为前驱结点
> 6、线索化右子树

**中序线索化二叉树遍历思路：**

> 1、先找到线索化的起始点
>
> 2、输出当前节点信息
>
> 3、然后寻找当前结点的后继结点，并输出

~~~
    /**
     *二叉树进行中序线索化的方法
     * @param node 就是当前需要线索化的节点
     */
    public void middlethreadedNodes(HeroNode node){
        if (node == null){
            return;
        }
        //一、先线索化左子树
        middlethreadedNodes(node.getLeft());
        //二、线索化当前节点
        //先处理当前结点的前驱结点
        if (node.getLeft() == null)
        {
            //让当前结点的左指针指向前驱结点
            node.setLeft(pre);
            //修改当前结点的左指针类型，指向前驱结点
            node.setLefttype(1);
        }
        //处理后继结点
        if (pre!=null && pre.getRight() == null){
            //让前驱结点的右指针指向当前结点
            pre.setRight(node);
            //修改前驱结点的右指针类型
            pre.setRighttype(1);
        }
        // 每处理一个结点后，让当前结点是下一个结点的前驱结点
        pre  = node;
        //三、再线索化右子树
        middlethreadedNodes(node.getRight());
    }
~~~

**中序线索化二叉树的遍历：**

~~~
 //中序遍历线索化二叉树
    public void middlethreadedList(){
        //定义一个变量，存储当前遍历的结点，从root开始
        HeroNode node = root;
        while (node != null){
            //循环的找到leftType == 1的结点，第一个找到就是结点8
            //后面随着遍历而变化，因为leftType==1，说明该结点是按照线索化处理后的有效结点
            while (node.getLefttype() == 0){
                 node = node.getLeft();
            }
            //打印当前结点
            println(node);
            //如果当前结点的右指针指向的是后继结点，就一直输出
            while (node.getRighttype() == 1){
                //获取到当前结点的后继结点
                node = node.getRight();
                println(node);
            }
            //替换这个遍历的结点
            node  = node.getRight();
        }
    }
~~~

##### 前序线索化二叉树

**前序线索化二叉树的思路：**

> 1、 先找到线索化的起始点----->当前节点的左节点为空 node.getLeft() == null
> 2、然后把当前节点右指针指向前驱结点
> 3、在处理后继结点，并把前驱结点的右指针设置为当前节点
> 4、最后把当前节点设置为前驱结点
> 5、线索化左子树
> 6、线索化右子树

**前序线索化二叉树遍历思路：**

> 1、先找到线索化的起始点，边找边输出当前节点
>
> 2、然后寻找当前结点的后继结点，并输出

~~~
 /**
     *二叉树进行前序线索化的方法
     * @param node 就是当前需要线索化的节点
     */
    public void prethreadedNodes(HeroNode node){
        if (node == null){
            return;
        }
        //一、线索化当前节点
        //先处理当前结点的前驱结点
        if (node.getLeft() == null)
        {
            //让当前结点的左指针指向前驱结点
            node.setLeft(pre);
            //修改当前结点的左指针类型，指向前驱结点
            node.setLefttype(1);
        }
        //处理后继结点
        if (pre!=null && pre.getRight() == null){
            //让前驱结点的右指针指向当前结点
            pre.setRight(node);
            //修改前驱结点的右指针类型
            pre.setRighttype(1);
        }

        // 每处理一个结点后，让当前结点是下一个结点的前驱结点
        pre  = node;
        //二、先线索化左子树
        if (node.getLefttype()==0)
            prethreadedNodes(node.getLeft());
        //三、再线索化右子树
        if (node.getRighttype()==0)
        prethreadedNodes(node.getRight());
    }
~~~

###### 前序线索二叉树的遍历

~~~
  //前序遍历线索化二叉树
    public void prethreadedList(){
        //定义一个变量，存储当前遍历的结点，从root开始
        HeroNode node = root;
        while (node != null){

            //循环的找到leftType == 1的结点
            //后面随着遍历而变化，因为leftType==1，说明该结点是按照线索化处理后的有效结点
            while (node.getLefttype() == 0){
                //打印当前结点
                System.out.println(node);
                node = node.getLeft();
            }
            //如果当前结点的右指针指向的是后继结点，就一直输出
            while (node.getRighttype() == 1){
                //打印当前结点
                System.out.println(node);
                //获取到当前结点的后继结点
                node = node.getRight();
            }
            System.out.println(node);
            //替换这个遍历的结点
            node  = node.getRight();
        }
    }
~~~

##### 后序线索化二叉树

**后序线索化二叉树的思路**：

> 1、先线索化左子树
> 2、在线索化右子树
> 3、找到线索化的起始点—当前节点的左节点为空 node.getLeft() == null
> 4、然后把当前节点右指针指向前驱结点
> 5、在处理后继结点，并把前驱结点的右指针设置为当前节点，如果前驱结点的右节点不为空，那么就把前驱结点的孩子设置为当前节点（避免遍历时进入到死循环）
> 6、最后把当前节点设置为前驱结点

**后序线索化二叉树遍历思路：**

> 1、 先找到线索化的起始点
>
> 2、然后寻找当前结点的后继结点，并输出
>
> 3、如果当前节点是根节点就输出信息并返回
>
> 4、如果当前结点的右节点与前驱结点相同，输出当前结点信息并迭代孩子结点
>
> 5、获取右结点

~~~
  /**
     *二叉树进行后序线索化的方法
     * @param node 就是当前需要线索化的节点
     */
    public void postthreadedNodes(HeroNode node){
        if (node == null){
            return;
        }
        //一、先线索化左子树
        postthreadedNodes(node.getLeft());

        //二、再线索化右子树
        postthreadedNodes(node.getRight());

        //三、线索化当前节点
        //先处理当前结点的前驱结点
        if (node.getLeft() == null)
        {
            //让当前结点的左指针指向前驱结点
            node.setLeft(pre);
            //修改当前结点的左指针类型，指向前驱结点
            node.setLefttype(1);
        }
        //处理后继结点
        if (pre!=null && pre.getRight() == null){
            //让前驱结点的右指针指向当前结点
            pre.setRight(node);
            //修改前驱结点的右指针类型
            pre.setRighttype(1);
        }else if (pre!=null && pre.getRight()!=null){
            pre.setChild(node);
        }
        // 每处理一个结点后，让当前结点是下一个结点的前驱结点
        pre  = node;
    }
~~~

**后序线索化二叉树的遍历：**

~~~
//后序遍历线索化二叉树
    public void postthreadedList(){
        //定义一个变量，存储当前遍历的结点，从root开始
        HeroNode node = root;
        HeroNode Prev = null;
        while (node != null){
            //循环的找到leftType == 1的结点
            //后面随着遍历而变化，因为leftType==1，说明该结点是按照线索化处理后的有效结点
            while (node.getLefttype() == 0){
                node = node.getLeft();
            }
            //如果当前结点的右指针指向的是后继结点，就一直输出
            while (node.getRighttype() == 1){
                println(node);
                Prev = node;
                //获取到当前结点的后继结点
                node = node.getRight();
            }
            if (node ==root){
                println(node);
                return;
            }
            while (node !=null && node.getRight()==Prev){
                println(node);
                Prev = node;
                //替换这个遍历的结点
                node  = node.getChild();
            }
            if(node!=null && node.getRighttype()==0) {
                node = node.getRight();
            }
        }
    }
~~~

#### 2、链式存储

- 二叉树的链式存储结构是指：用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。 通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储地址 。
- 链式结构又分为二叉链和三叉链，当前我们学习中一般都是二叉链，后面课程学到高阶数据结构如红黑树等会用到三叉链。

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021031917043953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70#pic_center) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210319170814596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5NjM4Nw==,size_16,color_FFFFFF,t_70#pic_center) 

### 二叉树的性质

若规定根节点的层数为1，则一棵非空二叉树的第i层上最多有2^(i-1) 个结点.

若规定根节点的层数为1，则深度为h的二叉树的最大结点数是2^h- 1.

对任何一棵二叉树, 如果度为0其叶结点个数为 n0, 度为2的分支结点个数为 n2,则有n0＝n2＋1

若规定根节点的层数为1，具有n个结点的满二叉树的深度，h=Log2(n+1). (ps：Log2(n+1)是log以2为
底，n+1为对数)

对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对
于序号为i的结点有：

~~~
若i>0，i位置节点的双亲序号：(i-1)/2；i=0，i为根节点编号，无双亲节点
若2i+1<n，左孩子序号：2i+1，2i+1>=n否则无左孩子
若2i+2<n，右孩子序号：2i+2，2i+2>=n否则无右孩子
~~~

# 树结构实际应用

## 堆排序

### 堆排序基本介绍：

> 1. 堆排序是利用堆这种数据结构而设计的一种排序算法，<font color='green'>堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。</font>
> 2. <font color='orange'>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</font>
> 3. <font color='blue'> 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 </font>
> 4. 大顶堆举例说明：
>
> ![1648992479636](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648992479636.png)

**对堆中的结点按层进行编号，映射到数组中就是下面这个样子:**

![1648992502691](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648992502691.png)

<font color='red'>大顶堆特点 ： arr[i] >= arr[2*i+1] && arr[i] >=
arr[2*i+2] // i 对应第几个节点，i 从0</font>

> 5. 小顶堆举例说明：
>
> ![1648992694773](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648992694773.png)
>
> <font color='red'> 小顶堆：arr[i] <= arr[2*i+1] && arr[i] <= arr[2*i+2] // i 对应第几个节点，i 从0 开始编号 </font>
>
> 6. **<font color='green'> 一般升序采用大顶堆，降序采用小顶堆</font>**

### 堆排序基本思想：

> 堆排序的基本思想是：
>
> 1. 将待排序序列构造成一个大顶堆
> 2. 此时，整个序列的最大值就是堆顶的根节点。
> 3. 将其与末尾元素进行交换，此时末尾就为最大值。
> 4. 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。
>
> 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了

要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。

![1648993021764](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648993021764.png)

步骤说明：

**步骤一：构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）。原始的数组：[4,6,8,5,9]**

（1）假设给定无序序列结构如下：

![1649035969913](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649035969913.png)

（2）此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。

![1649036038761](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036038761.png)

（3）找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。

![1649036074143](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036074143.png)

（4）这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6.

![1649036108338](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036108338.png)

此时，我们就将一个无序序列构造成了一个大顶堆。

**步骤二：将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。**

（1）将堆顶元素9和末尾元素4进行交换

![1649036212033](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036212033.png)

（2）重新调整结构，使其继续满足堆定义

![1649036241822](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036241822.png)

（3）再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

![1649036271987](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036271987.png)

（4）后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![1649036305140](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649036305140.png)

> **总结堆排序的基本思路：**
>
> 1. 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆；
> 2. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端；
> 3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

代码实现：

~~~
package DataStructures.Tree.DuiSort;

import java.util.Arrays;

public class HeapSort {
    public static void main(String[] args) {
        // 要求将数组进行升序排序
        int arr[] = {4,6,8,5,9};
        heapSort(arr);

    }

    // 编写一个堆排序的方法
    public static void heapSort(int[] arr){
        int temp =0;
        System.out.println("堆排序！");
        // 示例分布完成
        //adjustHeap(arr,1,arr.length);
        //System.out.println("第一次："+ Arrays.toString(arr));
        //
        //adjustHeap(arr,0,arr.length);
        //System.out.println("第二次："+Arrays.toString(arr));

        // 完成最终代码
        // 1、将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆）
        for (int i=arr.length/2-1;i>=0;i--){
            adjustHeap(arr,i,arr.length);
        }

        // 2、将堆顶元素与末尾元素进行交换，使末尾元素最大。
        // 3、然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换
        for (int j=arr.length-1;j>0;j--){
            // 交换
            temp = arr[j];
            arr[j]=arr[0];
            arr[0]=temp;
            adjustHeap(arr,0,j);
        }
        System.out.println(Arrays.toString(arr));
    }

    // 将一个数组（二叉树）调整为大顶堆

    /**
     * 功能：完成将以 i 对应的非叶子结点的树调整为大顶堆
     * int[] arr = {4,6,8,5,9}; => i=1(以6为非叶子结点)=> 得到4,9,8,5,6
     * @param arr 待调整的数组
     * @param i 表示非叶子结点在数组中的索引
     * @param len 表示对多少个元素进行调整，length是在逐渐减少
     */
    public static void adjustHeap(int[] arr,int i,int len){
        // 先取出当前元素的值，保存在临时变量
        int temp = arr[i];

        // k指向的是i结点的左子结点
        for (int k =i*2+1;k<len;k=k*2+1){
            // 左子结点的值小于右子结点的值
            if (k+1 < len && arr[k]<arr[k+1]){
                // k指向右子结点
                k++;
            }
            if (arr[k] > temp){
                // 如果子结点大于父结点
                // 把较大的值赋给当前结点
                arr[i]= arr[k];
                // ！！！i指向k，继续循环比较
                i = k;
            }else {
                break;
            }
        }
        // for循环结束后，已经将以i为父结点的树的最大值，放到了堆顶（局部）
        arr[i] = temp;
    }
}
~~~

**堆排序速度很快**

## 赫夫曼树

### 赫夫曼树基本介绍

1. **给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(HuffmanTree),** 还有的书翻译为霍夫曼树。
2. <font color='red'>**赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。**</font>

### 重要概念

> 1. 路径和路径长度：<font color='green'> **在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。** </font><font color='blue'> **通路中分支的数目称为路径长度。** </font><font color='red'> **若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1** </font>
> 2. **结点的权及带权路径长度：**<font color='orange'>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。 </font><font color='red'> **结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积** </font>

![1649038550904](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649038550904.png)

> 3. <font color='orange'>树的带权路径长度：</font><font color='orange'> 树的带权路径长度规定为所有叶子结点的带权路径长度之和， </font>记为WPL(weighted path length) ，<font color='green'>权值越大的结点离根结点越近的二叉树才是最优二叉树。</font>
>
> 4. **<font color='blue'>WPL最小的就是赫夫曼树</font>**

![1649038698673](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649038698673.png)

### 赫夫曼树创建思路图解

> 给你一个数列 {13, 7, 8, 3, 29, 6, 1}，要求转成一颗赫夫曼树。
> 思路分析( 示意图)：
>
> {13, 7, 8, 3, 29, 6, 1}
> 构成赫夫曼树的步骤：
>
> 1. 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
> 2. 取出根节点权值最小的两颗二叉树
> 3. 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
> 4. 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

![1649040127167](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649040127167.png)

代码实现：

~~~
package DataStructures.huffmanTree;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class HuffmanTree {
    public static void main(String[] args) {
        int[] arr = {13, 7, 8, 3, 29, 6, 1};

        Node node = createHuffmanTree(arr);
        preOrder(node);
        System.out.println();
        System.out.println("哈夫曼树根节点为："+node);
    }

    // 前序遍历方法
    public static void preOrder(Node root){
        if (root != null){
            root.preOrder();
        }else {
            System.out.println("该哈夫曼树为空树，无法遍历！");
        }
    }
    // 创建哈夫曼树的方法
    public static Node createHuffmanTree(int[] arr){
        // 1、为操作方便
        // 1）遍历arr数组
        // 2）将arr的每个元素构成一个Node
        // 3）将Node放入到ArrayList中
        List<Node> nodes = new ArrayList<Node>();
        for (int value:arr){
            nodes.add(new Node(value));
        }
        // 处理的过程是一个循环的过程
        while (nodes.size()>1){
            // 排序：从小到大
            Collections.sort(nodes);
            System.out.println("nodes="+nodes);

            // 取出根节点权值最小的二叉树
            //（1）取出ArrayList的前两个元素（因为数组是从小到大按序排）（二叉树）
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            // （2）构建一棵新的二叉树，根节点的value等于前两个元素value之和
            Node parent = new Node(leftNode.value+rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;

            // 从ArrayList中删除已经使用过的两个节点
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 将parent加入到nodes中
            nodes.add(parent);

            //Collections.sort(nodes);
            //System.out.println("第一次处理后："+nodes);
        }

        // 返回哈夫曼树的root
        return nodes.get(0);

    }
}

// 创建结点类
// 为了让Node对象持续排序Collections集合排序
// 让Node实现Comparable接口
class Node implements Comparable<Node>{
    // 结点权值
    int value;
    // 指向左子结点
    Node left;
    // 指向右子结点
    Node right;

    public Node(int value){
        this.value = value;
    }

    // 前序遍历
    public void preOrder(){
        System.out.print(this.value+"  ");
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    @Override
    public int compareTo(Node o) {
        // 表示从小到大排序
        return this.value - o.value;

        // 表示从大到小排序
        //return -(this.value - o.value);
    }
}
~~~

![1649042078131](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649042078131.png)

## 赫夫曼编码

**基本介绍**

> 1. 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，属于一种程序算法
> 2. 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
> 3. 赫夫曼编码广泛地用于数据文件压缩。其 压缩率通常在20% ～90%之间
> 4. 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

![1649227500174](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649227500174.png)

![1649227593087](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649227593087.png)

**<font color='green'> 字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码</font>**

![1649227846293](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649227846293.png)

#### 赫夫曼编码的原理分析

![1649228044027](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649228044027.png)

![1649228088346](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649228088346.png)

> 注意，**这个赫夫曼树根据排序方法不同，也可能不太一样，** 这样对应的赫夫曼编码也不完全一样，**但是wpl 是一样的，都是最小的**，比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为：

![1649228253555](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649228253555.png)

#### 最佳实践- 数据压缩( 创建赫夫曼树)

将给出的一段文本，比如 "i like like like java do you like a java" ， 根据前面的讲的赫夫曼编码原理，对其进行数据压缩处理 ， 形式如下：
"101010011011110111101001101111011110100110111101111010000110000111001
1001111000011001111000100100100110111101111011100100001100001110"

> 步骤1：根据赫夫曼编码压缩数据的原理，需要创建 "i like like like java do you like a java" 对应的赫夫曼树.

![1649229333531](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649229333531.png)

实现代码：

~~~
package DataStructures.HuffmanCode;

import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();

        System.out.println(contentBytes.length); // 40

        List<Node> nodes = getNodes(contentBytes);
        System.out.println("Nodes="+nodes);

        // 测试创建的二叉树
        System.out.println("赫夫曼树：");
        Node HuffmanTreeRoot = createHuffmanTree(nodes);
        // 前序遍历哈夫曼树
        preOrder(HuffmanTreeRoot);
        //HuffmanTreeRoot.preOrder();
    }
    // 前序遍历哈夫曼树
    public static void preOrder(Node root){
        if (root!=null){
            root.preOrder();
        }else {
            System.out.println("赫夫曼树为空，无法遍历！");
        }
    }

    /**
     *
     * @param bytes 接收字节数组
     * @return 返回List：Node[]date=32,weight = 9]......]
     */
    private static List<Node> getNodes(byte[] bytes){
        // 先创建一个ArrayList
        ArrayList<Node> nodes = new ArrayList<Node>();
        // 遍历bytes，统计每个byte出现的次数 -> map[key,value]
        Map<Byte,Integer> counts = new HashMap<>();
        for (byte b:bytes){
            Integer count = counts.get(b);
            if (count==null){
                // map还没有这个字符数据，第一次
                counts.put(b,1);
            }else {
                counts.put(b,count+1);
            }
        }

        // 把每一个键值对转成一个Node对象，并加入到nodes集合中
        // 遍历map
        for (Map.Entry<Byte,Integer> entry:counts.entrySet()){
            nodes.add(new Node(entry.getKey(),entry.getValue()));

        }
        return nodes;
    }

    // 可以通过List 创建对应的赫夫曼树
    private static Node createHuffmanTree(List<Node> nodes){

        while (nodes.size()>1){
            // 排序，从小到大
            Collections.sort(nodes);
            // 取出第一、二棵最小的二叉树
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            // 创建一棵新的二叉树，根节点没有data，只有权值
            Node parent = new Node(null,leftNode.weight+rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            // 将处理过的二叉树从nodes删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 将新的二叉树加入到nodes中
            nodes.add(parent);
        }
        // nodes最后的结点，就是哈夫曼树的根节点
        return nodes.get(0);
    }
}

// 创建Node，带数据和权值
class Node implements Comparable<Node>{
    // 存放数据本身，比如'a'=> 97 ''=> 32
    Byte data;
    // 权值，表示字符出现的次数
    int weight;
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        // 从小到大排序
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                "}";
    }

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }
}
~~~

#### 最佳实践- 数据压缩( 生成赫夫曼编码和赫夫曼编码后的数据）

> 我们已经生成了赫夫曼树, 下面我们继续完成任务：
>
> 1. 生成赫夫曼树对应的赫夫曼编码 , 如下表:
>     =01 a=100 d=11000 u=11001 e=1110 v=11011 i=101 y=11010 j=0010 k=1111 l=000  o=0011
> 2. 使用赫夫曼编码来生成赫夫曼编码数据 ,即按照上面的赫夫曼编码，将"i like like like java do you like a java" 字符串生成对应的编码数据, 形式如下.
>    1010100010111111110010001011111111001000101111111100100101001101110
>    001110000011011101000111100101000101111111100110001001010011011100
>
> 思路：前面已经分析过了，而且我们讲过了生成赫夫曼编码的具体实现。

代码实现：

~~~
package DataStructures.HuffmanCode;

import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();

        System.out.println(contentBytes.length); // 40

        List<Node> nodes = getNodes(contentBytes);
        System.out.println("Nodes="+nodes);

        // 测试创建的二叉树
        System.out.println("赫夫曼树：");
        Node HuffmanTreeRoot = createHuffmanTree(nodes);
        // 前序遍历哈夫曼树
        preOrder(HuffmanTreeRoot);
        //HuffmanTreeRoot.preOrder();

        // 测试是否生成了对应的Huffman编码
        //getCodes(HuffmanTreeRoot,"",stringBuilder);
        // 调用重载后的方法
        getCodes(HuffmanTreeRoot);
        System.out.println("生成的赫夫曼编码表为："+huffmanCodes);
    }
    // 生成的赫夫曼树对应的赫夫曼编码表
    // 思路：
    // 1、将赫夫曼编码表存放在Map<Byte,String> 形式为：
    // 32=>01、97=>100、100=>11000等等
    static Map<Byte,String> huffmanCodes = new HashMap<Byte,String>();
    // 2、在生成赫夫曼编码表时需要拼接路径，定义一个StringBuilder存储某个叶子结点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    // 为了调用方便，重载getCodes()
    private static Map<Byte,String> getCodes(Node root){
        if (root==null){
            return null;
        }
        // 处理root的左子树
        getCodes(root.left,"0",stringBuilder);
        // 处理root的右子树
        getCodes(root.right,"1",stringBuilder);

        return huffmanCodes;
    }

    /**
     * 功能：将传入的node结点的所有的叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合中
     * @param node 传入结点
     * @param code 路径，左子结点为0，右子结点为1
     * @param stringBuilder 用于拼接路径
     */
    private static void getCodes(Node node,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        // 将传入的code加入到stringBuilder2
        stringBuilder2.append(code);
        if (node!=null){
            // 如果node=null不处理
            //判断当前node是叶子结点还是非叶子结点
            if (node.data==null){
                // 非叶子结点
                // 递归处理
                // 向左
                getCodes(node.left,"0",stringBuilder2);
                // 向右
                getCodes(node.right,"1",stringBuilder2);
            }else {
                // 说明是一个叶子结点
                // 表示找到了某个叶子结点的最后
                huffmanCodes.put(node.data,stringBuilder2.toString());
            }
        }

    }


    // 前序遍历哈夫曼树
    public static void preOrder(Node root){
        if (root!=null){
            root.preOrder();
        }else {
            System.out.println("赫夫曼树为空，无法遍历！");
        }
    }

    /**
     *
     * @param bytes 接收字节数组
     * @return 返回List：Node[]date=32,weight = 9]......]
     */
    private static List<Node> getNodes(byte[] bytes){
        // 先创建一个ArrayList
        ArrayList<Node> nodes = new ArrayList<Node>();
        // 遍历bytes，统计每个byte出现的次数 -> map[key,value]
        Map<Byte,Integer> counts = new HashMap<>();
        for (byte b:bytes){
            Integer count = counts.get(b);
            if (count==null){
                // map还没有这个字符数据，第一次
                counts.put(b,1);
            }else {
                counts.put(b,count+1);
            }
        }

        // 把每一个键值对转成一个Node对象，并加入到nodes集合中
        // 遍历map
        for (Map.Entry<Byte,Integer> entry:counts.entrySet()){
            nodes.add(new Node(entry.getKey(),entry.getValue()));

        }
        return nodes;
    }

    // 可以通过List 创建对应的赫夫曼树
    private static Node createHuffmanTree(List<Node> nodes){

        while (nodes.size()>1){
            // 排序，从小到大
            Collections.sort(nodes);
            // 取出第一、二棵最小的二叉树
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            // 创建一棵新的二叉树，根节点没有data，只有权值
            Node parent = new Node(null,leftNode.weight+rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            // 将处理过的二叉树从nodes删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 将新的二叉树加入到nodes中
            nodes.add(parent);
        }
        // nodes最后的结点，就是哈夫曼树的根节点
        return nodes.get(0);
    }
}

// 创建Node，带数据和权值
class Node implements Comparable<Node>{
    // 存放数据本身，比如'a'=> 97 ''=> 32
    Byte data;
    // 权值，表示字符出现的次数
    int weight;
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        // 从小到大排序
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                "}";
    }

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }
}
~~~

#### 最佳实践- 数据解压( 使用赫夫曼编码解码)

> 使用赫夫曼编码来解码数据，具体要求是：
>
> 1. 前面我们得到了赫夫曼编码和对应的编码byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
> 2. 现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串"i like like like java do you like a java"
>
> 思路：解码过程，就是编码的一个逆向操作。

实现代码：

~~~
package DataStructures.HuffmanCode;

import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();  // 40位

        System.out.println(contentBytes.length); // 40

        List<Node> nodes = getNodes(contentBytes);
        System.out.println("Nodes="+nodes);

        // 测试创建的二叉树
        System.out.println("赫夫曼树：");
        Node HuffmanTreeRoot = createHuffmanTree(nodes);
        // 前序遍历哈夫曼树
        preOrder(HuffmanTreeRoot);
        //HuffmanTreeRoot.preOrder();

        // 测试是否生成了对应的Huffman编码
        //getCodes(HuffmanTreeRoot,"",stringBuilder);
        // 调用重载后的方法
        getCodes(HuffmanTreeRoot);
        System.out.println("生成的赫夫曼编码表为："+huffmanCodes);

        // 测试
        byte[] huffmanCodeBytes = zip(contentBytes,huffmanCodes);
        System.out.println("huffmanCodeBytes="+Arrays.toString(huffmanCodeBytes)); // 17位
    }

    // 编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]

    /**
     *
     * @param bytes 这是原始的字符串对应的byte[]
     * @param huffmanCodes huffmanCodes 生成的赫夫曼编码
     * @return 返回赫夫曼编码处理后的数组
     * 举例：String content = "i like like like java do you like a java"; => byte[] contentBytes = content.getBytes();
     * 返回的是：1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100
     *         这个字符串对应的byte[] HuffmanCodeBytes，即8位对应一个byte，放入到huffmanCodeBytes
     *         huffmanCodeBytes[0] = 10101000(补码) => byte [推导 反码：符号位不变，补码-1---> 10100111(反码)--->原码：符号位不变，其他位取反 --> 11011000(原码) = -88]
     *         也就是说huffmanCodeBytes[1] = -88
     */
    private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes){
        // 1、先利用赫夫曼编码表将传进来的bytes(数组)转为赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        // 遍历bytes数组
        for (byte b:bytes){
            stringBuilder.append(huffmanCodes.get(b));
        }
        // 将"1010100010111111110..."转为byte[] 数组

        // 统计返回 byte[] huffmanCodeBytes 长度
        int len;
        if (stringBuilder.length() % 8 ==0 ){
            len = stringBuilder.length()/8;
        }else {
            len = stringBuilder.length() / 8 + 1;
        }
        // 创建一个存储压缩后的byte数组
        byte[] huffmanCodeBytes = new byte[len];
        // 定义一个计数器，记录是第几个byte
        int index=0;
        for (int i=0;i<stringBuilder.length();i+=8){
            // 因为是每8位对应一个byte，所以步长 +8
            String strByte;
            if (i+8>stringBuilder.length()){
                // 不够八位，则有多少位取多少位
                strByte = stringBuilder.substring(i);
            }else {
                strByte = stringBuilder.substring(i,i+8);
            }
            // 将strByte转为byte，放入到by
            huffmanCodeBytes[index]=(byte)Integer.parseInt(strByte,2);
            index++;
        }
        return huffmanCodeBytes;
    }


    // 生成的赫夫曼树对应的赫夫曼编码表
    // 思路：
    // 1、将赫夫曼编码表存放在Map<Byte,String> 形式为：
    // 32=>01、97=>100、100=>11000等等
    static Map<Byte,String> huffmanCodes = new HashMap<Byte,String>();
    // 2、在生成赫夫曼编码表时需要拼接路径，定义一个StringBuilder存储某个叶子结点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    // 为了调用方便，重载getCodes()
    private static Map<Byte,String> getCodes(Node root){
        if (root==null){
            return null;
        }
        // 处理root的左子树
        getCodes(root.left,"0",stringBuilder);
        // 处理root的右子树
        getCodes(root.right,"1",stringBuilder);

        return huffmanCodes;
    }

    /**
     * 功能：将传入的node结点的所有的叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合中
     * @param node 传入结点
     * @param code 路径，左子结点为0，右子结点为1
     * @param stringBuilder 用于拼接路径
     */
    private static void getCodes(Node node,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        // 将传入的code加入到stringBuilder2
        stringBuilder2.append(code);
        if (node!=null){
            // 如果node=null不处理
            //判断当前node是叶子结点还是非叶子结点
            if (node.data==null){
                // 非叶子结点
                // 递归处理
                // 向左
                getCodes(node.left,"0",stringBuilder2);
                // 向右
                getCodes(node.right,"1",stringBuilder2);
            }else {
                // 说明是一个叶子结点
                // 表示找到了某个叶子结点的最后
                huffmanCodes.put(node.data,stringBuilder2.toString());
            }
        }

    }


    // 前序遍历哈夫曼树
    public static void preOrder(Node root){
        if (root!=null){
            root.preOrder();
        }else {
            System.out.println("赫夫曼树为空，无法遍历！");
        }
    }

    /**
     *
     * @param bytes 接收字节数组
     * @return 返回List：Node[]date=32,weight = 9]......]
     */
    private static List<Node> getNodes(byte[] bytes){
        // 先创建一个ArrayList
        ArrayList<Node> nodes = new ArrayList<Node>();
        // 遍历bytes，统计每个byte出现的次数 -> map[key,value]
        Map<Byte,Integer> counts = new HashMap<>();
        for (byte b:bytes){
            Integer count = counts.get(b);
            if (count==null){
                // map还没有这个字符数据，第一次
                counts.put(b,1);
            }else {
                counts.put(b,count+1);
            }
        }

        // 把每一个键值对转成一个Node对象，并加入到nodes集合中
        // 遍历map
        for (Map.Entry<Byte,Integer> entry:counts.entrySet()){
            nodes.add(new Node(entry.getKey(),entry.getValue()));

        }
        return nodes;
    }

    // 可以通过List 创建对应的赫夫曼树
    private static Node createHuffmanTree(List<Node> nodes){

        while (nodes.size()>1){
            // 排序，从小到大
            Collections.sort(nodes);
            // 取出第一、二棵最小的二叉树
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            // 创建一棵新的二叉树，根节点没有data，只有权值
            Node parent = new Node(null,leftNode.weight+rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            // 将处理过的二叉树从nodes删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 将新的二叉树加入到nodes中
            nodes.add(parent);
        }
        // nodes最后的结点，就是哈夫曼树的根节点
        return nodes.get(0);
    }
}

// 创建Node，带数据和权值
class Node implements Comparable<Node>{
    // 存放数据本身，比如'a'=> 97 ''=> 32
    Byte data;
    // 权值，表示字符出现的次数
    int weight;
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        // 从小到大排序
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                "}";
    }

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }
}
~~~

#### 最佳实践- 数据解压( 使用赫夫曼编码解码)

> 使用赫夫曼编码来解码数据，具体要求是：
>
> 1. 前面我们得到了赫夫曼编码和对应的编码byte[] , 即:[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
> 2. 现在要求使用赫夫曼编码， 进行解码，又重新得到原来的字符串"i like like like java do you like a java"
>
> 思路：解码过程，就是编码的一个逆向操作

实现代码：

~~~
// 完成数据的解压
    /*
    思路：
        1、将 huffmanCodeBytes=[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
          重写先转成赫夫曼编码对应的二进制的字符串："1010100010111..."
        2、赫夫曼编码对应的二进制的字符串"1010100010111..." --> 对照赫夫曼编码 --> "i like like like java do you like a java"
     */
    // 编写一个方法，完成对压缩数据的解码

    /**
     *
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 返回原来的字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes){
        //1、先得到 huffmanBytes 对应的二进制的字符串，形式：10101000111...
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转为二进制的字符串
        for (int i=0;i<huffmanBytes.length;i++){
            byte b = huffmanBytes[i];
            // 判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length-1);
            stringBuilder.append(byteToBitString(!flag,b));
        }
        // 把字符串按照指定的赫夫曼编码进行编码
        // 把赫夫曼编码表进行调换，反向查询：a->100  100->a
        Map<String,Byte> map = new HashMap<String, Byte>();
        for (Map.Entry<Byte,String> entry:huffmanCodes.entrySet()){
            map.put(entry.getValue(),entry.getKey());
        }
        System.out.println("map="+map);
        // 创建一个集合存放byte
        List<Byte> list = new ArrayList<>();
        // i是一个索引，不停的扫描stringBuilder
        for (int i=0;i<stringBuilder.length();){
            // 小的计数器
            int count = 1;
            boolean flag = true;
            Byte b =null;

            while (flag){
                // 取出一个'1' '0'
                // i不动，让count移动，直到匹配到一个字符
                String key = stringBuilder.substring(i,i+count);
                b = map.get(key);
                if (b==null){
                    // 说明没有匹配到
                    count++;
                }else {
                    // 匹配到
                    flag = false;
                }
            }
            list.add(b);
            // i直接移动到 count的位置
            i += count;
        }
        // 当for循环结束后，就得到了字符："i like like like java do you like a java"
        // 把list中的数据放到byte[] 并返回
        byte[] bytes = new byte[list.size()];
        for (int i=0;i< bytes.length;i++){
            bytes[i] = list.get(i);
        }
        return bytes;
    }

    /**
     * 将一个byte转为一个二进制的字符串
     * @param b 传入的byte
     * @param flag 标识是否需要补高位，如果为true，表示需要补高位，false表示不补，如果是最后一个字节，无需补高位
     * @return 该 b对应的二进制的字符串（注意：是按补码返回）
     */
    private static String byteToBitString(boolean flag,byte b){
        // 使用变量保存b，即将b转为int
        int temp = b;
        if (flag){
            // 如果是正数，存在补高位的问题
            // 按位与：256 1 0000 0000 | 0000 0001 ---> 1 0000 0001
            temp |= 256;
        }

        String str = Integer.toBinaryString(temp); // 这里返回的是temp对应的二进制的补码

        if (flag){
            // 取后面的8位
            return str.substring(str.length()-8);
        }else {
            return str;
        }
    }
~~~

**完整代码：**

~~~
package DataStructures.HuffmanCode;

import java.text.NumberFormat;
import java.util.*;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();  // 40位

        System.out.println(contentBytes.length); // 40


        // 分步过程
        /*
        List<Node> nodes = getNodes(contentBytes);
        System.out.println("Nodes="+nodes);

        // 测试创建的二叉树
        System.out.println("赫夫曼树：");
        Node HuffmanTreeRoot = createHuffmanTree(nodes);
        // 前序遍历哈夫曼树
        preOrder(HuffmanTreeRoot);
        //HuffmanTreeRoot.preOrder();

        // 测试是否生成了对应的Huffman编码
        //getCodes(HuffmanTreeRoot,"",stringBuilder);
        // 调用重载后的方法
        getCodes(HuffmanTreeRoot);
        System.out.println("生成的赫夫曼编码表为："+huffmanCodes);

        // 测试
        byte[] huffmanCodeBytes = zip(contentBytes,huffmanCodes);
        System.out.println("huffmanCodeBytes="+Arrays.toString(huffmanCodeBytes)); // 17位
        */

        // 发送HuffmanCodeBytes数组
        byte[] huffmanCodeBytes = huffmanZip(contentBytes);
        System.out.println("huffmanCodeBytes="+Arrays.toString(huffmanCodeBytes));
        System.out.println("length为："+huffmanCodeBytes.length);
        double rote = (double)(contentBytes.length-huffmanCodeBytes.length)/contentBytes.length;
        NumberFormat num = NumberFormat.getPercentInstance();
        String rates = num.format(rote);
        System.out.println("压缩率为："+rates);


        byte[] newBytes = decode(huffmanCodes,huffmanCodeBytes);
        System.out.println("原来的字符串为："+new String(newBytes)); // "i like like like java do you like a java"


    }
    // 完成数据的解压
    /*
    思路：
        1、将 huffmanCodeBytes=[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
          重写先转成赫夫曼编码对应的二进制的字符串："1010100010111..."
        2、赫夫曼编码对应的二进制的字符串"1010100010111..." --> 对照赫夫曼编码 --> "i like like like java do you like a java"
     */
    // 编写一个方法，完成对压缩数据的解码

    /**
     *
     * @param huffmanCodes 赫夫曼编码表
     * @param huffmanBytes 赫夫曼编码得到的字节数组
     * @return 返回原来的字符串对应的数组
     */
    private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes){
        //1、先得到 huffmanBytes 对应的二进制的字符串，形式：10101000111...
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转为二进制的字符串
        for (int i=0;i<huffmanBytes.length;i++){
            byte b = huffmanBytes[i];
            // 判断是不是最后一个字节
            boolean flag = (i == huffmanBytes.length-1);
            stringBuilder.append(byteToBitString(!flag,b));
        }
        // 把字符串按照指定的赫夫曼编码进行编码
        // 把赫夫曼编码表进行调换，反向查询：a->100  100->a
        Map<String,Byte> map = new HashMap<String, Byte>();
        for (Map.Entry<Byte,String> entry:huffmanCodes.entrySet()){
            map.put(entry.getValue(),entry.getKey());
        }
        System.out.println("map="+map);
        // 创建一个集合存放byte
        List<Byte> list = new ArrayList<>();
        // i是一个索引，不停的扫描stringBuilder
        for (int i=0;i<stringBuilder.length();){
            // 小的计数器
            int count = 1;
            boolean flag = true;
            Byte b =null;

            while (flag){
                // 取出一个'1' '0'
                // i不动，让count移动，直到匹配到一个字符
                String key = stringBuilder.substring(i,i+count);
                b = map.get(key);
                if (b==null){
                    // 说明没有匹配到
                    count++;
                }else {
                    // 匹配到
                    flag = false;
                }
            }
            list.add(b);
            // i直接移动到 count的位置
            i += count;
        }
        // 当for循环结束后，就得到了字符："i like like like java do you like a java"
        // 把list中的数据放到byte[] 并返回
        byte[] bytes = new byte[list.size()];
        for (int i=0;i< bytes.length;i++){
            bytes[i] = list.get(i);
        }
        return bytes;
    }

    /**
     * 将一个byte转为一个二进制的字符串
     * @param b 传入的byte
     * @param flag 标识是否需要补高位，如果为true，表示需要补高位，false表示不补，如果是最后一个字节，无需补高位
     * @return 该 b对应的二进制的字符串（注意：是按补码返回）
     */
    private static String byteToBitString(boolean flag,byte b){
        // 使用变量保存b，即将b转为int
        int temp = b;
        if (flag){
            // 如果是正数，存在补高位的问题
            // 按位与：256 1 0000 0000 | 0000 0001 ---> 1 0000 0001
            temp |= 256;
        }

        String str = Integer.toBinaryString(temp); // 这里返回的是temp对应的二进制的补码

        if (flag){
            // 取后面的8位
            return str.substring(str.length()-8);
        }else {
            return str;
        }
    }

    /**
     *
     * @param bytes 原始的字符串对应的字节数组即contentBytes
     * @return 经过赫夫曼编码处理后的字节数组，即压缩后的数组
     */
    // 使用一个方法，将一系列的方法封装起来，便于我们的调用
    private static byte[] huffmanZip(byte[] bytes){
        List<Node> nodes = getNodes(bytes);
        // 根据nodes创建赫夫曼树
        Node huffmanTreeRoot = createHuffmanTree(nodes);
        // 根据赫夫曼树创建对应的赫夫曼编码
        Map<Byte,String> huffmanCodes = getCodes(huffmanTreeRoot);
        // 根据生成的赫夫曼编码压缩，得到压缩后的赫夫曼编码字节数组
        byte[] huffmanCodeBytes = zip(bytes,huffmanCodes);

        return huffmanCodeBytes;
    }

    // 编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]
    /**
     *
     * @param bytes 这是原始的字符串对应的byte[]
     * @param huffmanCodes huffmanCodes 生成的赫夫曼编码
     * @return 返回赫夫曼编码处理后的数组
     * 举例：String content = "i like like like java do you like a java"; => byte[] contentBytes = content.getBytes();
     * 返回的是：1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100
     *         这个字符串对应的byte[] HuffmanCodeBytes，即8位对应一个byte，放入到huffmanCodeBytes
     *         huffmanCodeBytes[0] = 10101000(补码) => byte [推导 反码：符号位不变，补码-1---> 10100111(反码)--->原码：符号位不变，其他位取反 --> 11011000(原码) = -88]
     *         也就是说huffmanCodeBytes[1] = -88
     */
    private static byte[] zip(byte[] bytes,Map<Byte,String> huffmanCodes){
        // 1、先利用赫夫曼编码表将传进来的bytes(数组)转为赫夫曼编码对应的字符串
        StringBuilder stringBuilder = new StringBuilder();
        // 遍历bytes数组
        for (byte b:bytes){
            stringBuilder.append(huffmanCodes.get(b));
        }
        // 将"1010100010111111110..."转为byte[] 数组

        // 统计返回 byte[] huffmanCodeBytes 长度
        // 简写：int len = (stringBuilder.length() + 7) / 8
        int len;
        if (stringBuilder.length() % 8 ==0 ){
            // 可以被8整除
            len = stringBuilder.length()/8;
        }else {
            // 不能被8整除
            len = stringBuilder.length() / 8 + 1;
        }

        // 创建一个存储压缩后的byte数组
        byte[] huffmanCodeBytes = new byte[len];
        // 定义一个计数器，记录是第几个byte
        int index=0;
        for (int i=0;i<stringBuilder.length();i+=8){
            // 因为是每8位对应一个byte，所以步长 +8
            String strByte;
            if (i+8>stringBuilder.length()){
                // 不够八位，则有多少位取多少位
                strByte = stringBuilder.substring(i);
            }else {
                strByte = stringBuilder.substring(i,i+8);
            }
            // 将strByte转为byte，放入到by
            huffmanCodeBytes[index]=(byte)Integer.parseInt(strByte,2);
            index++;
        }
        return huffmanCodeBytes;
    }


    // 生成的赫夫曼树对应的赫夫曼编码表
    // 思路：
    // 1、将赫夫曼编码表存放在Map<Byte,String> 形式为：
    // 32=>01、97=>100、100=>11000等等
    static Map<Byte,String> huffmanCodes = new HashMap<Byte,String>();
    // 2、在生成赫夫曼编码表时需要拼接路径，定义一个StringBuilder存储某个叶子结点的路径
    static StringBuilder stringBuilder = new StringBuilder();

    // 为了调用方便，重载getCodes()
    private static Map<Byte,String> getCodes(Node root){
        if (root==null){
            return null;
        }
        // 处理root的左子树
        getCodes(root.left,"0",stringBuilder);
        // 处理root的右子树
        getCodes(root.right,"1",stringBuilder);

        return huffmanCodes;
    }

    /**
     * 功能：将传入的node结点的所有的叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合中
     * @param node 传入结点
     * @param code 路径，左子结点为0，右子结点为1
     * @param stringBuilder 用于拼接路径
     */
    private static void getCodes(Node node,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        // 将传入的code加入到stringBuilder2
        stringBuilder2.append(code);
        if (node!=null){
            // 如果node=null不处理
            //判断当前node是叶子结点还是非叶子结点
            if (node.data==null){
                // 非叶子结点
                // 递归处理
                // 向左
                getCodes(node.left,"0",stringBuilder2);
                // 向右
                getCodes(node.right,"1",stringBuilder2);
            }else {
                // 说明是一个叶子结点
                // 表示找到了某个叶子结点的最后
                huffmanCodes.put(node.data,stringBuilder2.toString());
            }
        }

    }

    // 前序遍历哈夫曼树
    public static void preOrder(Node root){
        if (root!=null){
            root.preOrder();
        }else {
            System.out.println("赫夫曼树为空，无法遍历！");
        }
    }

    /**
     *
     * @param bytes 接收字节数组
     * @return 返回List：Node[]date=32,weight = 9]......]
     */
    private static List<Node> getNodes(byte[] bytes){
        // 先创建一个ArrayList
        ArrayList<Node> nodes = new ArrayList<Node>();
        // 遍历bytes，统计每个byte出现的次数 -> map[key,value]
        Map<Byte,Integer> counts = new HashMap<>();
        for (byte b:bytes){
            Integer count = counts.get(b);
            if (count==null){
                // map还没有这个字符数据，第一次
                counts.put(b,1);
            }else {
                counts.put(b,count+1);
            }
        }

        // 把每一个键值对转成一个Node对象，并加入到nodes集合中
        // 遍历map
        for (Map.Entry<Byte,Integer> entry:counts.entrySet()){
            nodes.add(new Node(entry.getKey(),entry.getValue()));

        }
        return nodes;
    }

    // 可以通过List 创建对应的赫夫曼树
    private static Node createHuffmanTree(List<Node> nodes){

        while (nodes.size()>1){
            // 排序，从小到大
            Collections.sort(nodes);
            // 取出第一、二棵最小的二叉树
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            // 创建一棵新的二叉树，根节点没有data，只有权值
            Node parent = new Node(null,leftNode.weight+rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            // 将处理过的二叉树从nodes删除
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            // 将新的二叉树加入到nodes中
            nodes.add(parent);
        }
        // nodes最后的结点，就是哈夫曼树的根节点
        return nodes.get(0);
    }
}

// 创建Node，带数据和权值
class Node implements Comparable<Node>{
    // 存放数据本身，比如'a'=> 97 ''=> 32
    Byte data;
    // 权值，表示字符出现的次数
    int weight;
    Node left;
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override
    public int compareTo(Node o) {
        // 从小到大排序
        return this.weight - o.weight;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                "}";
    }

    // 前序遍历
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }
}
~~~

#### 最佳实践-文件压缩

> 思路：读取文件-> 得到赫夫曼编码表 -> 完成压缩

代码实现：

~~~
/**
     *
     * @param srcFile 传入的希望压缩的文件的全路径
     * @param dstFile 压缩后的文件的存放路径
     */
    // 编写方法，将一个文件进行压缩
    public static void zipFile(String srcFile,String dstFile){
        // 创建输出流
        OutputStream os = null;
        ObjectOutputStream oos =null;
        FileInputStream  is = null;
        try{
            // 创建文件输入流
            is = new FileInputStream(srcFile);
            // 创建一个和原文件大小一样的byte[]
            byte[] b = new byte[is.available()];
            // 读取文件
            is.read(b);

            // 使用赫夫曼编码进行编码
            // 获取到文件对应的赫夫曼编码
            // 直接对原文件压缩
            byte[] huffmanBytes = huffmanZip(b);
            // 创建文件的输出流，存放压缩文件
            os = new FileOutputStream(dstFile);
            // 创建一个和文件输出流关联的ObjectOutputStream
            oos = new ObjectOutputStream(os);
            // 把赫夫曼编码后的字节数组写入压缩文件
            oos.writeObject(huffmanBytes);
            // 以对象流的方式写入赫夫曼编码，为了以后恢复原文件时使用
            // 注意：一定把赫夫曼编码写入压缩文件，否则无法恢复
            oos.writeObject(huffmanCodes);

        }catch (Exception e){
            System.out.println(e.getMessage());
        }finally {
            try{
                is.close();
                os.close();
                oos.close();
            }catch (Exception e){
                System.out.println(e.getMessage());
            }
        }
    }
~~~

测试代码：

![1649315615119](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649315615119.png)

#### 最佳实践-文件解压（文件恢复）

> 具体要求：将前面压缩的文件，重新恢复成原来的文件。
>
> <font color='red'>思路：读取压缩文件(数据和赫夫曼编码表)-> 完成解压(文件恢复)</font>

实现代码：

~~~
/**
     *
     * @param zipFile 准备解压的文件
     * @param dstFile 将文件解压到哪个位置
     */
    // 编写文件解压的方法
    public static void unZipFile(String zipFile,String dstFile){
        // 定义文件的输入流
        InputStream is = null;
        // 定义一个与输入流有关的对象输入流
        ObjectInputStream ois = null;
        // 定义文件的输出流
        OutputStream os = null;
        try {
            // 创建文件输入流
            is = new FileInputStream(zipFile);
            // 创建is关联的对象输入流
            ois = new ObjectInputStream(is);
            // 读取byte[]
            byte[] huffmanBytes = (byte[])ois.readObject();
            // 读取赫夫曼编码表
            Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();

            // 解码
            byte[] bytes = decode(huffmanCodes,huffmanBytes);
            // 将bytes写入到目标文件
            os = new FileOutputStream(dstFile);
            // 写数据到文件中
            os.write(bytes);
        }catch (Exception e){
            System.out.println(e.getMessage());
        }finally {
            try {
                os.close();
                ois.close();
                is.close();
            }catch (Exception e){
                System.out.println(e.getMessage());
            }
        }
    }
~~~

测试代码：

![1649316970911](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649316970911.png)

##### 赫夫曼编码压缩文件注意事项：

> 1. 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [ 举例压一个 .ppt ]
> 2. 赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [ 举例压一个.xml文件]
> 3. 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.

## 二叉排序树（BST）

给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加。

> 解决方案：
>
> 1. 使用数组
>    1) 数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢. [ 示意图 ]
>    2) 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。[ 示意图 ]
> 2. 使用链式存储-链表
>    不管链表是否有序，查找速度都慢，添加数据速度比数组快，不需要数据整体移动。[ 示意图 ]
> 3. 使用二叉排序树

### 二叉排序树介绍

**<font color='orange'>二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</font>**

**特别说明：**<font color='red'> 如果有相同的值，可以将该节点放在左子节点或右子节点 </font>

比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![1649322058427](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649322058427.png)

#### 二叉排序树创建和遍历

一个数组创建成对应的二叉排序树，并使用**中序遍历二叉排序树，**比如: 数组为Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为 :

![1649322102421](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649322102421.png)

**代码实现：**

~~~
package DataStructures.BinarySortTree;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7,3,10,12,5,1,9};
        BinarySortTree binarySortTree = new BinarySortTree();
        // 循环的添加结点到二叉排序树
        for (int i=0;i<arr.length;i++){
            Node node = new Node(arr[i]);
            binarySortTree.add(node);
        }
        // 中序遍历二叉排序树
        System.out.println("中序遍历二叉排序树！");
        binarySortTree.infixOrder(); // 1，3，5，7，9，10，12
    }
}
// 创建二叉排序树
class BinarySortTree{
    private Node root;
    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }
}

// 创建结点
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }
}
~~~

#### 二叉排序树的删除

二叉排序树有三种情况需要考虑：

> 1. 删除叶子节点 (比如：2, 5, 9, 12)
> 2. 删除只有一颗子树的节点 (比如：1)
> 3. 删除有两颗子树的节点. (比如：7, 3，10 )

![1649323495690](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649323495690.png)

##### 1、删除叶子节点

> <font color='green'>删除的节点是叶子节点，即该节点下没有左右子节点</font>

> 思路：
>
> 1. 需求先去找到要删除的结点  targetNode
>
> 2. 找到targetNode 的 父结点 parent（考虑是否存在父节点）
>
> 3. 确定 targetNode 是 parent的左子结点还是右子结点
>
> 4. 根据前面的情况来对应删除
>
>    左子结点 parent.left = null
>
>    右子结点 parent.right = null

**代码实现：**

~~~
package DataStructures.BinarySortTree;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        // 循环的添加结点到二叉排序树
        for (int i=0;i<arr.length;i++){
            Node node = new Node(arr[i]);
            binarySortTree.add(node);
        }
        // 中序遍历二叉排序树
        System.out.println("中序遍历二叉排序树！");
        binarySortTree.infixOrder(); // 1，3，5，7，9，10，12

        // 测试删除叶子结点
        binarySortTree.delNode(2);
        System.out.println("删除结点后：");
        binarySortTree.infixOrder();
    }
}
// 创建二叉排序树
class BinarySortTree{
    private Node root;
    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }

    // 查到待删除的结点
    public Node serach(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找待删除节点的父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    // 删除结点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1.需要先找到待删除的结点 targetNode
            Node targetNode = serach(value);
            // 如果没有找打待删除的结点，直接返回
            if (targetNode == null){
                return;
            }
            // 如果targetNode没有父结点，也不需要继续查找待删除结点的父结点，即待删除的结点为root
            if (root.left==null && root.right==null){
                root = null;
                return;
            }
            // 2.找到待删除结点的父结点：parent
            Node parent = searchParent(value);
            // 如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                // 判断targetNode是父结点的左子结点还是右子结点
                if (parent.left!=null && parent.left.value == value){
                    parent.left = null;
                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }
            }
        }
    }
}

// 创建结点
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    // 查找要删除的节点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value){
        if (value == this.value){
            // 找到
            return this;
        }else if (value < this.value){
            if (this.left==null){
                return null;
            }
            // 向左子树递归查找
            return this.left.search(value);
        }else{
            // 向右子树递归查找
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    /**
     *
     * @param value 要查找的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有则返回null
     */
    public Node searchParent(int value){
        // 如果当前节点就是待删除的结点的父结点，就返回
        if ((this.left!=null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null){
                // 向左子树递归查找
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null){
                // 向右子树递归查找
                return this.right.searchParent(value);
            }else {
                // 可能不满足以上条件，则没有找到父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

}
~~~

##### 2、删除节点有一个子节点

> <font color='blue'> 删除的节点有一个子节点，即该节点有左子节点或者右子节点。 </font>

> 思路：
>
> 1. 需求先去找到要删除的结点  targetNode
> 2. 找到targetNode 的父结点 parent 
> 3. 确定targetNode 的子结点是左子结点还是右子结点
> 4. targetNode 是 parent 的左子结点还是右子结点
> 5. 如果targetNode 有左子结点
>    1）如果 targetNode 是 parent 的左子结点
>    parent.left = targetNode.left;
>    2）如果 targetNode 是 parent 的右子结点
>    parent.right = targetNode.left;
> 6. 如果targetNode 有右子结点
>    1）如果 targetNode 是 parent 的左子结点
>    parent.left = targetNode.right;
>    2）如果 targetNode 是 parent 的右子结点
>    parent.right = targetNode.right

![1649323495690](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649323495690.png)

**代码实现：**

~~~
package DataStructures.BinarySortTree;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        // 循环的添加结点到二叉排序树
        for (int i=0;i<arr.length;i++){
            Node node = new Node(arr[i]);
            binarySortTree.add(node);
        }
        // 中序遍历二叉排序树
        System.out.println("中序遍历二叉排序树！");
        binarySortTree.infixOrder(); // 1，3，5，7，9，10，12

        // 测试删除叶子结点
        //binarySortTree.delNode(2);
        binarySortTree.delNode(1);
        System.out.println("删除结点后：");
        binarySortTree.infixOrder();
    }
}
// 创建二叉排序树
class BinarySortTree{
    private Node root;
    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }

    // 查到待删除的结点
    public Node serach(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找待删除节点的父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    // 删除结点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1.需要先找到待删除的结点 targetNode
            Node targetNode = serach(value);
            // 如果没有找打待删除的结点，直接返回
            if (targetNode == null){
                return;
            }
            // 如果targetNode没有父结点，也不需要继续查找待删除结点的父结点，即待删除的结点为root
            if (root.left==null && root.right==null){
                root = null;
                return;
            }
            // 2.找到待删除结点的父结点：parent
            Node parent = searchParent(value);
            // 1、如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                // 判断targetNode是父结点的左子结点还是右子结点
                if (parent.left!=null && parent.left.value == value){
                    parent.left = null;
                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }
            }
            // 2、如果待删除的结点有一个子结点
            else if (targetNode.left!=null || targetNode.right != null){
                if (targetNode.left!=null){
                    // 判断targetNode是父结点的左子结点还是右子结点
                    if (parent.left!=null && parent.left.value == value){
                        parent.left = targetNode.left;
                    }else if (parent.right!=null && parent.right.value == value){
                        parent.right = targetNode.left;
                    }
                }else if (targetNode.right!=null) {
                    // 判断targetNode是父结点的左子结点还是右子结点
                    if (parent.left != null && parent.left.value == value) {
                        parent.left = targetNode.right;
                    } else if (parent.right != null && parent.right.value == value) {
                        parent.right = targetNode.right;
                    }
                }
            }
           
        }
    }
}

// 创建结点
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    // 查找要删除的节点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value){
        if (value == this.value){
            // 找到
            return this;
        }else if (value < this.value){
            if (this.left==null){
                return null;
            }
            // 向左子树递归查找
            return this.left.search(value);
        }else{
            // 向右子树递归查找
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    /**
     *
     * @param value 要查找的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有则返回null
     */
    public Node searchParent(int value){
        // 如果当前节点就是待删除的结点的父结点，就返回
        if ((this.left!=null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null){
                // 向左子树递归查找
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null){
                // 向右子树递归查找
                return this.right.searchParent(value);
            }else {
                // 可能不满足以上条件，则没有找到父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

}
~~~

##### 3、删除节点有两个子节点

> <font color='orange'>删除的节点有两个子节点，即该节点有左子节点和右子节点</font>

> 思路：
>
> 1. 需求先去找到要删除的结点  targetNode
> 2. 找到targetNode 的 父结点 parent 
> 3. 从targetNode 的右子树找到最小的结点
> 4. 用一个临时变量，将最小结点的值保存 temp
> 5. 删除该最小结点
> 6. targetNode.value = temp

![1649323495690](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649323495690.png)

**代码实现：**

~~~
package DataStructures.BinarySortTree;

public class BinarySortTreeDemo {
    public static void main(String[] args) {
        int[] arr = {7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        // 循环的添加结点到二叉排序树
        for (int i=0;i<arr.length;i++){
            Node node = new Node(arr[i]);
            binarySortTree.add(node);
        }
        // 中序遍历二叉排序树
        System.out.println("中序遍历二叉排序树！");
        binarySortTree.infixOrder(); // 1，3，5，7，9，10，12

        // 测试删除叶子结点
        //binarySortTree.delNode(2);
        // 测试删除有一个子节点
        //binarySortTree.delNode(1);
        // 删除有两个子节点
        binarySortTree.delNode(10);
        System.out.println("删除结点后：");
        binarySortTree.infixOrder();
    }
}
// 创建二叉排序树
class BinarySortTree{
    private Node root;
    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }

    // 查到待删除的结点
    public Node serach(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找待删除节点的父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    // 编写方法

    /**
     *
     * @param node 传入的结点，当作一个二叉排序树的根结点
     * @return 返回的是以node为根结点的二叉排序树的最小结点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        // 循环查找左结点，就会找到最小值
        while (target.left!=null){
            target = target.left;
        }
        // 找到以node为根结点的最小的左子结点--> target
        // 删除最小结点
        delNode(target.value);
        return target.value;
    }
    // 删除结点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1.需要先找到待删除的结点 targetNode
            Node targetNode = serach(value);
            // 如果没有找打待删除的结点，直接返回
            if (targetNode == null){
                return;
            }
            // 如果targetNode没有父结点，也不需要继续查找待删除结点的父结点，即待删除的结点为root
            if (root.left==null && root.right==null){
                root = null;
                return;
            }
            // 2.找到待删除结点的父结点：parent
            Node parent = searchParent(value);
            // 1、如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                // 判断targetNode是父结点的左子结点还是右子结点
                if (parent.left!=null && parent.left.value == value){
                    parent.left = null;
                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }
            }
            // 2、待删除的结点有两个结点
            else if (targetNode.left!=null && targetNode.right!=null){
                // 具体思路看笔记
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;
            }
            // 3、如果待删除的结点有一个子结点
            else {
                if (targetNode.left!=null){
                    // 判断targetNode是父结点的左子结点还是右子结点
                    if (parent.left!=null && parent.left.value == value){
                        parent.left = targetNode.left;
                    }else if (parent.right!=null && parent.right.value == value){
                        parent.right = targetNode.left;
                    }
                }else if (targetNode.right!=null) {
                    // 判断targetNode是父结点的左子结点还是右子结点
                    if (parent.left != null && parent.left.value == value) {
                        parent.left = targetNode.right;
                    } else if (parent.right != null && parent.right.value == value) {
                        parent.right = targetNode.right;
                    }
                }
            }

        }
    }
}

// 创建结点
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    // 查找要删除的节点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value){
        if (value == this.value){
            // 找到
            return this;
        }else if (value < this.value){
            if (this.left==null){
                return null;
            }
            // 向左子树递归查找
            return this.left.search(value);
        }else{
            // 向右子树递归查找
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    /**
     *
     * @param value 要查找的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有则返回null
     */
    public Node searchParent(int value){
        // 如果当前节点就是待删除的结点的父结点，就返回
        if ((this.left!=null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null){
                // 向左子树递归查找
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right != null){
                // 向右子树递归查找
                return this.right.searchParent(value);
            }else {
                // 可能不满足以上条件，则没有找到父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

}
~~~

## 平衡二叉树（AVL树）

> 给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.

![1649413913386](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649413913386.png)

> 左边BST存在的问题分析:
>
> 1. 左子树全部为空，从形式上看，更像一个单链表.
> 2. 插入速度没有影响
> 3. 查询速度明显降低(因为需要依次比较), 不能发挥BST的优势，因为每次还需要比较左子树，其查询速度比
>    单链表还慢
> 4. 解决方案-平衡二叉树(AVL)

### 平衡二叉树介绍

1. <font color='red'> 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， **可以保证查询效率较高。** </font>
2. **<font color='orange'>具有以下特点：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</font>**
3. 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。

举例说明，看看下面哪些AVL树, 为什么?

![1649415283975](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649415283975.png)

#### 应用案例- 单旋转( 左旋转)

> 1. 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}
> 2. 思路分析(示意图)
> 3. 代码实现

代码实现：

~~~
package DataStructures.AVLTree;

public class AVLTreeDemo {
    public static void main(String[] args) {
        int[] arr = {4,3,6,5,7,8};
        // 创建一个AVLTree对象
        AVLTree avlTree = new AVLTree();
        // 添加结点
        for (int i=0;i<arr.length;i++){
            avlTree.add(new Node(arr[i]));
        }

        // 中序遍历
        System.out.println("中序遍历：");
        avlTree.infixOrder();

        System.out.println("在未做平衡处理前（即未旋转前）~~~");
        System.out.println("树的高度="+avlTree.getRoot().height()); // 4
        System.out.println("树的左子树的高度："+avlTree.getRoot().leftHeight()); // 1
        System.out.println("树的右子树的高度："+avlTree.getRoot().rightHeight()); // 3

        // 进行左旋转（右子树高度>左子树高度）

    }
}
// 创建AVLTree（平衡二叉树）
class AVLTree{
    private Node root;

    public Node getRoot() {
        return root;
    }


    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }

    // 查找待删除的结点
    public Node serach(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找待删除节点的父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    // 编写方法
    // 1、返回的以node为根结点的二叉排序树的最小结点的值
    // 2、删除node为根节点的二叉排序树的最小结点
    /**
     *
     * @param node 传入的结点，当作一个二叉排序树的根结点
     * @return 返回的是以node为根结点的二叉排序树的最小结点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        // 循环查找左结点，就会找到最小值
        while (target.left!=null){
            target = target.left;
        }
        // 找到以node为根结点的最小的左子结点--> target
        // 删除最小结点
        delNode(target.value);
        return target.value;
    }
    // 删除结点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1.需要先找到待删除的结点 targetNode
            Node targetNode = serach(value);
            // 如果没有找打待删除的结点，直接返回
            if (targetNode == null){
                return;
            }
            // 如果targetNode没有父结点，也不需要继续查找待删除结点的父结点，即待删除的结点为root
            if (root.left==null && root.right==null){
                root = null;
                return;
            }
            // 2.找到待删除结点的父结点：parent
            Node parent = searchParent(value);
            // 1、如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                // 判断targetNode是父结点的左子结点还是右子结点
                if (parent.left!=null && parent.left.value == value){
                    parent.left = null;
                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }
            }
            // 2、待删除的结点有两个结点
            else if (targetNode.left!=null && targetNode.right!=null){
                // 具体思路看笔记
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;
            }
            // 3、如果待删除的结点有一个子结点
            else {
                if (targetNode.left!=null){
                    if (parent!=null){
                        // 判断targetNode是父结点的左子结点还是右子结点
                        if (parent.left.value == value){
                            parent.left = targetNode.left;
                        }else if (parent.right.value == value){
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }
                }else if (targetNode.right!=null) {
                    if (parent!=null){
                        // 判断targetNode是父结点的左子结点还是右子结点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else if (parent.right.value == value) {
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }

        }
    }


}

// 结点类
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }
    // 返回左子树的高度
    public int leftHeight(){
        if (left == null){
            return 0;
        }
        return left.height();
    }
    // 返回右子树的高度
    public int rightHeight(){
        if (right == null){
            return 0;
        }
        return right.height();
    }

    // 返回以当前结点为根节点的二叉树的高度
    public int height(){
        return Math.max(left == null?0:left.height(),right == null?0:right.height()) + 1;
    }

    // 左旋转的方法
    private void leftRotate(){
        // 创建新的结点，以当前根节点的值
        Node newNode = new Node(value);
        // 把新的结点的左子树设置为当前结点的左子树
        newNode.left = left;
        // 把新结点的右子树设置成当前结点的右子树的左子树
        newNode.right = right.left;
        // 把当前结点的值替换为右子结点的值
        value = right.value;
        // 把当前结点的右子树设置为当前结点右子树的右子树
        right = right.right;
        // 把当前结点的左子结点设置为新的结点
        left = newNode;
    }

    // 查找要删除的节点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value){
        if (value == this.value){
            // 找到
            return this;
        }else if (value < this.value){
            if (this.left==null){
                return null;
            }
            // 向左子树递归查找
            return this.left.search(value);
        }else{
            // 向右子树递归查找
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    /**
     *
     * @param value 要查找的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有则返回null
     */
    public Node searchParent(int value){
        // 如果当前节点就是待删除的结点的父结点，就返回
        if ((this.left!=null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null){
                // 向左子树递归查找
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right!=null){
                // 向右子树递归查找
                return this.right.searchParent(value);
            }else {
                // 可能不满足以上条件，则没有找到父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
        // 当添加完一个节点后，若右子树的高度 - 左子树的高度 > 1，左旋转
        if (rightHeight() - leftHeight() > 1){
            // 左旋转
            leftRotate();
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

}
~~~

> 对节点A 进行 左 旋转的步骤
>
> 1. 将A 节点的 右节点 的 左节点 ，指向 A节点
> 2. 将 A节点的右节点，指向A 节点的右节点的左节点

![1649418627273](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649418627273.png)

![1649418941444](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649418941444.png)

#### 应用案例- 单旋转( 右旋转)

> 1. 要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}
> 2. 思路分析(示意图)
> 3. 代码实现

![1649419096171](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649419096171.png)

代码实现：

~~~
package DataStructures.AVLTree;

public class AVLTreeDemo {
    public static void main(String[] args) {
        //int[] arr = {4,3,6,5,7,8};
        int[] arr = {10,12,8,9,7,6};
        // 创建一个AVLTree对象
        AVLTree avlTree = new AVLTree();
        // 添加结点
        for (int i=0;i<arr.length;i++){
            avlTree.add(new Node(arr[i]));
        }

        // 中序遍历
        System.out.println("中序遍历：");
        avlTree.infixOrder();

        System.out.println("在未做平衡处理前（即未旋转前）~~~");
        System.out.println("树的高度="+avlTree.getRoot().height()); // 4
        System.out.println("树的左子树的高度："+avlTree.getRoot().leftHeight()); // 1
        System.out.println("树的右子树的高度："+avlTree.getRoot().rightHeight()); // 3
        System.out.println("当前根节点为："+avlTree.getRoot());

        // 进行左旋转（右子树高度>左子树高度）
        // 进行右旋转（左子树高度>右子树高度）
    }
}
// 创建AVLTree（平衡二叉树）
class AVLTree{
    private Node root;

    public Node getRoot() {
        return root;
    }


    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }

    // 查找待删除的结点
    public Node serach(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找待删除节点的父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    // 编写方法
    // 1、返回的以node为根结点的二叉排序树的最小结点的值
    // 2、删除node为根节点的二叉排序树的最小结点
    /**
     *
     * @param node 传入的结点，当作一个二叉排序树的根结点
     * @return 返回的是以node为根结点的二叉排序树的最小结点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        // 循环查找左结点，就会找到最小值
        while (target.left!=null){
            target = target.left;
        }
        // 找到以node为根结点的最小的左子结点--> target
        // 删除最小结点
        delNode(target.value);
        return target.value;
    }
    // 删除结点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1.需要先找到待删除的结点 targetNode
            Node targetNode = serach(value);
            // 如果没有找打待删除的结点，直接返回
            if (targetNode == null){
                return;
            }
            // 如果targetNode没有父结点，也不需要继续查找待删除结点的父结点，即待删除的结点为root
            if (root.left==null && root.right==null){
                root = null;
                return;
            }
            // 2.找到待删除结点的父结点：parent
            Node parent = searchParent(value);
            // 1、如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                // 判断targetNode是父结点的左子结点还是右子结点
                if (parent.left!=null && parent.left.value == value){
                    parent.left = null;
                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }
            }
            // 2、待删除的结点有两个结点
            else if (targetNode.left!=null && targetNode.right!=null){
                // 具体思路看笔记
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;
            }
            // 3、如果待删除的结点有一个子结点
            else {
                if (targetNode.left!=null){
                    if (parent!=null){
                        // 判断targetNode是父结点的左子结点还是右子结点
                        if (parent.left.value == value){
                            parent.left = targetNode.left;
                        }else if (parent.right.value == value){
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }
                }else if (targetNode.right!=null) {
                    if (parent!=null){
                        // 判断targetNode是父结点的左子结点还是右子结点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else if (parent.right.value == value) {
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }

        }
    }


}

// 结点类
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }
    // 返回左子树的高度
    public int leftHeight(){
        if (left == null){
            return 0;
        }
        return left.height();
    }
    // 返回右子树的高度
    public int rightHeight(){
        if (right == null){
            return 0;
        }
        return right.height();
    }

    // 返回以当前结点为根节点的二叉树的高度
    public int height(){
        return Math.max(left == null?0:left.height(),right == null?0:right.height()) + 1;
    }

    // 左旋转的方法
    private void leftRotate(){
        // 创建新的结点，以当前根节点的值
        Node newNode = new Node(value);
        // 把新的结点的左子树设置为当前结点的左子树
        newNode.left = left;
        // 把新结点的右子树设置成当前结点的右子树的左子树
        newNode.right = right.left;
        // 把当前结点的值替换为右子结点的值
        value = right.value;
        // 把当前结点的右子树设置为当前结点右子树的右子树
        right = right.right;
        // 把当前结点的左子结点设置为新的结点
        left = newNode;
    }

    // 右旋转的方法
    private void rightRotate(){
        // 创建一个新的结点，值为当前节点的值
        Node newNode = new Node(value);
        // 把新节点的右子树设置为当前结点的右子树
        newNode.right = right;
        // 把新节点的左子树设置为当前节点的左子树的左子树
        newNode.left = left.right;
        // 把当前节点的值换为左子结点的值
        value = left.value;
        // 把当前节点的左子树设置为左子树的左子树
        left = left.left;
        // 把当前节点的右子树设置为新结点
        right = newNode;
    }

    // 查找要删除的节点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value){
        if (value == this.value){
            // 找到
            return this;
        }else if (value < this.value){
            if (this.left==null){
                return null;
            }
            // 向左子树递归查找
            return this.left.search(value);
        }else{
            // 向右子树递归查找
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    /**
     *
     * @param value 要查找的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有则返回null
     */
    public Node searchParent(int value){
        // 如果当前节点就是待删除的结点的父结点，就返回
        if ((this.left!=null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null){
                // 向左子树递归查找
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right!=null){
                // 向右子树递归查找
                return this.right.searchParent(value);
            }else {
                // 可能不满足以上条件，则没有找到父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
        // 当添加完一个节点后，若右子树的高度 - 左子树的高度 > 1，左旋转
        if (rightHeight() - leftHeight() > 1){
            // 左旋转
            leftRotate();
        }
        // 当添加完一个节点后，若左子树的高度 - 右子树的高度 > 1，右旋转
        if (leftHeight() - rightHeight() > 1){
            // 右旋转
            rightRotate();
        }
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

}
~~~

#### 应用案例-双旋转

> 前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如数列
> int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树.
> int[] arr = {2,1,6,5,7,3}; // 运行原来的代码可以看到，并没有转成 AVL树

解决思路分析：

![1649419939480](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649419939480.png)

实现代码：

~~~
package DataStructures.AVLTree;

public class AVLTreeDemo {
    public static void main(String[] args) {
        //int[] arr = {4,3,6,5,7,8};
        //int[] arr = {10,12,8,9,7,6};
        int[] arr = {10,11,7,6,8,9};
        // 创建一个AVLTree对象
        AVLTree avlTree = new AVLTree();
        // 添加结点
        for (int i=0;i<arr.length;i++){
            avlTree.add(new Node(arr[i]));
        }

        // 中序遍历
        System.out.println("中序遍历：");
        avlTree.infixOrder();

        System.out.println("在未做平衡处理前（即未旋转前）~~~");
        System.out.println("树的高度="+avlTree.getRoot().height()); // 4
        System.out.println("树的左子树的高度："+avlTree.getRoot().leftHeight()); // 1
        System.out.println("树的右子树的高度："+avlTree.getRoot().rightHeight()); // 3
        System.out.println("当前根节点为："+avlTree.getRoot());
        System.out.println("根节点的左子结点为："+avlTree.getRoot().left);
        System.out.println("根节点的右子节点为："+avlTree.getRoot().right);

        // 进行左旋转（右子树高度>左子树高度）
        // 进行右旋转（左子树高度>右子树高度）
    }
}
// 创建AVLTree（平衡二叉树）
class AVLTree{
    private Node root;

    public Node getRoot() {
        return root;
    }


    // 添加节点的方法
    public void add(Node node){
        if (root==null){
            // 如果root为空，则直接让root指向node
            root=node;
        }else {
            root.add(node);
        }
    }
    // 中序遍历
    public void infixOrder(){
        if (root!=null){
            root.infixOrder();
        }else {
            System.out.println("当前二叉排序树为空，无法遍历！");
        }
    }

    // 查找待删除的结点
    public Node serach(int value){
        if (root == null){
            return null;
        }else {
            return root.search(value);
        }
    }
    // 查找待删除节点的父节点
    public Node searchParent(int value){
        if (root == null){
            return null;
        }else {
            return root.searchParent(value);
        }
    }

    // 编写方法
    // 1、返回的以node为根结点的二叉排序树的最小结点的值
    // 2、删除node为根节点的二叉排序树的最小结点
    /**
     *
     * @param node 传入的结点，当作一个二叉排序树的根结点
     * @return 返回的是以node为根结点的二叉排序树的最小结点的值
     */
    public int delRightTreeMin(Node node){
        Node target = node;
        // 循环查找左结点，就会找到最小值
        while (target.left!=null){
            target = target.left;
        }
        // 找到以node为根结点的最小的左子结点--> target
        // 删除最小结点
        delNode(target.value);
        return target.value;
    }
    // 删除结点
    public void delNode(int value){
        if (root == null){
            return;
        }else {
            // 1.需要先找到待删除的结点 targetNode
            Node targetNode = serach(value);
            // 如果没有找打待删除的结点，直接返回
            if (targetNode == null){
                return;
            }
            // 如果targetNode没有父结点，也不需要继续查找待删除结点的父结点，即待删除的结点为root
            if (root.left==null && root.right==null){
                root = null;
                return;
            }
            // 2.找到待删除结点的父结点：parent
            Node parent = searchParent(value);
            // 1、如果要删除的结点是叶子节点
            if (targetNode.left == null && targetNode.right == null){
                // 判断targetNode是父结点的左子结点还是右子结点
                if (parent.left!=null && parent.left.value == value){
                    parent.left = null;
                }else if (parent.right!=null && parent.right.value == value){
                    parent.right = null;
                }
            }
            // 2、待删除的结点有两个结点
            else if (targetNode.left!=null && targetNode.right!=null){
                // 具体思路看笔记
                int minVal = delRightTreeMin(targetNode.right);
                targetNode.value = minVal;
            }
            // 3、如果待删除的结点有一个子结点
            else {
                if (targetNode.left!=null){
                    if (parent!=null){
                        // 判断targetNode是父结点的左子结点还是右子结点
                        if (parent.left.value == value){
                            parent.left = targetNode.left;
                        }else if (parent.right.value == value){
                            parent.right = targetNode.left;
                        }
                    }else {
                        root = targetNode.left;
                    }
                }else if (targetNode.right!=null) {
                    if (parent!=null){
                        // 判断targetNode是父结点的左子结点还是右子结点
                        if (parent.left.value == value) {
                            parent.left = targetNode.right;
                        } else if (parent.right.value == value) {
                            parent.right = targetNode.right;
                        }
                    }else {
                        root = targetNode.right;
                    }
                }
            }

        }
    }


}

// 结点类
class Node{
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }
    // 返回左子树的高度
    public int leftHeight(){
        if (left == null){
            return 0;
        }
        return left.height();
    }
    // 返回右子树的高度
    public int rightHeight(){
        if (right == null){
            return 0;
        }
        return right.height();
    }

    // 返回以当前结点为根节点的二叉树的高度
    public int height(){
        return Math.max(left == null?0:left.height(),right == null?0:right.height()) + 1;
    }

    // 左旋转的方法
    private void leftRotate(){
        // 创建新的结点，以当前根节点的值
        Node newNode = new Node(value);
        // 把新的结点的左子树设置为当前结点的左子树
        newNode.left = left;
        // 把新结点的右子树设置成当前结点的右子树的左子树
        newNode.right = right.left;
        // 把当前结点的值替换为右子结点的值
        value = right.value;
        // 把当前结点的右子树设置为当前结点右子树的右子树
        right = right.right;
        // 把当前结点的左子结点设置为新的结点
        left = newNode;
    }

    // 右旋转的方法
    private void rightRotate(){
        // 创建一个新的结点，值为当前节点的值
        Node newNode = new Node(value);
        // 把新节点的右子树设置为当前结点的右子树
        newNode.right = right;
        // 把新节点的左子树设置为当前节点的左子树的左子树
        newNode.left = left.right;
        // 把当前节点的值换为左子结点的值
        value = left.value;
        // 把当前节点的左子树设置为左子树的左子树
        left = left.left;
        // 把当前节点的右子树设置为新结点
        right = newNode;
    }

    // 查找要删除的节点
    /**
     *
     * @param value 希望删除的结点的值
     * @return 如果找到返回该结点，否则返回null
     */
    public Node search(int value){
        if (value == this.value){
            // 找到
            return this;
        }else if (value < this.value){
            if (this.left==null){
                return null;
            }
            // 向左子树递归查找
            return this.left.search(value);
        }else{
            // 向右子树递归查找
            if (this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    // 查找要删除节点的父节点
    /**
     *
     * @param value 要查找的结点的值
     * @return 返回的是要删除的结点的父结点，如果没有则返回null
     */
    public Node searchParent(int value){
        // 如果当前节点就是待删除的结点的父结点，就返回
        if ((this.left!=null && this.left.value == value) || (this.right != null && this.right.value == value)){
            return this;
        }else {
            // 如果查找的值小于当前结点的值，并且当前结点的左子结点不为空
            if (value < this.value && this.left != null){
                // 向左子树递归查找
                return this.left.searchParent(value);
            }else if (value >= this.value && this.right!=null){
                // 向右子树递归查找
                return this.right.searchParent(value);
            }else {
                // 可能不满足以上条件，则没有找到父节点
                return null;
            }
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }

    // 添加结点
    // 递归的形式，需要满足二叉排序树的要求
    public void add(Node node){
        if (node==null){
            return;
        }
        // 判断传入的节点的值和当前子树的根节点的值的大小关系
        if (node.value<this.value){
            if (this.left==null){
                // 如果当前节点左子结点为空，直接挂在左子结点
                this.left=node;
            }else {
                // 递归向左子树添加
                this.left.add(node);
            }
        }else{ // 添加的结点的值大于当前结点的值
            if (this.right==null){
                this.right = node;
            }else {
                // 递归向右子树添加
                this.right.add(node);
            }
        }
        // 当添加完一个节点后，若右子树的高度 - 左子树的高度 > 1，左旋转
        if (rightHeight() - leftHeight() > 1){
            // 如果它的右子树的左子树的高度大于它的右子树的高度
            if (right!=null && right.leftHeight() > right.rightHeight()){
                // 先对当前结点的右子树进行右旋转
                right.rightRotate();
                // 再对当前节点进行左旋转
                leftRotate();
            }else {
                // 否则直接进行左旋转即可
                leftRotate();
            }
            // 没必要在平衡继续进行判断！！！
            return;
        }
        // 当添加完一个节点后，若左子树的高度 - 右子树的高度 > 1，右旋转
        if (leftHeight() - rightHeight() > 1){
            // 如果它的左子树的右子树的高度大于它的左子树的高度
            if (left != null && left.rightHeight() > left.leftHeight()){
                // 先对当前节点的左子树进行左旋转
                left.leftRotate();
                // 再对当前节点进行右旋转
                rightRotate();
            }else {
                // 直接进行右旋转即可
                rightRotate();
            }
        }
        return;
    }

    // 中序遍历
    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

}
~~~

# 多路查找树

## 二叉树与B树

二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树：

![1649420836163](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649420836163.png)

> 1. 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多( 比如1
>    亿) ， 就存在如下问题:
> 2. 问题1 ：在构建二叉树时，需要多次进行i/o 操作( 海量数据存在数据库或文件中) ，节点海量，构建二
>    叉树时，速度有影响
> 3. 问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度

### 多叉树

> 1. <font color='red'>在二叉树中，每个节点有数据项，最多有两个子节点。如果 **允许每个节点可以有更多的数据项和更多的子节点，就是 多叉树（multiway tree） ）**</font>
> 2. 后面我们讲解的2-3 树，2-3-4 树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化。
> 3. 举例说明( 下面2-3 树就是一颗多叉树）

![1649421502133](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649421502133.png)

### B树的基本介绍

**B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。**

![1649421535657](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649421535657.png)

> 1. 如图B 树通过重新组织节点， 降低了树的高度.
> 2. 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k) ，这样每个节点只需要一次I/O 就可以完全载入
> 3. 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中

### 2-3树基本介绍

> <font color='red'>2-3树是最简单的B树结构, 具有如下特点:</font>
>
> - **<font color='orange'>2-3 树的所有叶子节点都在同一层.( 只要是B 树都满足这个条件)</font>**
> - <font color='red'>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</font>
> - <font color='red'>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</font>
> - <font color='blue'>2-3树是由二节点和三节点构成的树。</font>

#### 2-3应用案例

> 将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成2-3树，并保证数据插入的大小顺序。(演示一下构建2-3树的过程.)

> 插入规则 插入规则:
>
> 1. 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)
> 2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
> 3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
> 4. <font color='green'>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。</font>
> 5. 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则

![1649421974193](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649421974193.png)

#### 其他说明

除了23树，还有234树等，概念和23树类似，也是一种B树，如图：

![1649423218953](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649423218953.png)

### B树的介绍

> **<font color='blue'>B-tree 树即B 树，B即Balanced，平衡的意思。</font>**有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree 就是指的B 树。

![1649423299596](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649423299596.png)

#### B树的说明：

> 1. <font color='blue'>**B树的阶：节点的最多子节点个数。**</font>比如2-3树的阶是3，2-3-4树的阶是4
> 2. <font color='red'>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</font>
> 3. <font color='green'>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</font>
> 4. **搜索有可能在非叶子结点结束**
> 5. 其搜索性能等价于在关键字全集内做一次二分查找

### B+树的介绍

> **B+树是B树的变体，也是一种多路搜索树。**
>
> **<font color='red'>特点：所有的数据都存放在叶子结点，数据只在叶子节点出现</font>**

![1649423453261](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649423453261.png)

#### B+树的说明：

> 1. B+树的搜索与B树也基本相同，**区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找**
> 2. 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。
> 3. <font color='red'>不可能在非叶子结点命中</font>
> 4. **<font color='blue'>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</font>**
> 5. 更适合文件索引系统
> 6. B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.

### B*树的介绍

> <font color='green'>**B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。**</font>

![1649423758849](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649423758849.png)

#### B*树的说明：

> 1. **B*树定义了非叶子结点关键字个数至少为(2/3)×M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。**
> 2. 从第1个特点我们可以看出<font color='red'>，B*树分配新结点的概率比B+树要低，空间使用率更高</font>



# 图

**学习图的原因：**

> - 线性表局限于一个直接前驱和一个直接后继的关系
> - 树也只能有一个直接前驱也就是父节点
> - 当我们<font color='red'>需要表示多对多的关系时，这里我们就用到了图</font>

### 图的基本介绍

> **<font color='red'>图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。</font>**

![1649423909635](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649423909635.png)

### 图的常用概念

> 1. 顶点(vertex)
> 2. 边(edge)
> 3. 路径
> 4. 无向图
> 5. 有向图
> 6. 带权图

**无向图举例：**

![1649423976837](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649423976837.png)

#### 无向图

> <font color='green'>无向图： 顶点之间的连接没有方向，</font>比如A-B，即可以是 A-> B 也可以 B->A。
>
> 路径：比如从 D -> C 的路径有
>
> 1. D->B->C
> 2. D->A->B->C

#### 有向图

> <font color='red'>有向图： 顶点之间的连接有方向</font>，比如A-B，只能是 A-> B 不能是 B->A .

![1649424057642](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424057642.png)

#### 带权图

> **<font color='blue'>带权图：这种边带权值的图也叫网.</font>**

![1649424118667](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424118667.png)

### 图的表示方式

> 图的表示方式有两种：<font color='red'>二维数组表示（邻接矩阵）、链表表示（邻接表）</font>

#### 1、邻接矩阵

> <font color='purple'>**邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。**</font>

![1649424232268](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424232268.png)

#### 2、邻接表

> 1. <font color='red'>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.</font>
> 2. <font color='green'>邻接表的实现只关心存在的边，不关心不存在的边。</font>因此没有空间浪费，<font color='blue'>**邻接表由数组+链表组成**</font>

![1649424328146](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424328146.png)

说明：

> - 标号为0的结点的相关联的结点为 1 2 3 4
> - 标号为1的结点的相关联结点为0 4，
> - 标号为2的结点相关联的结点为 0 4 5

### 图的快速入门案例

1、图示

![1649424422114](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424422114.png)

2、思路分析 

> (1) 存储顶点String 使用 ArrayList 
>
> (2) 保存矩阵 int[][] edges

3、代码实现

~~~
package DataStructures.Graph;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {
    // 存储顶点的集合
    private ArrayList<String> vertexList;
    // 存储图对应的邻接矩阵
    private int[][] edges;
    // 表示边的数目
    private int numOfEdges;

    public static void main(String[] args) {
        // 测试
        // 结点的个数
        int n = 5;

        String[] Vertexs = {"A","B","C","D","E"};
        // 创建图对象
        Graph graph = new Graph(n);
        // 循环的添加顶点
        for (String vertex:Vertexs){
            graph.insertVertex(vertex);
        }
        // 添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);
        // 显示图
        graph.showGraph();
    }

    // 构造器

    /**
     *
     * @param n 顶点的个数
     */
    public Graph(int n) {
        // 初始化矩阵和ArrayList
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
    }
    // 返回结点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }

    // 得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    // 返回结点i(下标)对应的数据
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    // 返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    // 显示图对应的矩阵
    public void showGraph(){
        for (int[] link: edges){
            System.out.println(Arrays.toString(link));
        }
    }

    // 插入结点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    // 添加边
    /**
     *
     * @param v1 表示第一个顶点的下标即为第几个顶点
     * @param v2 表示第二个顶点对应的下标
     * @param weight 表示顶点的权值
     */
    public void insertEdge(int v1,int v2,int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}
~~~

**运行截图：**

![1649486643083](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649486643083.png)

## 图的深度优先遍历（DFS）

### 图的遍历

> <font color='blue'>所谓图的遍历，即是对结点的访问。</font>一个图有那么多个结点，如何遍历这些结点，需要特定策略
>
> 一般有两种访问策略：<font color='red'>(1)深度优先遍历 (2)广度优先遍历</font>

### 基本思想

> **<font color='red'>图的深度优先搜索(Depth First Search)</font>** 
>
> 1. <font color='blue'>深度优先遍历</font>，**从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。**
> 2. 我们可以看到，这样的访问策略是**优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。**
> 3. 显然，<font color='red'> 深度优先搜索是一个递归的过程 </font>font>

### 算法步骤

> 1. 访问初始结点v，并标记结点v为已访问。
> 2. 查找结点v的第一个邻接结点w。
> 3. 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。
> 4. 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。
> 5. 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。

![1649424886187](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424886187.png)

#### 案例

![1649424909369](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424909369.png)

2、思路分析

![1649424923551](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649424923551.png)

3、代码实现

~~~
package DataStructures.Graph;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {
    // 存储顶点的集合
    private ArrayList<String> vertexList;
    // 存储图对应的邻接矩阵
    private int[][] edges;
    // 表示边的数目
    private int numOfEdges;
    // 定义数组，记录某个顶点是否被访问过
    private boolean[] isVisited;

    public static void main(String[] args) {
        // 测试
        // 结点的个数
        int n = 5;

        String[] Vertexs = {"A","B","C","D","E"};
        // 创建图对象
        Graph graph = new Graph(n);
        // 循环的添加顶点
        for (String vertex:Vertexs){
            graph.insertVertex(vertex);
        }
        // 添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);
        // 显示图
        graph.showGraph();

        // 测试深度遍历图
        graph.DepthFirstSearch();
    }

    // 构造器

    /**
     *
     * @param n 顶点的个数
     */
    public Graph(int n) {
        // 初始化矩阵和ArrayList
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
        isVisited = new boolean[n];
    }
    // 得到第一个邻接结点的下标

    /**
     *
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     */
    public int getFirstNeighbor(int index){
        for (int j=0;j<vertexList.size();j++){
            if (edges[index][j]>0){
                return j;
            }
        }
        return -1;
    }
    // 根据前一个邻接结点的下标来获取下一个邻接结点
    public int getNextNeighbor(int v1,int v2){
        for (int j = v2+1;j<vertexList.size();j++){
            if (edges[v1][j]>0){
                return j;
            }
        }
        return -1;
    }

    // 深度优先遍历图
    public void DepthFirstSearch(boolean[] isVisited,int i){
        // 首先我们访问该结点并输出
        System.out.print(getValueByIndex(i) + "->");
        // 将访问过的结点设置为已访问
        isVisited[i] = true;
        // 查找结点i的第一个邻接结点w
        int w = getFirstNeighbor(i);
        while ( w!=-1){
            // 说明有
            if (!isVisited[w]){
                DepthFirstSearch(isVisited,w);
            }
            // w存在，但已经被访问过
            w = getNextNeighbor(i,w);
        }
    }
    // 对DepthFirstSearch进行重载，遍历所有的结点，并进行DepthFirstSearch
    public void DepthFirstSearch(){
        // 遍历所有的结点，进行DepthFirstSearch
        for (int i=0;i<getNumOfEdges();i++){
            if (!isVisited[i]){
                DepthFirstSearch(isVisited,i);
            }
        }
    }
    // 返回结点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }

    // 得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    // 返回结点i(下标)对应的数据
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    // 返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    // 显示图对应的矩阵
    public void showGraph(){
        for (int[] link: edges){
            System.out.println(Arrays.toString(link));
        }
    }

    // 插入结点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    // 添加边
    /**
     *
     * @param v1 表示第一个顶点的下标即为第几个顶点
     * @param v2 表示第二个顶点对应的下标
     * @param weight 表示顶点的权值
     */
    public void insertEdge(int v1,int v2,int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}
~~~

## 图的广度优先遍历

### 基本思想

> 图的广度优先搜索(Broad First Search) 。
>
> 1. **类似于一个分层搜索的过程，<font color='red'>广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</font>**

### 算法步骤

> 1. 访问初始结点v并标记结点v为已访问。
> 2. 结点v入队列
> 3. 当队列非空时，继续执行，否则算法结束。
> 4. 出队列，取得队头结点u。
> 5. 查找结点u的第一个邻接结点w。
> 6. 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤：
>    6.1 若结点w尚未被访问，则访问结点w并标记为已访问。
>    6.2 结点w入队列
>    6.3 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。

#### 案例

![1649425084926](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649425084926.png)

代码实现：

~~~
package DataStructures.Graph;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;

public class Graph {
    // 存储顶点的集合
    private ArrayList<String> vertexList;
    // 存储图对应的邻接矩阵
    private int[][] edges;
    // 表示边的数目
    private int numOfEdges;
    // 定义数组，记录某个顶点是否被访问过
    private boolean[] isVisited;

    public static void main(String[] args) {
        // 测试
        // 结点的个数
        int n = 5;

        String[] Vertexs = {"A","B","C","D","E"};
        // 创建图对象
        Graph graph = new Graph(n);
        // 循环的添加顶点
        for (String vertex:Vertexs){
            graph.insertVertex(vertex);
        }
        // 添加边
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);
        // 显示图
        graph.showGraph();

        // 测试深度遍历图
        //graph.DepthFirstSearch();
        System.out.println();

        // 测试广度优先遍历
        graph.bfs();
    }

    // 构造器

    /**
     *
     * @param n 顶点的个数
     */
    public Graph(int n) {
        // 初始化矩阵和ArrayList
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;
        isVisited = new boolean[n];
    }
    // 得到第一个邻接结点的下标
    /**
     *
     * @param index
     * @return 如果存在就返回对应的下标，否则返回-1
     */
    public int getFirstNeighbor(int index){
        for (int j=0;j<vertexList.size();j++){
            if (edges[index][j]>0){
                return j;
            }
        }
        return -1;
    }
    // 根据前一个邻接结点的下标来获取下一个邻接结点
    public int getNextNeighbor(int v1,int v2){
        for (int j = v2+1;j<vertexList.size();j++){
            if (edges[v1][j]>0){
                return j;
            }
        }
        return -1;
    }

    // 深度优先遍历图
    public void DepthFirstSearch(boolean[] isVisited,int i){
        // 首先我们访问该结点并输出
        System.out.print(getValueByIndex(i) + "->");
        // 将访问过的结点设置为已访问
        isVisited[i] = true;
        // 查找结点i的第一个邻接结点w
        int w = getFirstNeighbor(i);
        while ( w!=-1){
            // 说明有
            if (!isVisited[w]){
                DepthFirstSearch(isVisited,w);
            }
            // w存在，但已经被访问过
            w = getNextNeighbor(i,w);
        }
    }

    // 对一个结点进行广度优先遍历
    private void bfs(boolean[] isVisited,int i){
        // 表示队列头结点对应下标
        int u;
        // 邻接结点w
        int w;
        // 队列，结点访问顺序的记录
        LinkedList queue = new LinkedList();
        // 访问结点，输出结点信息
        System.out.print("广度优先遍历："+getValueByIndex(i)+"->");
        // 标记为已访问
        isVisited[i] = true;
        // 将结点加入队列
        queue.addLast(i);

        while (!queue.isEmpty()){
            // 取出队列的头结点下标
            u = (Integer)queue.removeFirst();
            // 得到第一个邻接点的下标
            w = getFirstNeighbor(u);
            while ( w!= -1){
                // 找到
                // 是否访问过
                if (!isVisited[w]){
                    System.out.print(getValueByIndex(w)+"->");
                    // 标记已访问
                    isVisited[w] = true;
                    // 入队列
                    queue.addLast(w);
                }
                // 已经访问过
                // 以u为前驱点，找w后面的下一个邻接点
                w = getNextNeighbor(u,w); // 体现出广度优先
            }
        }
    }
    // 重载bfs，遍历所有结点，进行广度优先遍历
    public void bfs(){
        for (int i=0;i<getNumOfVertex();i++){
            if (!isVisited[i]){
                bfs(isVisited,i);
            }
        }
    }
    // 对DepthFirstSearch进行重载，遍历所有的结点，并进行DepthFirstSearch
    public void DepthFirstSearch(){
        // 遍历所有的结点，进行DepthFirstSearch
        for (int i=0;i<getNumOfVertex();i++){
            if (!isVisited[i]){
                DepthFirstSearch(isVisited,i);
            }
        }
    }
    // 返回结点的个数
    public int getNumOfVertex(){
        return vertexList.size();
    }

    // 得到边的数目
    public int getNumOfEdges(){
        return numOfEdges;
    }
    // 返回结点i(下标)对应的数据
    public String getValueByIndex(int i){
        return vertexList.get(i);
    }
    // 返回v1和v2的权值
    public int getWeight(int v1,int v2){
        return edges[v1][v2];
    }
    // 显示图对应的矩阵
    public void showGraph(){
        for (int[] link: edges){
            System.out.println(Arrays.toString(link));
        }
    }

    // 插入结点
    public void insertVertex(String vertex){
        vertexList.add(vertex);
    }

    // 添加边
    /**
     *
     * @param v1 表示第一个顶点的下标即为第几个顶点
     * @param v2 表示第二个顶点对应的下标
     * @param weight 表示顶点的权值
     */
    public void insertEdge(int v1,int v2,int weight){
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }

}
~~~

## 图的深度优先 图的深度优先VS 广度优先

![1649489390033](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649489390033.png)

# 常用10种算法

## 1、二分查找算法( 非递归)

> 1. <font color='red'>二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找</font>
> 2. 二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置 最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 < 100 < 2^7)

数组 {1,3, 8, 10, 11, 67, 100}，编程实现二分查找， 要求使用非递归的方式完成.

#### 思路分析

> mid = (left + right) / 2;
>
> 如果target小于arr[mid]，则right = mid - 1，向左边查找；
>
> 如果target大于arr[mid]，则left = mid + 1，向右边查找。

#### 代码实现：

~~~
package Algorithm.binarysearchnorecursion;

public class BinarySearchDemo {
    public static void main(String[] args) {
        int[] arr = {1,3, 8, 10, 11, 67, 100};
        for (int i:arr){
            System.out.print(i + " ");
        }
        // 测试二分查找的非递归算法实现
        int index = binarySearch(arr,1);
        System.out.println();
        System.out.println("非递归二分查找结果为："+index);

    }
    // 二分查找的非递归实现！！！！！！！
    /**
     *
     * @param arr 待查找的数组，arr是升序排列
     * @param target 需要查找的数
     * @return 返回对应的下标，-1表示没有找到
     */
    public static int binarySearch(int[] arr,int target){
        int left = 0;
        int right = arr.length-1;
        while (left <= right){
            int mid = (left + right) / 2;
            if (arr[mid] == target){
                return mid;
            }else if (target < arr[mid]){
                // 需要向左边查找
                right = mid - 1;
            }else {
                // 需要向右边查找
                left = mid + 1;
            }
        }
        return -1;
    }
}
~~~

## 2、分治算法

> **<font color='red'>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</font>**这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

#### 分治算法可以求解的问题

> 1. 二分搜索
> 2. 大整数乘法
> 3. 棋盘覆盖
> 4. 合并排序
> 5. 快速排序
> 6. 线性时间选择
> 7. 最接近点对问题
> 8. 循环赛日程表
> 9. 汉诺塔

### 分治算法的基本步骤

> **分治法在每一层递归上都有三个步骤：**
>
> 1. <font color='red'>分解</font>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
> 2. <font color='red'>解决</font>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
> 3. <font color='red'>合并</font>：将各个子问题的解合并为原问题的解。

### 分治算法设计模式

分治(Divide-and-Conquer(P))算法设计模式如下：

> if |P|≤n0
> 	then return(ADHOC(P))
> //将P分解为较小的子问题 P1 ,P2 ,…,Pk
> for i←1 to k
>
> do yi ← Divide-and-Conquer(Pi) 递归解决Pi
>
> T ← MERGE(y1,y2,…,yk) 合并子问题
>
> return(T)

<font color='red'>其中|P|表示问题P的规模；</font><font color='blue'>n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。</font>**ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。**因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。<font color='orange'>算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</font>

### 分治算法最佳实践-汉诺塔

#### 思路分析

> 如果是有一个盘， A->C
>
> 如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1、最下边的盘     2、上面的盘
>
> 1. 先把最上面的盘 A->B
> 2. 把最下边的盘 A->C
> 3. 把B塔的所有盘 从 B->C

![1649492988092](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649492988092.png)

#### 代码实现：

~~~
package Algorithm.divideConquer;

public class Hanoitower {
    public static void main(String[] args) {
        hanoitower(5,'A','B','C');
    }

    // 汉诺塔问题实现代码
    // 使用分治算法解决
    public static void hanoitower(int num,char a,char b,char c){
        // 如果只有一个盘
        if (num == 1){
            System.out.println("第1个盘从 "+a+"->"+c);
        }else {
            // 如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1、最下边的盘 2、最上面所有的盘
            // 1、先把最上面的盘 A->B，移动过程使用到C
            hanoitower(num - 1, a, c, b);
            // 2、把最下面的盘移动到A-C
            System.out.println("第"+num+"个盘从 " + a + "->" + c);
            // 3、把B盘的所有移动到C B->C，移动过程使用到A盘
            hanoitower(num-1, b, a, c);
        }
    }
}
~~~

演示截图：

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649494505953.png" alt="1649494505953" style="zoom:50%;" />

## 3、动态规划算法

#### 应用场景-背包问题

背包问题：有一个背包，容量为4磅 ， 现有如下物品

![1649494566986](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649494566986.png)

> 1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出
> 2. 要求装入的物品不能重复

### 动态规划算法介绍

1. <font color='red'>**动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法**</font>
2. <font color='blue'>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</font>
3. 与分治算法不同的是，<font color='green'>**适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。**</font> ( <font color='blue'>**即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解**</font> )
4. <font color='orange'>动态规划可以通过填表的方式来逐步推进，得到最优解。</font>

> 动态规划算法的基本思想与分治法类似，也是**将待求解的问题分解为若干个子问题（阶段），**按顺序求解子阶段，<font color='red'>前一子问题的解，为后一子问题的求解提供了有用的信息。</font>在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

#### 背包问题思路分析

1. 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用 )
2. 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。

### 1、动态规划算法最佳实践-背包问题

> 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。**即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。**再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：
>
> 1. <font color='red'>v[i] [0]=v[0] [j]=0; //表示 填入表 第一行和第一列是0</font>
> 2. 当w[i]> j 时：v[i] [j]=v[i-1] [j] // **当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略**
> 3. 当j>=w[i]时： v[i] [j]=max{v[i-1] [j], v[i]+v[i-1] [j-w[i]]}

> // 当准备加入的新增的商品的容量小于等于当前背包的容量
> // 装入的方式：
>
> - v[i-1] [j]： 就是上一个单元格的装入的最大值
> - v[i] ：表示当前商品的价值
> - v[i-1] [j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值
> - 当j>=w[i]时： v[i] [j]=max{v[i-1] [j], v[i]+v[i-1] [j-w[i]]} 

#### 思路图解：

![1649495375163](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649495375163.png)

#### 代码实现：

~~~
package Algorithm.dynamic;

public class BagProblem {
    public static void main(String[] args) {
        // 物品的重量
        int[] w = {1,4,3};
        // 物品的价值
        int[] val = {1500,3000,2000};
        // 背包的容量
        int m = 4;
        // 物品的个数
        int n = val.length;

        // 为了记录放入商品的情况，定义一个二维数组
        int[][] path = new int[n+1][m+1];

        // 创建二维数组表示
        // v[i][j] 表示前i个物品中能够装入容量为j的背包的最大价值
        int[][] v = new int[n+1][m+1];

        // 初始化第一行第一列
        for (int i=0;i<val.length;i++){
            // 第一列
            v[i][0] = 0;
        }
        for (int i=0;i<v[0].length;i++){
            // 第一行
            v[0][i] = 0;
        }
        // 动态规划处理
        for (int i=1;i<v.length;i++){ // 不处理第一行
            for (int j=1;j<v[0].length;j++){ // 不处理第一列
                if (w[i-1] > j){
                    v[i][j] = v[i-1][j];
                }else {
                    // 说明：因为处理的时候没有处理第一行和第一列，所以i、j都是从1开始的，但是val、w数组中应该从下标为0的元素开始
                    //v[i][j] = Math.max(v[i-1][j],val[i-1]+v[i-1][j-w[i-1]]);
                    // 为了记录商品存放到背包的情况，不能简单直接的使用公式，需要进行判断
                    if (v[i-1][j] < val[i-1]+v[i-1][j-w[i-1]]){
                        v[i][j] = val[i-1]+v[i-1][j-w[i-1]];
                        // 记录当前情况(最优的)
                        path[i][j] = 1;
                    }else {
                        v[i][j] = v[i-1][j];
                    }
                }
            }
        }

        // 遍历二维数组
        for (int[] k:v){
            for (int i:k){
                System.out.print(i + "  ");
            }
            System.out.println();
        }
        System.out.println("===================");
        // 输出最后放入的哪些商品
        // 遍历path
        // 这样输出会把所有商品的放入情况都得到，其实只需要最后的放入
        //for (int i=0;i<path.length;i++){
        //    for (int j=0;j<path.length;j++){
        //        if (path[i][j] == 1){
        //            System.out.printf("第%d个商品放入到背包\n",i);
        //        }
        //    }
        //}

        int i = path.length-1;
        int j = path[0].length-1;
        while (i > 0 && j > 0){
            // 从path数组的最后开始找
            if (path[i][j] == 1){
                System.out.printf("第%d个商品放入到背包\n",i);
                j -= w[i - 1]; // w[i-1]
            }
            i--;
        }
    }
}
~~~

运行截图：

![1649505632246](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649505632246.png)

### 2、经典的数字三角形问题

 ![img](https://img-blog.csdn.net/20150811133448624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 

在上面的数字三角形中寻找一条从顶部到底边的路径，**使得路径上所经过的数字之和最大**。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。

三角形的行数大于1小于等于100，数字为 0 - 99 

 ![输入格式](https://img-blog.csdn.net/20181011214621425?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FpbGFvamll/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 



## 4、KMP算法

### 应用场景-字符串匹配问题

> 字符串匹配问题：
>
> 1. 有一个字符串 str1= ""硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好""，和一个子串 str2="尚硅谷你尚硅你"
> 2. 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置，如果没有，则返回-1

### 1、暴力匹配算法

如果用暴力匹配的思路，并假设现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:

1. 如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符
2. 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i回溯，j 被置为0。
3. 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。(不可行!)
4. 暴力匹配算法实现

#### 代码实现：

~~~
package Algorithm.KMP;

public class ViolenceMatch {
    public static void main(String[] args) {
        // 测试暴力匹配算法
        String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
        String str2 = "尚硅谷你尚硅你";
        int index = violenceMatch(str1,str2);
        System.out.println("index = "+index);
    }

    // 暴力匹配算法实现
    public static int violenceMatch(String str1,String str2){
        char[] s1 = str1.toCharArray();
        char[] s2 = str2.toCharArray();

        int l1 = s1.length;
        int l2 = s2.length;

        // i索引指向s1
        int i = 0;
        // j索引指向s2
        int j = 0;
        while (i < l1 && j < l2){ // 保证匹配时不越界
            if (s1[i] == s2[j]){ // 匹配成功OK
                i++;
                j++;
            }else { // 没有匹配成功
                // 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i回溯，j 被置为0。
                i = i - (j -1);
                j = 0;
            }
        }
        // 判断是否匹配成功
        if (j == l2){
            return i-j;
        }else {
            return -1;
        }
    }
}
~~~

**暴力匹配算法性能很低**

### 2、KMP算法

> 1. KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法
> 2. Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法.
> 3. **KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间**

#### KMP算法的改进

> KMP算法的改进在于：<font color='red'>每当从某个起始位置开始一趟比较后，在匹配过程中出现失配，不回溯i，而是利用已经得到的部分匹配结果，将一种假想的位置定位“指针”在模式上向右滑动尽可能远的一段距离到某个位置后，继续按规则进行下一次的比较。 </font>

#### 部分匹配值

> 前缀：指除最后一个字符外，字符串的所有头部字串。
>
> 后缀：指除第一个字符外，字符串的所有尾部子串。
>
> 部分匹配值：为字符串的前缀和后缀的最长相等前后缀长度。 

![1649763360561](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649763360561.png)

### 3、KMP算法流程

> 规定i是主串S的下标，j是模式T的下标。现在假设现在主串S匹配到 i 位置，模式串T匹配到 j 位置。
>
> 1. 如果j = -1，则i++，j++，继续匹配下一个字符；
> 2. 如果S[i] = T[j]，则i++，j++，继续匹配下一个字符；
> 3. 如果j != -1，且S[i] != P[j]，则 i 不变，j = next[j]。此举意味着失配时，接下来模式串T要相对于主串S向右移动j - next [j] 位。

### 4、KMP 算法最佳应用- 字符串匹配问题

> 字符串匹配问题：：
>
> 1. 有一个字符串 str1= "BBC ABCDAB ABCDABCDABDE"，和一个子串str2="ABCDABD"
> 2. 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1
> 3. 要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法.

#### 思路分析：

![1649507538134](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649507538134.png)

![1649507574440](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649507574440.png)

![1649507749587](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649507749587.png)

![1649507920355](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649507920355.png)

![1649507935338](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649507935338.png)

#### 代码实现：

~~~
package Algorithm.KMP;

import java.util.Arrays;

public class KMPAlgorithm {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";

        int[] next = kmpNext("ABCDABD");
        System.out.println(Arrays.toString(next));

        int index = kmpSearch(str1,str2,next);
        System.out.println("index = "+index);
    }
    // KMP搜索算法
    /**
     *
     * @param str1 源字符串
     * @param str2 子串
     * @param next 子串对应的部分匹配表
     * @return 如果是-1则未匹配到，否则返回匹配到的第一个字符的位置
     */
    public static int kmpSearch(String str1,String str2,int[] next){
        // 遍历
        for (int i=0, j=0; i<str1.length();i++){
            // 需要处理 str1.charAt(i)!=str2.charAt(j)，调整j的大小
            // KMP算法的核心点
            while (j > 0 && str1.charAt(i)!=str2.charAt(j)){
                j = next[j-1];
            }
            if (str1.charAt(i)==str2.charAt(j)){
                j++;
            }
            if (j==str2.length()){ // 找到了
                return i-j+1;
            }
        }
        return -1;
    }

    // 获取到一个字符串（子串）的部分匹配值
    public static int[] kmpNext(String dest){
        // 创建一个数组next，保存部分匹配值
        int[] next = new int[dest.length()];
        // 如果dest的长度为1，部分匹配值一定为0
        next[0] = 0;
        for (int i=1,j=0;i<dest.length();hjhh     i++){
            // 当dest.charAt(i) != dest.charAt(j)时，需要从next[j-1]获取新的j
            // 直到发现有dest.charAt(i) == dest.charAt(j)时退出
            // KMP算法的核心点
            while (j > 0 && dest.charAt(i) != dest.charAt(j)){
                j = next[j-1];
            }
            // 当dest.charAt(i) == dest.charAt(j)时，部分匹配值就+1
            if (dest.charAt(i) == dest.charAt(j)){
                j++;
            }
            next[i] = j;
        }
        return next;
    }
}
~~~

运行截图：

![1649512138169](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649512138169.png)

## 5、贪心算法

#### 应用场景-集合覆盖问题

假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号

![1649508753516](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649508753516.png)

### 1、贪心算法介绍

> 1. <font color='red'>**贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法**</font>
> 2. 贪婪算法所得到的结果 不一定是最优的结果( 有时候会是最优解)，但是都是相对近似(接近)最优解的结果

### 2、贪心算法最佳应用-集合覆盖

![1649508829510](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649508829510.png)

#### 思路分析：

> 如何找出覆盖所有地区的广播台的集合呢，使用穷举法实现,列出每个可能的广播台的集合，这被称为幂集。假设总的有n个广播台，则广播台的组合总共有2ⁿ -1 个,假设每秒可以计算10个子集， 如图：

![1649508860681](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649508860681.png)

使用贪婪算法，效率高：

目前并没有算法可以快速计算得到准备的值， **使用贪婪算法，则可以得到非常接近的解，并且效率高。**选择策略上，因为需要覆盖全部地区的最小集合:

1. 遍历所有的广播电台, **找到一个覆盖了<font color='red'>最多未覆盖</font>的地区的电台**(此电台可能包含一些已覆盖的地区，但没有关系）
2. **将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。**
3. 重复第1步直到覆盖了全部的地区

#### 思路图解：

![1649552310492](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649552310492.png)

#### 实现代码：

~~~
package Algorithm.greedyAlgorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithmDemo {
    public static void main(String[] args) {
        // 创建广播电台，放到Map
        HashMap<String,HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
        // 将各个电台放入到broadcasts
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");

        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");

        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");

        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");

        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");

        // 加入到map
        broadcasts.put("K1",hashSet1);
        broadcasts.put("K2",hashSet2);
        broadcasts.put("K3",hashSet3);
        broadcasts.put("K4",hashSet4);
        broadcasts.put("K5",hashSet5);

        // allAreas存放所有的地区
        HashSet<String> allAreas = new HashSet<String>();
        allAreas.add("北京");
        allAreas.add("上海");
        allAreas.add("天津");
        allAreas.add("广州");
        allAreas.add("深圳");
        allAreas.add("成都");
        allAreas.add("杭州");
        allAreas.add("大连");

        // 创建一个选择的电台的集合
        ArrayList<String> selects = new ArrayList<String>();

        // 定义一个临时的集合，保存在遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
        HashSet<String> tempSet = new HashSet<String>();

        // 定义maxKey，保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应电台的Key
        // 如果maxKey不为空，则会加入到selects中
        String maxKey = "";
        while (allAreas.size()!=0){ // 如果allAreas不等于0，则表示还有地区为覆盖到
            // 每进行一次while循环，maxKey置空
            maxKey = null;
            // 遍历broadcasts，取出对应的Key
            for (String key:broadcasts.keySet()){
                // 每进行一次for循环，需要将tempSet清空
                tempSet.clear();
                // 当前Key能覆盖的地区的集合
                HashSet<String> areas = broadcasts.get(key);
                tempSet.addAll(areas);
                // 求出tempSet和allAreas集合的交集，保留同时存在在tempSet和allAreas的数据
                tempSet.retainAll(allAreas);
                // 如果当前集合包含的未覆盖地区的数量，比maxKey指向的集合覆盖的地区还多，则重置maxKey，体现贪心算法的特点！！！每次都选择最优的
                if (tempSet.size()>0 && (maxKey == null || tempSet.size() > broadcasts.get(maxKey).size())){
                    maxKey = key;
                }
            }
            // maxKey != null，应该将maxKey加入到selects
            if (maxKey!=null){
                selects.add(maxKey);
                // 将maxKey指向的地区集合从allAreas中删除
                allAreas.removeAll(broadcasts.get(maxKey));
            }
        }
        System.out.println("得到的选择结果为："+selects);
    }
}
~~~

运行截图：

![1649555612116](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649555612116.png)

### 3、贪心算法注意事项和细节

> - **贪婪算法所得到的结果不一定是最优的结果( 有时候会是最优解) ，但是都是相对近似( 接近) 最优解的结果**
> - 比如上题的算法选出的是K1, K2, K3, K5，符合覆盖了全部的地区
> - 但是我们发现 K2, K3,K4,K5 也可以覆盖全部地区，如果K2 的使用成本低于K1,那么我们上题的 K1, K2, K3, K5 虽然是满足条件，但是并不是最优的。

## 6、普利姆算法

#### 应用场景- 修路问题

![1649552860871](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649552860871.png)

1. 有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通
2. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
3. 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?

思路: 将10条边，连接即可，但是总的里程数不是最小.

> **正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.**

### 最小生成树

> 修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree) ，简称MST。 
>
> 1. <font color='red'>给定一个带权的无向连通图，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树</font>
> 2. <font color='orange'>N个顶点，一定有N-1条边</font>
> 3. 包含全部顶点
> 4. N-1条边都在图中
> 5. 举例说明(如图:)
> 6. <font color='blue'>求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法</font>

![1649556102006](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649556102006.png)

### 普利姆算法介绍

> 1. <font color='red'>**普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图**</font>
>
> 2. 普利姆的算法如下：
>
>    1. 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合
>
>    2. 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点u的visited[u]=1
>
>    3. 若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1
>
>    4. 重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边
>
>    5. 提示: 单独看步骤很难理解，我们通过代码来讲解，比较好理解.

### 普利姆最佳实践-修路问题

![1649556388432](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649556388432.png)

> - 胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通
> - 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
> - 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?

#### 思路图解：

![1649557111321](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649557111321.png)

#### 实现代码：

~~~
package Algorithm.primAlgorithm;

import java.util.Arrays;

public class PrimAlgorithm {
    public static void main(String[] args) {
        // 测试
        char[] data = {'A','B','C','D','E','F','G'};
        int verxs = data.length;
        // 邻接矩阵 10000表示权值大，不连通
        int[][] weight = new int[][]{
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,10000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000}
        };

        // 创建MGraph对象
        MGraph graph = new MGraph(verxs);
        // 创建一个最小生成树对象
        MinTree minTree = new MinTree();
        minTree.createGraph(graph,verxs,data,weight);
        // 显示图
        minTree.showGraph(graph);

        // prim
        minTree.prim(graph,1);
    }
}
// 创建最小生成树---村庄图
class MinTree{
    // 创建图的邻接矩阵
    /**
     *
     * @param graph 图对象
     * @param verxs 图的顶点个数
     * @param data 图的顶点的值
     * @param weight 图的邻接矩阵
     */
    public void createGraph(MGraph graph, int verxs,char[] data,int[][] weight){
        int i,j;
        for (i=0;i<verxs;i++){ // 顶点
            graph.data[i] = data[i];
            for (j=0;j<verxs;j++){
                graph.weight[i][j] = weight[i][j];
            }
        }
    }
    // 显示图的方法
    public void showGraph(MGraph graph){
        for (int[] link:graph.weight){
            System.out.println(Arrays.toString(link));
        }
    }

    // 编写primAlgorithm算法，得到最小生成树
    /**
     *
     * @param graph 图
     * @param v 表示从图的第几个顶点开始生成
     */
    public void prim(MGraph graph,int v){
        // visited标记顶点是否被访问过
        int[] visited = new int[graph.verxs];
        // visited[]元素值默认为0，标为未被访问过

        // 把当前顶点标记为已访问
        visited[v] = 1;
        // h1和h2记录两个顶点的下标
        int h1 = -1;
        int h2 = -1;
        // 将minWeight初始化一个大数，在遍历时会重新赋值
        int minWeight = 10000;
        for (int k=1;k<graph.verxs;k++){ // 因为有graph.verxs个顶点，prim算法结束后，有graph.verxs-1条边

            // 确定每一次生成的子图，和哪个顶点的距离最近
            for (int i=0;i<graph.verxs;i++){ // i顶点表示被访问过的顶点
                for (int j=0;j<graph.verxs;j++){ // j顶点表示尚未访问过的顶点
                    if (visited[i]==1 && visited[j] == 0 && graph.weight[i][j] < minWeight){
                        // 替换minWeight（寻找已经访问过的顶点与为访问过的顶点间权值最小的边
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            // 找到一条边最小
            System.out.println("边最小："+graph.data[h1]+"->"+graph.data[h2]+"权值为："+graph.weight[h1][h2]);
            // 将当前找到的顶点标记为已经访问过了
            visited[h2] = 1;
            // 重置minWeight，方便下一次遍历
            minWeight = 10000;
        }
    }
}

// 创建图
class MGraph{
    // 表示图的结点个数
    int verxs;
    // 存放节点数据
    char[] data;
    // 存放边，零阶矩阵
    int[][] weight;

    public MGraph(int verxs) {
        this.verxs = verxs;
        data = new char[verxs];
        weight = new int[verxs][verxs];
    }
}
~~~

#### 运行截图：

![1649559024241](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559024241.png)

## 7、克鲁斯卡尔算法

#### 应用场景-公交站问题

![1649559075879](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559075879.png)

> 1. 某城市新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通
> 2. 各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里
> 3. 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?

### 克鲁斯卡尔算法介绍

> 1. <font color='orange'>**克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。**</font>
> 2. <font color='red'>**基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路**</font>
> 3. 具体做法：**首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止**

### 克鲁斯卡尔算法图解

![1649559887414](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559887414.png)

![1649560049604](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649560049604.png)

![1649560087791](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649560087791.png)

### 克鲁斯卡尔算法分析

![1649560109798](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649560109798.png)

### 判断是否构成回路

![1649560153026](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649560153026.png)

### 克鲁斯卡尔最佳实践-公交站问题

![1649559208976](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559208976.png)

> 1. 有北京有新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通
> 2. 各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里
> 3. 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?

#### 思路图解：

![1649559285678](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559285678.png)

#### 实现代码：

~~~
package Algorithm.Kruskal;

import java.util.Arrays;

public class KruskalCase {
    // 边的条数
    private int edgeNum;
    // 顶点数组
    private char[] vertxs;
    // 邻接矩阵
    private int[][] matrix;
    // INF表示两个顶点不能连通
    private static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) {
        // 测试
        char[] vertexs = {'A','B','C','D','E','F','G'};
        // 克鲁斯卡尔算法的邻接矩阵
        int[][] matrix = {
                {0,12,INF,INF,INF,16,14},
                {12,0,10,INF,INF,7,INF},
                {INF,10,0,3,5,6,INF},
                {INF,INF,3,0,4,INF,INF},
                {INF,INF,5,4,0,2,8},
                {16,7,6,INF,2,0,9},
                {14,INF,INF,INF,8,9,0}
        };

        // 创建KruskalCase对象实例
        KruskalCase kruskalCase = new KruskalCase(vertexs,matrix);

        kruskalCase.print();


        EData[] edges = kruskalCase.getEdges();
        System.out.println(Arrays.toString(edges)); // 未排序
        kruskalCase.sortEdges(edges);
        System.out.println(Arrays.toString(edges));
        kruskalCase.kruskal();

    }

    // 构造器

    public KruskalCase(char[] vertxs, int[][] matrix) {
        // 初始化顶点数和边的条数
        int vlen = vertxs.length;

        // 初始化顶点
        this.vertxs = new char[vlen];
        for (int i=0;i<vertxs.length;i++){
            this.vertxs[i] = vertxs[i];
        }

        // 初始化边
        this.matrix = new int[vlen][vlen];
        for (int i=0;i<vlen;i++){
            for (int j=0;j<vlen;j++){
                this.matrix[i][j] = matrix[i][j];
            }
        }

        // 统计边的条数
        for (int i=0;i<vlen;i++){
            // j=i+1表示不统计自己到自己的那条边
            for (int j=i+1;j<vlen;j++){
                if (this.matrix[i][j]!=INF){
                    // 这条边有效即连通
                    edgeNum++;
                }
            }
        }

    }
    public void kruskal(){
        // 表示最后结果数组的索引
        int index = 0;
        // 用于保存“已有最小生成树”中的每个顶点在最小生成树中的终点
        int[] ends = new int[edgeNum];
        // 创建结果数组，保存最后的最小生成树
        EData[] rets = new EData[edgeNum];

        // 获取途中所有的边的集合，一共有12条边
        EData[] edges = getEdges();

        // 首先按照边的权值大小进行排序
        sortEdges(edges);

        // 遍历edges数组，将边添加到最小生成树中时，判断准备加入的边是否生成了回路，如果没有就加入到结果数组中rets
        for (int i =0;i<edgeNum;i++){
            // 获取到第i条边的第一个顶点
            int p1 = getPosition(edges[i].start);
            // 获取到第i条边的第二个顶点
            int p2 = getPosition(edges[i].end);

            // 获取两个顶点在已有的最小生成树中的终点
            int m =getEnd(ends,p1);
            int n = getEnd(ends,p2);

            // 判断是否构成回路
            if (m != n){ // 没有构成回路
                ends[m] = n; // 设置m在“已有最小生成树”中的终点<E,F>  [0,0,0,0,5,0,0,0,0,0,0,0]
                // 有一条边加入rets数组！！！
                rets[index++] = edges[i];
            }
        }
        System.out.println("最小生成树为：");
        for (int i=0;i<index;i++){
            // 统计并打印最小生成树
            System.out.println(rets[i]);
        }
    }

    // 打印邻接矩阵
    public void print(){
        System.out.println("零阶矩阵为：");
        for (int i=0;i<vertxs.length;i++){
            for (int j=0;j<vertxs.length;j++){
                System.out.printf("%12d\t",matrix[i][j]);
            }
            // 换行处理
            System.out.println();
        }
    }

    // 对边按照权值排序处理，冒泡排序
    /**
     * 功能：对边进行排序
     * @param edges 边的集合
     */
    private void sortEdges(EData[] edges){
        EData temp;
        for (int i=0;i<edges.length-1;i++){
            for (int j=0;j<edges.length-1-i;j++){
                if (edges[j].weight > edges[j+1].weight){
                    temp = edges[j];
                    edges[j] = edges[j+1];
                    edges[j+1] = temp;
                }
            }
        }
    }

    /**
     *
     * @param ch 传入顶点的值，比如'A','B'...
     * @return 返回ch顶点对应的下标，如果找不到则返回-1
     */
    private int getPosition(char ch){
        for (int i=0;i<vertxs.length;i++){
            if (vertxs[i] == ch){
                return i;
            }
        }
        return -1;
    }

    /**
     * 功能：获取图中的边，放到EData[]中，后面需要遍历该数组
     * 是通过martix邻接矩阵来获取的
     * EData[]：[['A','B',12],['B','F',7]......]
     * @return 返回图中边的数组
     */
    private EData[] getEdges(){
        int index = 0;
        EData[] edges = new EData[edgeNum];
        for (int i=0;i<vertxs.length;i++){
            for (int j=i+1;j<vertxs.length;j++){
                if (matrix[i][j] != INF){
                    edges[index++] = new EData(vertxs[i],vertxs[j],matrix[i][j]);
                }
            }
        }
        return edges;
    }

    /**
     * 功能：获取下标为i的顶点的终点，用于后面判断两个顶点的终点是否相同
     * @param ends 记录了各个顶点对应的终点是哪个，ends数组是在遍历过程中逐步形成的
     * @param i 传入的顶点对应的下标
     * @return 返回的是 下标为i的顶点对应的终点的下标
     */
    private int getEnd(int[] ends,int i){
        while (ends[i] != 0){
            i = ends[i];
        }
        return i;
    }
}

// 创建一个类EData，它的对象实例就表示一条边
class EData{
    // 边的起点
    char start;
    // 边的邻接终点
    char end;
    // 边的权值
    int weight;

    // 构造器

    public EData(char start, char end, int weight) {
        this.start = start;
        this.end = end;
        this.weight = weight;
    }

    // 重写toString方法，便于输出这条边的信息

    @Override
    public String toString() {
        return "EData{" +
                "<" + start +
                ", " + end +
                "> " + weight +
                '}';
    }
}
~~~

#### 运行截图：

![1649575307306](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649575307306.png)

## 8、迪杰斯特拉算法

#### 应用场景-最短路径问题

![1649575603368](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649575603368.png)

> 1. 战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄
> 2. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
> 3. 问：如何计算出G村庄到其它各个村庄的最短距离?
> 4. 如果从其它点出发到各个点的最短距离又是多少?

### 迪杰斯特拉(Dijkstra)算法

**迪杰斯特拉(Dijkstra)**算法是典型最短路径算法，**用于计算一个结点到其他结点的最短路径。**<font color='red'> 它的主要特点是以起始点为中心向外层层扩展( **广度优先搜索思想**)，直到扩展到终点为止</font>

### 迪杰斯特拉(Dijkstra)算法过程

> 设置出发顶点为v，顶点集合V{v1,v2,vi...}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，**Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)**
>
> 1. <font color='red'>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</font>
> 2. 更新Dis集合，<font color='blue'>更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</font>
> 3. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

### 迪杰斯特拉(Dijkstra) 算法最佳应用-最短路径

![1649575852723](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649575852723.png)

> 1. 战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄
> 2. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
> 3. 问：如何计算出G村庄到 其它各个村庄的最短距离?
> 4. 如果从其它点出发到各个点的最短距离又是多少?

#### 思路图解：

![1649559285678](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559285678.png)

![1649559295595](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559295595.png)

![1649559392148](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649559392148.png)

![1649576131317](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649576131317.png)

#### 实现代码：

~~~html
package Algorithm.dijkstra;

import java.util.Arrays;

public class DijkstraAlgorithm {
    public static void main(String[] args) {
        char[] vertex = {'A','B','C','D','E','F','G'};
        // 邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        // 表示不可以连接
        final int N = 65535;
        matrix[0]=new int[]{N,5,7,N,N,N,2};
        matrix[1]=new int[]{5,N,N,9,N,N,3};
        matrix[2]=new int[]{7,N,N,N,8,N,N};
        matrix[3]=new int[]{N,9,N,N,N,4,N};
        matrix[4]=new int[]{N,N,8,N,N,5,4};
        matrix[5]=new int[]{N,N,N,4,5,N,6};
        matrix[6]=new int[]{2,3,N,N,4,6,N};

        // 创建一个Graph对象
        Graph graph = new Graph(vertex,matrix);
        graph.showGraph();
        graph.Dijkstra(6);
        graph.showDijkstra();
    }
}

class Graph{
    // 顶点数组
    private char[] vertex;
    // 邻接矩阵
    private int[][] matrix;

    // 已经访问过的顶点的集合
    private VisitedVertex vv;

    // 构造器

    public Graph(char[] vertex, int[][] matrix) {
        this.vertex = vertex;
        this.matrix = matrix;
    }

    // 显示图
    public void showGraph(){
        for (int[] link:matrix){
            System.out.println(Arrays.toString(link));
        }
    }

    // Dijkstra算法实现
    /**
     *
     * @param index 表示出发顶点对应的下标
     */
    public void Dijkstra(int index){
        vv = new VisitedVertex(vertex.length,index);
        // 更新index下标顶点到周围顶点的距离和周围顶点的前驱结点
        update(index);

        for (int j=1;j<vertex.length;j++){
            // 选择并返回新的访问顶点
            index = vv.updateArr();
            // 更新index下标顶点到周围顶点的距离和周围顶点的前驱结点
            update(index);
        }
    }

    // 更新index下标顶点到周围顶点的距离和周围顶点的前驱结点
    private void update(int index){
        int len = 0;
        // 根据遍历邻接矩阵的index行
        for (int j=0;j<matrix[index].length;j++){
            // len表示：出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和
            len = vv.getDis(index) + matrix[index][j];
            // 如果j顶点没有被访问过并且len小于出发顶点到j顶点的距离，需要更新
            if (!vv.in(j) && len < vv.getDis(j)){
                // 更新j顶点的前驱顶点为index顶点
                vv.updatePre(j,index);
                // 更新出发顶点到j顶点的距离
                vv.updateDis(j,len);
            }
        }
    }

    // 显示结果
    public void showDijkstra(){
        vv.show();
    }

}

// 已访问顶点集合
class VisitedVertex{
    // 记录各个顶点是否访问过  1表示访问过，0为访问，会动态更新
    public int[] already_arr;
    // 每个下标对应的值为前一个顶点的下标，会动态更新
    public int[] pre_visited;
    // 记录出发顶点到其他所有顶点的距离，比如G为出发顶点，就会记录到G到其他顶点的距离，会动态更新，求的最短距离就会被存放到dis
    public int[] dis;

    // 构造器
    /**
     *
     * @param length 表示顶点的个数
     * @param index 出发顶点对应的下标
     */
    public VisitedVertex(int length,int index){
        this.already_arr = new int[length];
        this.pre_visited = new int[length];
        this.dis = new int[length];

        // 初始化dis数组
        Arrays.fill(dis,65535);
        // 设置触发顶点被访问过
        this.already_arr[index] = 1;
        // 设置出发顶点的访问距离为0
        this.dis[index] = 0;
    }

    /**
     * 功能：判断index对应的顶点是否被访问过
     * @param index 顶点对应的下标
     * @return 如果访问过就返回true，否则返回false
     */
    public boolean in(int index){
        return already_arr[index] == 1;
    }

    /**
     * 功能：更新出发顶点到index顶点的距离
     * @param index 对应顶点的下标
     * @param len 待更新的距离
     */
    public void updateDis(int index,int len){
        dis[index] = len;
    }

    /**
     * 功能：更新pre顶点的前驱顶点为index顶点
     * @param pre
     * @param index
     */
    public void updatePre(int pre,int index){
        pre_visited[pre] = index;
    }

    /**
     * 功能：返回出发顶点到index顶点的距离
     * @param index
     */
    public int getDis(int index){
        return dis[index];
    }

    // 继续选择并返回新的访问顶点，比如这里的G完后，就是A点作为新的访问顶点（注意不是出发顶点）
    public int updateArr(){
        int min = 65535,index =0;
        for (int i=0;i<already_arr.length;i++){
            if (already_arr[i] == 0 && dis[i] < min){
                min = dis[i];
                index = i;
            }
        }
        // 更新index顶点被访问过
        already_arr[index] = 1;
        return index;
    }

    // 显示最后的结果
    // 即将三个数组的情况输出
    public void show(){
        System.out.println("=======================");
        for (int i:already_arr){
            System.out.print(i+" ");
        }
        System.out.println();
        for (int i:pre_visited){
            System.out.print(i+" ");
        }
        System.out.println();

        // 方便查看最短距离处理一下
        char[] vertex = {'A','B','C','D','E','F','G'};
        int count =0 ;
        for (int i:dis){
            if (i != 65535){
                System.out.print(vertex[count]+"("+i+")  ");
            }else {
                System.out.println('N');
            }
            count++;
        }
        System.out.println();
    }
}
~~~

#### 运行截图：

![1649582633439](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649582633439.png)

## 9、弗洛伊德算法

### 弗洛伊德(Floyd)算法介绍

1. 和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算
   法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授 罗伯特· 弗洛伊德命名
2. <font color='red'>**弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径**</font>
3. <font color='blue'>**迪杰斯特拉算法(Dijkstra)用于计算图中某一个顶点到其他顶点的最短路径。**</font>
4. 弗洛伊德算法 VS 迪杰斯特拉算法 ：**迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；**<font color='green'>**弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。**</font>

### 弗洛伊德(Floyed)算法图解分析

> - 设<font color='red'>**置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径**</font>
> - 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得
> - 弗洛伊德(Floyd)算法图解分析-举例说明

![1649577204148](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649577204148.png)

![1649577228470](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649577228470.png)

![1649577240795](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649577240795.png)

### 弗洛伊德(Floyd) 算法最佳应用-最短路径

![1649577267871](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649577267871.png)

> 1. 胜利乡有7个村庄(A, B, C, D, E, F, G)
> 2. 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
> 3. 问：如何计算出 各村庄到 其它各村庄的最短距离?

#### 代码实现：

~~~html
package Algorithm.floyed;

import java.util.Arrays;

public class FloyedAlgorithm {
    public static void main(String[] args) {
        char[] vertex = {'A','B','C','D','E','F','G'};
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[]{0,5,7,N,N,N,2};
        matrix[1] = new int[]{5,0,N,9,N,N,3};
        matrix[2] = new int[]{7,N,0,N,8,N,N};
        matrix[3] = new int[]{N,9,N,0,N,4,N};
        matrix[4] = new int[]{N,N,8,N,0,5,4};
        matrix[5] = new int[]{N,N,N,4,5,0,6};
        matrix[6] = new int[]{2,3,N,N,4,6,0};

        // 创建图对象
        Graph graph = new Graph(vertex.length,matrix,vertex);
        // floyed算法
        graph.floyed();
        graph.show();
    }
}

// 创建图
class Graph{
    // 存放顶点的数组
    private char[] vertex;
    // 保存从各个顶点出发到其他顶点的距离，最后的结果也是保留在该数组中
    private int[][] dis;
    // 保存到达目标顶点的前驱顶点
    private int[][] pre;

    // 构造器
    /**
     *
     * @param length 大小（顶点个数）
     * @param matrix 初始的邻接矩阵
     * @param vertex 顶点数组
     */
    public Graph(int length,int[][] matrix,char[] vertex){
        this.vertex = vertex;
        this.dis = matrix;
        this.pre = new int[length][length];
        // 对pre数组初始化，存放的是前驱节点的下标
        for (int i=0;i<length;i++){
            Arrays.fill(pre[i],i);
        }
    }

    // 显示dis和pre
    public void show(){
        // 为了显示便于阅读，优化一下输出
        char[] vertex = {'A','B','C','D','E','F','G'};
        for (int k=0;k<dis.length;k++){
            // 先将pre数组输出
            for (int i:pre[k]){
                System.out.print(vertex[i] + "  ");
            }
            System.out.println();
            // 将dis数组显示
            for (int j=0;j<vertex.length;j++){
                System.out.print("("+vertex[k]+"到"+vertex[j]+"的最短路径为"+dis[k][j]+")  ");
            }
            System.out.println();
        }
    }

    // floyed算法
    public void floyed(){
        // 保存距离
        int len = 0;
        // 从中间顶点遍历，k就是中间顶点的下标
        for (int k=0;k<dis.length;k++){
            // 出发顶点，从i顶点出发：['A','B','C','D','E','F','G']
            for (int i=0;i<dis.length;i++){
                for (int j=0;j<dis.length;j++){
                    // 求出从i顶点出发，经过k中间顶点，到达j顶点的距离
                    len = dis[i][k] + dis[k][j];
                    // 如果len < dis[i][j]，则更新距离
                    if (len < dis[i][j]){
                        dis[i][j] = len;
                        // 更新前驱顶点
                        pre[i][j] = pre[k][j];
                    }
                }
            }
        }
    }
}
~~~

#### 运行截图：

![1649592600723](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649592600723.png)

## 10、马踏棋盘算法

### 马踏棋盘算法介绍和游戏演示

> 1. 马踏棋盘算法也被称为骑士周游问题
> 2. 将马随机放在国际象棋的8×8棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则( 马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格

![1649582829475](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649582829475.png)

### 马踏棋盘游戏代码实现

- 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。
- 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析+代码实现
- 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.

#### 思路图解：

![1649582924098](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649582924098.png)

#### 实现代码：

~~~html
package Algorithm.horse;

import java.awt.*;
import java.util.ArrayList;

public class HorseChessboard {
    // 棋盘的列数
    private static int X;
    // 棋盘的行数
    private static int Y;
    // 创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    // 使用一个变量，标记是否棋盘的所有位置都被访问过，如果为true则表示成功
    private static boolean finished;

    public static void main(String[] args) {
        X = 8;
        Y = 8;
        // 马儿的初始位置，从1开始编号
        int row = 1;
        int column = 1;
        // 创建棋盘
        int[][] chessboard = new int[X][Y];
        // 初始值都为false
        visited = new boolean[X * Y];
        long start = System.currentTimeMillis();
        traversalChessboard(chessboard,row-1,column-1,1);
        long end = System.currentTimeMillis();
        System.out.println("共耗时："+(end-start)+"毫秒");
        // 输出棋盘的最后情况
        for (int[] rows:chessboard){
            for (int step:rows){
                System.out.print(step+"\t");
            }
            System.out.println();
        }
    }

    // 马踏棋盘的算法
    /**
     *
     * @param chessboard 棋盘
     * @param row 马儿当前位置的行
     * @param column 马儿当前位置的列
     * @param step 马儿走的是第几步，初始位置为第一步，依次递增
     */
    public static void traversalChessboard(int[][] chessboard,int row,int column,int step){
        chessboard[row][column] = step;
        // 标记该位置已经访问
        visited[row * X + column] = true;
        // 获取当前位置可以走的下一个位置的集合
        // (column,row)的原因：因为在next函数中，x、y轴，x表示列，y表示行，所以需要先列后行
        ArrayList<Point> points = next(new Point(column,row));
        // 遍历points
        while (!points.isEmpty()){
            // 取出下一个可以走的位置
            Point point = points.remove(0);
            // 判断该点是否已经访问过
            if (!visited[point.y*X+point.x]){ // 还未访问过
                traversalChessboard(chessboard,point.y,point.x,step+1);
            }
        }
        // 判断马儿是否完成任务
        // step < X * Y成立的情况有两种：
        // 1、棋盘还未走完
        // 2、棋盘走完，但尚处于回溯过程中
        if (step < X*Y && !finished){
            // 未完成任务
            chessboard[row][column] = 0;
            visited[row*X+column] = false;
        }else {
            finished = true;
        }
    }

    /**
     * 功能：根据当前的位置（Point），计算马儿还能走哪些位置（Point），并放入到一个集合中（ArrayList），最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint){
        // 创建ArrayList
        ArrayList<Point> ps = new ArrayList<Point>();
        // 创建Point
        Point p1 = new Point();
        // 左、上为减法
        // 右、下为加法
        // 表示马儿可以走5的位置
        if ((p1.x = curPoint.x - 2) >=0 && (p1.y = curPoint.y -1 )>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走6这个位置吗
        if ((p1.x = curPoint.x -1)>=0 && (p1.y=curPoint.y-2)>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走7这个位置吗
        if ((p1.x = curPoint.x + 1) < X && (p1.y=curPoint.y-2)>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走0这个位置吗
        if ((p1.x = curPoint.x +2) < X && (p1.y=curPoint.y-1)>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走1这个位置吗
        if ((p1.x = curPoint.x +2) < X && (p1.y=curPoint.y+1)<Y){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走2这个位置吗
        if ((p1.x = curPoint.x +1) < X && (p1.y=curPoint.y+2) < Y){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走3这个位置吗
        if ((p1.x = curPoint.x -1) >=0 && (p1.y=curPoint.y+2) < Y){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走4这个位置吗
        if ((p1.x = curPoint.x -2) >=0 && (p1.y=curPoint.y+1) < Y){
            ps.add(new Point(p1));
        }
        return ps;
    }
}
~~~

#### 运行截图：

![1649598145127](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649598145127.png)

### 骑士周游回溯算法-贪心算法优化

![1649598489795](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649598489795.png)

#### 实现代码：

~~~
package Algorithm.horse;

import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;

public class greedyHorse {
    // 棋盘的列数
    private static int X;
    // 棋盘的行数
    private static int Y;
    // 创建一个数组，标记棋盘的各个位置是否被访问过
    private static boolean visited[];
    // 使用一个变量，标记是否棋盘的所有位置都被访问过，如果为true则表示成功
    private static boolean finished;

    public static void main(String[] args) {
        X = 8;
        Y = 8;
        // 马儿的初始位置，从1开始编号
        int row = 1;
        int column = 1;
        // 创建棋盘
        int[][] chessboard = new int[X][Y];
        // 初始值都为false
        visited = new boolean[X * Y];
        long start = System.currentTimeMillis();
        traversalChessboard(chessboard,row-1,column-1,1);
        long end = System.currentTimeMillis();
        System.out.println("共耗时："+(end-start)+"毫秒");
        // 输出棋盘的最后情况
        for (int[] rows:chessboard){
            for (int step:rows){
                System.out.print(step+"\t");
            }
            System.out.println();
        }
    }

    // 马踏棋盘的算法
    /**
     *
     * @param chessboard 棋盘
     * @param row 马儿当前位置的行
     * @param column 马儿当前位置的列
     * @param step 马儿走的是第几步，初始位置为第一步，依次递增
     */
    public static void traversalChessboard(int[][] chessboard,int row,int column,int step){
        chessboard[row][column] = step;
        // 标记该位置已经访问
        visited[row * X + column] = true;
        // 获取当前位置可以走的下一个位置的集合
        // (column,row)的原因：因为在next函数中，x、y轴，x表示列，y表示行，所以需要先列后行
        ArrayList<Point> points = next(new Point(column,row));
        // 对points进行排序，排序的规则就是对points所有的Point对象的下一步的位置的数目，进行非递减排序
        sort(points);
        // 遍历points
        while (!points.isEmpty()){
            // 取出下一个可以走的位置
            Point point = points.remove(0);
            // 判断该点是否已经访问过
            if (!visited[point.y*X+point.x]){ // 还未访问过
                traversalChessboard(chessboard,point.y,point.x,step+1);
            }
        }
        // 判断马儿是否完成任务
        // step < X * Y成立的情况有两种：
        // 1、棋盘还未走完
        // 2、棋盘走完，但尚处于回溯过程中
        if (step < X*Y && !finished){
            // 未完成任务
            chessboard[row][column] = 0;
            visited[row*X+column] = false;
        }else {
            finished = true;
        }
    }

    /**
     * 功能：根据当前的位置（Point），计算马儿还能走哪些位置（Point），并放入到一个集合中（ArrayList），最多有8个位置
     * @param curPoint
     * @return
     */
    public static ArrayList<Point> next(Point curPoint){
        // 创建ArrayList
        ArrayList<Point> ps = new ArrayList<Point>();
        // 创建Point
        Point p1 = new Point();
        // 左、上为减法
        // 右、下为加法
        // 表示马儿可以走5的位置
        if ((p1.x = curPoint.x - 2) >=0 && (p1.y = curPoint.y -1 )>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走6这个位置吗
        if ((p1.x = curPoint.x -1)>=0 && (p1.y=curPoint.y-2)>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走7这个位置吗
        if ((p1.x = curPoint.x + 1) < X && (p1.y=curPoint.y-2)>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走0这个位置吗
        if ((p1.x = curPoint.x +2) < X && (p1.y=curPoint.y-1)>=0){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走1这个位置吗
        if ((p1.x = curPoint.x +2) < X && (p1.y=curPoint.y+1)<Y){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走2这个位置吗
        if ((p1.x = curPoint.x +1) < X && (p1.y=curPoint.y+2) < Y){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走3这个位置吗
        if ((p1.x = curPoint.x -1) >=0 && (p1.y=curPoint.y+2) < Y){
            ps.add(new Point(p1));
        }
        // 判断马儿可以走4这个位置吗
        if ((p1.x = curPoint.x -2) >=0 && (p1.y=curPoint.y+1) < Y){
            ps.add(new Point(p1));
        }
        return ps;
    }

    // 根据当前这一步的所有的下一步的选择位置，进行非递减排序
    public static void sort(ArrayList<Point> ps){
        // 排序减少回溯的次数
        ps.sort(new Comparator<Point>() {
            @Override
            public int compare(Point o1, Point o2) {
                // 获取到o1的下一步的所有位置
                int count1 = next(o1).size();
                int count2 = next(o2).size();
                if (count1<count2){
                    return -1;
                }
                else if (count1 == count2){
                    return 0;
                }else {
                    return 1;
                }
            }
        });
    }
}
~~~

#### 运行截图：

![1649599121220](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649599121220.png)

**速度明显大大的提升了！！！**

# 补充

## 一、回溯

<font color='red'>回溯法简单来说就是按照深度优先的顺序，穷举所有可能性的算法，</font>但是回溯算法比暴力穷举法更高明的地方就是<font color='red'>回溯算法可以随时判断当前状态是否符合问题的条件。</font>一旦不符合条件，那么就退回到上一个状态，省去了继续往下探索的时间。 

**回溯法---深度优先搜索**

- 从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到“尽头”的时候, 再倒回出发点, 从另一个可能出发, 继续搜索。这就是回溯。

# 算法的时间复杂度和空间复杂度

## 1、时间复杂度

时间复杂度：时间复杂度实际上是一个函数，<font color='red'>代表基本操作重复执行的次数</font>，进而分析函数虽变量的变化来确定数量级，数量级用O表示，所以算法的时间复杂度为：

> T（n）=O（f（n）)

<font color='blue'>在一个算法存在最好、平均、最坏三种情况，</font>我们<font color='red'>一般关注的是最坏情况，</font>原因是，最坏情况是任何输入实例在运行时间的上界，对于某些算法来说，最坏情况出现的比较频繁，从大体上来看，平均情况和最坏情况一样差。

一般O（n）的计算方法：

1. <font color='red'>用1代替所有运行时间中出现的加法常数；</font>
2. <font color='green'>在修改后的运行函数中保留最高阶的项；</font>
3. <font color='blue'>如果最高阶的项系数不是1，则去除这个项系数。</font>
4. **递归算法的时间复杂度为：递归总次数*每次递归中基本操作执行的次数。**

常见的时间复杂度有以下七种：

> 1. O（1）常数型
> 2. O（log2N）对数型
> 3. O（N）线性型
> 4. O（Nlog2N）二维型
> 5. O（N^2)平方型
> 6. O（N^3)立方型
> 7. O（2^N）指数型。

 ![img](https://img-blog.csdn.net/2018052318285274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zmc2l3ZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

## 2、空间复杂度

<font color='red'>空间复杂度是对一个算法在运行过程中**临时占用存储空间的度量**，</font>**一个算法在计算机存储器上所占用的存储空间包括存储算法本身所占用的空间，算数和输入输出所占用的存储空间以及临时占用存储空间三个部分**，算法的输入输出数据所占用的存储空间是由待解决的问题来决定的，通过参数表由调用函数而来，它随本算法的不同而改变，存储算法本身所占用的存储空间有算法的书写长短成正比。<font color='red'>算法在运行过程中占用的临时空间由不同的算法决定。</font>

![1650265712603](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650265712603.png)

**时间复杂度：O(1)，空间复杂度：O(1); **

## 3、案例

### 1

1. 当有若干个循环时，时间复杂度是和嵌套层数最多的循环语句中最内层的频度决定的 

![1650266198504](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266198504.png)

**时间复杂度：O(n^3),空间复杂度：O（1） **

### 2

2. 二分法的时间复杂度 

![1650266258695](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266258695.png)

分析：

![1650266276820](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266276820.png)

在最坏的情况下循环x次后找到，n/（2^x）=1;x=log2n;

所以二分查找的时间复杂度为：O（log2n）；空间复杂度O（1）； 

### 3

3. 用递归算法求n的阶乘 

![1650266332839](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266332839.png)

 n的阶乘的时间复杂度很简单：就是n次递归算法，所以为O（n），空间复杂度O（n），递归的深度是n。 

### 4

4.  斐波那契数列 

![1650266364479](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266364479.png)

分析：

![1650266376314](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266376314.png)

将其用流程图画出来发现是一个完全二叉树，节点数为2^n-1

深度为n，根据最坏情况，时间复杂度为O（2^n），空间复杂度为O（n）；

![1650266411983](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650266411983.png)

