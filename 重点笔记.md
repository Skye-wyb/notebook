## 数组的四种声明方式

#### 1、先声明再初始化

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/202007232016101.png) 

#### 2、声明并初始化

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723201636430.png) 

#### 3、创建数组同时赋值

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723201729319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NzczMDA0,size_16,color_FFFFFF,t_70) 

#### 4、创建同时赋值，简写，不能写成两条语句

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200723201804494.png) 

### 数组的方法

#### 1.shift():

从[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)中移除元素:

shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值

**返回值：**

数组原来的第一个元素的值。

#### 2.unshift()

 向[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)中添加元素:

unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度 

**参数描述：**

参数一：必需。向数组添加的第一个元素。

参数二：可选。向数组添加的第二个元素。

参数三：可选。可添加若干个元素。

**返回值：**

array 的新长度。

#### 3.pop()

 pop() 方法用于删除并返回数组的最后一个元素 

**返回值：**

array的最后一个元素

#### 4.push()

 push() 方法可向[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)的末尾添加一个或多个元素，并返回新的长度。 

**参数描述：**

参数一：必需。要添加到数组的第一个元素。

参数二：可选。要添加到数组的第二个元素。

参数三：可选。可添加多个元素。

**返回值：**

把指定的值添加到数组后的新长度。

#### 5.map()

**用来生成 / 创建一个新数组**。

其结果是该数组中的每个元素调用一次提供的函数后的返回值。
map 不修改原数组本身（会在 callback 执行时改变原数组） 

~~~
map()方法按照原始数组元素顺序依次处理元素
~~~

#### 6.from()

**<font color='red'>Array.from()方法就是将一个类数组对象或者可遍历对象转换成一个真正的数组。</font>**

Array.from有三个参数Array.from(arrayLike[, mapFn[, thisArg]])，arrayLike：想要转换成数组的伪数组对象或可迭代对象；

#### 7.filter()

filter() 方法**创建一个新的数组**，对每个元素进行遍历，**符合条件则可以返回，不符合就过滤掉**。

**接收两个参数**，一个是函数，返回一个布尔类型的值，决定元素是否保留，一个是函数的this指向（类

似map方法）；  

<font color='red'>注意点：</font>

1、filter可以**改变数组长度**，可以修改**对象数组**属性的值，不能修改**普通数组**的值；

2、**不对空数组校验**，但返回的是空[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)

#### 8.reduce()

对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。

reducer 函数接收4个参数:

- Accumulator (acc) (累计器)
- Current Value (cur) (当前值)
- Current Index (idx) (当前索引)
- Source Array (src) (源数组)

reduce为数组中的每一个元素依次执行回调函数，但是不包括数组中被删除或从未被赋值的元素

- reduce方法最终返回的是最后一次调用累加器的结果

#### 9.join()

> 数组.join('间隔符号')

 **join() 将数组单元中存储的数据,拼接为一个字符串**

#### 10. arraycopy()

> <font color='red'>System.arraycopy(src, srcPos, dest, destPos, length);</font>

- src表示源数组
- srcPos表示源数组中拷贝元素的起始位置。
- dest表示目标数组
- destPos表示拷贝到目标数组的起始位置
- length表示拷贝元素的个数

#### 内边距撑开盒子

如果块级元素（div）未设置宽度或高度，则padding不会撑开盒子；可以设置display:inline-block；但此时，margin：100px,auto；居中会失效。

#### 后代选择器

**：nth-child(n)**

选择第n个孩子

**:first_child**

选择第一个孩子

**:last-child:**

选择最后一个孩子

#### margin: 0 auto; 居中失效原因

**1.没有指定宽度**

解决：设置width
结论：分别给要居中的元素添加了指定宽度，没变化，说明不是这个原因

**2.浮动、绝对定位、固定定位的盒子失效**

结论：看不见有这方面的设置啊，排除

**3.行内元素失效**

解决方法：①设置display:block；②给定要居中的行内元素的宽度。（自带宽度的input/button等元素无需设置宽度）

**4.display:table-cell;只要display不是block就会失效**

解决方法：display:block,然后margin:0 auto生效。

# 字符串的方法

##### 1.slice()

 slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 

| 参数  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| start | 要抽取的片断的起始下标。如果是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。 |
| end   | 紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。 |

###### 返回值

一个新的字符串。包括字符串 stringObject 从 start 开始（包括 start）到 end 结束（不包括 end）为止的所有字符。

#### 数组中的方法

##### 1.slice()

 slice() 方法可从已有的数组中返回选定的元素。 

| 参数  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| start | 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 |
| end   | 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 |

###### 返回值

 返回一个新的数组，包含从 start 到 end （包含start元素但不包括end元素）的 arrayObject 中的元素。 

#### charAt(index)方法

用于检索一个字符串中特定索引的字符

例如： str.charAt(0)检索str中的第一个字符 

#### toUpperCase()方法

**作用：**用于把[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)转换为大写
**语法：**string.toUpperCase()
**返回：**一个新的全部大写的字符串。
**提示**：原字符串不改变。

#### toLowerCase()方法

**作用：**用于把[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)转换为小写
**语法：**string.toLowerCase()
**返回：**一个新的全部小写的字符串。
**提示**：原字符串不改变。

## sizeof和strlen

#### sizeof()

<font color='red'>sizeof()是运算符，而不是一个函数</font>

**由于在编译时计算，所以sizeof不能用于返回动态分配的内存空间的大小**

当参数不同时，sizeof返回的值表示含义如下：

> 数组：编译时分配的数组空间大小
>
> 指针：存储该指针所用的空间大小（存储该指针的地址的长度）
>
> 类型：该类型所占的空间大小
>
> 对象：对象的实际占用空间大小
>
> 函数：函数的返回类型所占的空间大小，函数的返回类型不能是void

注意：

~~~
char str[] = 'Hello'
~~~

**sizeof(str)=6**

解析：因为<font color='orange'>sizeof计算长度包括字符串结束符'\0'</font>

#### strlen()

<font color='red'>strlen()是函数，要在运行时才能计算</font>

**参数必须是字符型指针（char*），且必须是以'\0'结尾的**

注意：

~~~
char str[] = 'Hello'
~~~

**strlen(str)=5**

解析：因为<font color='green'>strlen计算长度不包括字符串结束符'\0'</font>

总结：

> 1. **sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。**
> 2. **strlen只关心存储的数据内容，不关心空间的大小和类型。** 

# String的相关方法

#### 1、substring()

 **substring()的作用就是截取父字符串的某一部分** 

substring(int beginIndex, int endIndex)

- <font color='red'>第一个参数int为开始的索引，对应String数字中的开始位置</font>
- <font color='red'>第二个参数是截止的索引位置，对应String中的结束位置</font>

1、取得的字符串长度为：endIndex - beginIndex;

2、从beginIndex开始取，到endIndex结束，从0开始数，其中不包括endIndex位置的字符

**substring(a,b)中的参数a其值可以从索引值0开始，当a等于0时，则表示其从字符串的第一个字符开始算起，也就是其子字符串是包含第一个字符的，当然，你也可以从后续的其他字符开始；**

**substring(a,b)中的参数b,其值最大可以为 父字符串的长度，但并不包含索引值为b的那个字符。**

<font color='green'>**如果没有endIndex，则表示从beginIndex开始有多少位截取多少位**</font>

#### 2、length()

获取字符串的长度

#### 3、charAt()

~~~
charAt(int index)
~~~

获取指定索引处的字符

#### deleteCharAt(int index)

>  删除指定位置的字符 

#### 4、indexOf()

~~~
indexOf(String str)
~~~

<font color='red'> 获取str在字符串对象中第一次出现的索引 </font>

#### 5、equals() 

~~~
equals(Object obj)
~~~

 比较字符串的内容是否相同 

#### 6、 equalsIgnoreCase()

~~~
equalsIgnoreCase(String anotherString)
~~~

 比较字符串的内容是否相同,忽略大小写 

#### 7、startsWith()

~~~
startsWith(String prefix)
~~~

判断字符串对象是否以指定的字符开头

~~~
startsWith(String prefix,int toffset)
~~~

判断字符串对象是否以指定的字符开头，参数toffset指定从哪个下标开始

#### 8、endWith()

~~~
endWith(String str)
~~~

判断字符串对象是否以指定的字符结尾

#### 9、isEmpty()

~~~
isEmpty()
~~~

判断指定字符串是否为空

### 字符串的转化方法

#### 1、toCharArray()

> 把字符串转化为字符数组
>

#### 2、toLowerCase()

> 把字符串转换为小写字符串
>

#### 3、toUpperCase()

> 把字符串转换为大写字符串
>

#### 4、valueof

> 将其他基本类型转换为String类型

### 其他常用方法

#### 1、trim()

> 去除字符串两端空格
>

#### 2、split()

> 去除字符串中指定的字符，然后返回一个新的字符串数组
>

![1649833781202](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649833781202.png)

![1649833810372](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649833810372.png)

#### 3、subSequence()

~~~
subSequence(int beginIndex,int endIndex)
~~~

> 截取字符串中指定位置的字符组成一个新的字符串 
>

#### 4、replace()

~~~
replace(char oldChar,char newChar)
~~~

> 将指定字符替换成另一个指定的字符
>

#### 5、replaceAll()

~~~
replaceAll(String regex,String replasement)
~~~

> 用新的内容替换全部旧内容
>

#### 6、replaceFirst()

~~~
replaceFirst(String regex,String replacement)
~~~

>  替换首个满足条件的内容 
>

#### 7、lastIndexOf()

~~~
lastIndexOf(String str)
~~~

> 返回指定字符出现的最后一次的下标
>

#### 8、contains()

~~~
contains(CharSequence s)
~~~

> 查看字符串中是否含有指定字符
>

#### 9、concat()

~~~
concat(String str)
~~~

> 在原有的字符串的基础上加上指定字符串
>
> substring(a,b)中的参数b，其值最大可以为 父字符串的长度，但并不包含索引值为b的那个字符。
>

#### 10、matches()

>  String.matches() 这个方法主要是返回是否匹配指定的字符串，如果匹配则为true,否则为false; 
>
>  最易于看一个<font color='red'>字符串是否与正则表达式相匹配 </font>
>

#### 11、delete(int start,int end)

> 删除一段字符

#### 12、insert && erase

![1649819339493](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649819339493.png)

### Vue运行报错：

'vue-cli-service' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

**解决办法：删除现有的node_modules文件，然后在终端执行  npm install vue-cli-service -S ，单独安装"vue-cli-service"**

#### 父子组件之间传递数据（共享数据）

1.父组件向子组件共享数据：使用自定义属性，在子组件中通过 props 自定义属性

2.子组件向父组件共享数据：使用自定义事件

#### 面试问的较多的问题：Vue组件之间共享数据有哪些方法？过程是怎么样的

#### 兄弟组件之间传递数据：

 1.创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象

2. 在数据发送方，调用 bus.$emit('事件名称', 要发送的数据) 方法触发自定义事件 
3. 在数据接收方，调用 bus.$on('事件名称', 事件处理函数) 方法注册一个自定义事件 ，通过事件处理回调函数接收发送方传递过来的数据。

#### 组件自定义属性：props

props是只读不能修改的，若要修改props的值，可以将其转存到data中，然后进行修改；data(){

return{count:this.init;}}

#### 输入框失去焦点事件：

onblur、blur()

#### 数组的方法

###### 1.some()遍历

```
 some(function(){})方法，同样是针对数组中的每一个元素，但是这个方法是，只要有一个元素比对结果为true，返回结果就为true，反之要所有的元素比对结果全为false才为false；
 some(function(){})方法，在遍历过程中，在找到对应的项之后，可以通过 return true 固定的语法，来终止 some 循环
```

###### 2.every()方法

~~~
every(function(){})方法，针对数组中的每一个元素进行比对，只要有一个元素比对结果为false则返回false，反之要所有的元素比对结果全为true才为true；
~~~

###### 3.filter()方法

~~~
filter(function(){})方法不会对空数组进行检测，不会改变原始数组
filter(function(){})方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素；
~~~

~~~
Array.every(x=>x)是每一个都要满足

Array.some(x=>x)是有一个满足。

Array.find（findIndex)，返回符合条件的第一个值。

Array.filter（过滤成新的数组）
~~~

###### 4.reduce()方法

~~~
arr.filter(item => item.state).reduce((累加的结果, 当前的循环项) => { 
	函数表达式（对item循环项的处理）
	return 每一个处理后的累加值
}, 累积结果的初始值)
~~~

#### Number数字对象的方法

###### 1.toString()

可以把数字转换为字符串，参数radix，默认为0；

radix为2，表示以二进制值显示；

radix为8，表示以八进制值显示；

radix为16，表示以十六进制值显示；

###### 2.toFixed()

可以把Number四舍五入为小数位数指定的数字

参数：x，规定小数的位数，默认为0

###### 3.toExponential()

可把对象的值转换为指数计数法

参数：x，规定指数计数法中的小数位数，默认为6

###### 4.toPrecision()

可把对象的值超出指定位数时将其转换为指数计数法

参数：x，规定必须被转换为指数计数法的最小位数，若省略该参数，则调用toString()方法

###### 5.isFinite()

用户检测指定参数是否无穷大，若为有限数字则返回true，否则返回false

~~~
Number.isFinite() 与全局的 isFinite() 函数不同，全局的 isFinite() 会先把检测值转换为 Number ，然后在检测。

Number.isFinite() 不会将检测值转换为 Number对象，如果检测值不是 Number 类型，则返回 false。
~~~

#### CSS选择器

##### 1.元素选择器

~~~
HTML元素是最典型的选择器类型，任何一个HTML元素都可以做为选择器。元素选择器的有效范围为页面中所有的、名称相同的HTML元素。

格式： 元素 { 属性: 值; }

例如：h1 { color: red; } h2 { color: #FF0000; } 或者：h1, h2 { color: #ff0000; }
~~~

##### 2.类选择器

如果想要把某一个样式应用到不同的HTML元素上，可以采用类选择器来定义，然后在不同标签中应用它们。

格式1： .类名 { 属性: 值; }

格式2：元素.类名 { 属性: 值; }

~~~
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
<title>类选择器示例1</title>
<style type="text/css">
.tt{ font-size:10pt; font-family:黑体; color:#800080; font-weight:bold; }
</style>
</head>
<body>
<p class="tt">示例一</p> /*p标签应用名字为tt的类层叠样式表*/
<h1 class="tt">示例二</h1> /*h1标签也应用名字为tt的类层叠样式表*/
</body>
</html>
~~~

##### 3.ID选择器

除了使用类选择器的方式定义一个样式以外，还可以使用ID定义样式。ID与类选择器的概念相似，**只是ID选择器只能被引用一次，而类选择器可以被多次引用。**
格式：**#id名 { 属性: 值; }**

示例：**#red { color: red; }**

~~~
<p id="red">欢迎使用id选择器</p>
~~~

##### 4.后代选择器

 如果需要为位于某个标记符内的元素设置特定的样式规则，则应将选择器指定为具有上下文关系的HTML标记 。

~~~
h1 b{
	color:blue;
}
~~~

##### 5.属性和值选择器

######  5.1为带有 title 属性的所有元素设置样式： 

~~~
[title]{
	color:red;
}
~~~

###### 5.2 为 title=“bjsxt” 的所有元素设置样式 

~~~
[title='bjsxt']{
	border:5px solid blue;
}
~~~

###### 5.3 设置表单的样式 

~~~
input[type="text"]
{
  width:150px;
  display:block;
  margin-bottom:10px;
  background-color:yellow;
  font-family: Verdana, Arial;
}

input[type="button"]
{
  width:120px;
  margin-left:35px;
  display:block;
  font-family: Verdana, Arial;
}
~~~

##### 6.通配符选择器

~~~
/*
        通配符选择器
        语法格式：
            *{
                属性:值;
            }
        语法说明:
            *表示任意标签
        注意:
            1.在实际开发中，*因为通配任意标，而且不同浏览器，body存在间距，所以一般使用*处理间隙
        */
        *{
            margin: 0px;
            padding: 0px;
            background-color: brown;
        }
~~~

##### 7.交集选择器

~~~
/*
        交集选择器
        语法格式：
            元素名.类名{
                属性:值;
            }
            或者
            元素名#ID值{
                属性:值;
            }
         语法解释:
            1.交集符合选择器是由两个选择器直接构成的，其结果是二者元素范围的交集。
            2.其中第一个选择器必须是元素选择器，第二个选择器是ID选择器或者类选择器
            3.两个选择器中间不能有空格
        */
        p.classvalue{
            color:red; text-align:center;
        }
~~~

##### 8.并集选择器

~~~
/*
       并集选择器
       语法格式:
            选择器1,选择器2,...,选择器n{
                属性:值;
            }
        语法说明:
            1.并集选择器是由多个选择器组成,各个选择器之间使用英文的逗号(,)分隔。
            2.这多个选择器都会有这些CSS样式
        注意：
            1.在实际开发中并集选择器使用频率比较高。
            2.公共样式可以使用并集选择器抽离出来,这样精简CSS样式代码
        */
        div,p{
            width: 200px;
            height: 100px;
            border: 2px solid rebeccapurple;
        }
~~~

##### 9.子选择器

~~~
/*
       子类选择器
       语法格式:
            选择器1>选择器2{
                属性:值;
            }
        语法说明:
            1.子类选择器也是由多个选择器组成,各个选择器之间使用">"连接，其效果类似于后代选择器
        注意:
            子类选择器其作用类似于后代选择器,但是子类选择器其效率高于后代选择器,推荐使用
        */
        body>div{
            border: #ff858f 2px solid;
            height: 300px;
            width: 400px;
            background-color: #c7ffaf;
        }
~~~

##### 10.伪类选择器

~~~
 /*
        伪类选择器
        语法格式:
            初始化的样式
            a:link{
                属性:值;
            }
            鼠标点击过后的样式
            a:visited{
                属性:值;
            }
            鼠标放在上面的样式
            a:hover{
                属性:值;
            }
            鼠标按下时的样式
            a:active{
                属性:值;
            }
            注意：
                1.在CSS样式的定义中,a:hover 必须被置于 a:link 和 a:visited 之后，
                    顺序不对，有时样式会失效
                2.:hover属性适用于任何元素
                3.应当将相同的属性抽离出来,放在a标签选择器中
        */
        div{
            margin: 30% auto;
            height: 200px;
            width: 700px;
        }
        a:link{
            color: #ff858f;
            font-size: 20px;
            font-family: "Microsoft YaHei UI";
            text-decoration: none;
            margin: 20px;
        }
        a:hover{
            text-decoration: underline;
            color: #1bff4c;
            font-size: 25px;
            font-weight: bold;
        }
        a:active{
            color: red;
            text-decoration: none;
        }
        a:visited{
            color: aqua;
        }
        div.div2:link{
            background-color: #1bff4c;
            height: 200px;
            width: 200px;
        }
        div.div2:hover{
            background-color: #ff858f;
        }
~~~

###### 10.1:root：伪类选择器

**:root 表示<html>元素，除了优先级更高之外，与 html选择器相同**。

#### flex布局

display:flex

**// 主轴上的对齐方式**

 justify-content: space-between;

~~~
可选值：justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;
~~~

#####  ![img](https://img-blog.csdnimg.cn/20190502141523947.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjA3Njk0,size_16,color_FFFFFF,t_70) 

 **// 在交叉轴上如何对齐**

 align-items: center;

~~~
可选值：align-items: stretch | flex-start | flex-end | center | baseline;
~~~

 ![img](https://img-blog.csdnimg.cn/20190502151638555.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NjA3Njk0,size_16,color_FFFFFF,t_70)



#### input的属性

##### 1.autocomplete属性

autocomplete属性：清除input框输入存留的历史值，防止下拉历史值显示

**input 的属性autocomplete 默认为on，其含义代表是否让浏览器自动记录之前输入的值**

**很多时候，需要对客户的资料进行保密，防止浏览器软件或者恶意插件获取到**

**可以在input中加入autocomplete="off" 来关闭记录**

#### token值的模拟存储和获取

##### 1.模拟存储Token

~~~
localStorage.setItem('token','Bearer XXX')
~~~

##### 2.模拟获取Token

~~~
localStorage.getItem('token')
~~~

##### 3.模拟清除Token

~~~
localStorage.removeItem('token')
~~~

#### box-sizing

css 中的 **`box-sizing`** 属性定义了user-agent应该如何计算**一个元素的总宽度和总高度** 

##### 1、content-box  

content-box是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。

width/height=content

##### 2、border-box

border-box 告诉浏览器：**你想要设置的边框和内边距的值是包含在width内的**。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。

**border-box：内边距不会撑开盒子**

**border-box不包含margin**

width/height = content + border + paddding

#### box-shadow

##### 1.box-shadow参数解释

~~~
@1：inset

  有inset 则为内阴影，没有insert 则为外阴影，默认为外阴影。
 
@2：offset-x
 
 横向阴影的大小，正值阴影在右边，负值阴影在左边，0的时候阴影中盒子后面，看不见的，如果有blur-radius值会有模糊效果。
 
@3：offset-y
 
纵向阴影的大小，值同offset-x。
 
@4：blur-radius
 
阴影的模糊程度，值越大，阴影越模糊。
 
@5：spread-radius
 
 阴影的扩大缩小，正值时，阴影扩大；负值时，阴影缩小，默认为0，和盒子同样大。
 
box-shadow: 4px4px 21px 0 #D0D0D0;
~~~

#### textarea标签

textarea标签用于定义多行文本输入

##### 属性

###### rows属性

定义：**用于定义显示的行数**

值：**正整数**

###### cols属性

定义：**用于定义每行中的字符数**

值：**正整数**

#### JS中...的用法

##### 展开语法

  可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开，字面意思一般是指：[1,2,3]，{name:"mdn"}

###### 1.函数调用

~~~js
function sum(x, y) {
  return x * y;
}
const numbers = [1, 2];

console.log(sum(...numbers));
// 2

sum(...numbers)相当于 sum.apply(null,numbers)
~~~

###### 2.构造字面量数组

~~~
var arr1=[1,2];
var arr2=[...arr1,3,4];
console.log(arr2);
//[1,2,3,4]
~~~

###### 3.构造字面量字符串

~~~
var arr1=['a','b',...'cdef'];
console.log(arr1);
//['a','b','c','d','e','f']
~~~

###### 4.构造字面量对象

~~~
var obj1={a:1};
var obj2={b:2};
var obj3={...obj1,...obj2,c:3};
console.log(obj3);
//{a:1,b:2,c:3}
~~~

#### apply()

 apply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。 

注意：call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。
语法：func.apply(thisArg, [argsArray]) 

### Math常用方法

Math称之为数学函数，它也是对象数据类型的，主要是用来操作数字的

#### 1.Math.abs()求绝对值

#### 2.Math.ceil/Math.floor：向上取整、向下取整

向上取整，无论是正数还是负数，都取最大的值

向下取整，无论是正数还是负数，都取最小的值

~~~
Math.ceil(1.2)
2
Math.ceil(-1.6)
-1
 
Math.floor(1.8)
1
Math.floor(-1.1)
-2
~~~

#### 3.Math.round()：四舍五入

若为负数，则临界点必须大于5

~~~
Math.round(1.5)
2
Math.round(-1.5)
-1
Math.round(-1.51)
-2
~~~

#### 4.Math.sqrt()：开平方

##### 立方根

> <font color='red'>Math.cbrt</font>(2);//结果为8；

##### 自然对数

> <font color='red'>Math.log()</font>

#### 5.Math.pow(n,m)：取幂

n的m次幂

~~~
Math.pow(3,2)
9
~~~

#### 6.Math.PI：3.1415926...

#### 7.Math.max/Math.min：获取最大值和最小值

#### 8.Math.random()：获取0~1之间的随机数（大于等于0小于1）

##### 获取n到m之间的随机数：Math.random()*(m-n)+n

~~~
// 获取10到20之间的随机数
Math.random()*10+10
~~~



#### 查看本机IP：

打开cmd：输入 **ipconfig** ，即可查看本机IP

![1648026320220](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648026320220.png)

#### display：flex的相关属性

##### align-content属性

<font color='cornflowerblue'>作用：设置同一列子元素在Y轴的对齐方式</font>

- flex-start	排列在当前列的最上方
- flex-end	排列在当前列的最下方
- center	排列在当前列的中间位置
- space-between	间距相等排列，上下不留白
- space-around	间距相等排列，上下留白等于间距的一半

##### justify-content属性

<font color='cornflowerblue'>作用：设置同一行子元素在X轴的对齐方式</font>

- flex-start	排列在当前行的最左边
- flex-end	排列在当前行的最右边
- center	排列在当前行的中间位置
- space-between	间距相等排列，两边不留白
- space-around	间距相等排列，两边留白等于间距的一半

##### align-items属性

<font color='cornflowerblue'> 作用：设置同一行子元素在Y轴的对齐方式 </font>

- flex-start	排列在当前行的最上方
- flex-end	排列在当前行的最下方
- center	排列在当前行的中间位置
- stretch	当子元素没有设置高度或为auto,将占满整个容器的高度
- baseline	以子元素第一行文字的基线对齐
  

# JAVA--scanner类

#### 1、scanner简介

Scanner类是java.util包中的一个类

作用：常用于控制台的输入，**当需要使用控制台输入时即可调用这个类** 

#### 2、scanner用法

使用方法

1. 首先需要构造一个Scanner类的对象，并且与标准输入流System.in关联

   ~~~
   Scanner sc=new Scanner(System.in);
   ~~~

2. 调用Scanner类对象sc的方法从输入流中获取你需要的输入

说明：

- 当创建了一个Scanner类对象之后，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给对象sc，若要获取需要的内容，调用sc的方法即可

#### 3、scanner的常用方法

<font color='red'>1、nextInt()只读取数值，读取完后\n没有读取并且光标放在本行</font>

~~~
Scanner sc=new Scanner(System.in);
int i=sc.nextInt()；
~~~

**每次可以只输入一个数字，回车确认**；例如：“123”，只能被一个nextInt读取。

**也可以输入一组数字，**例如：“123 456 789”，每个数字之间用空格（一个或多个空格）隔开，**可被多个**

**nextInt()读取**，空格及回车不会被读取。

（注：输入数字中不能夹杂除数字、空格、回车之外的其他字符，否则会报错）

​								 ![img](https://img-blog.csdn.net/20180808095607276?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzgxNjQ2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

<font color='red'> 2、nextDouble()的用法同理nextInt()，注意：nextInt无法读取小数，否则会报错。</font> 

​        						 ![img](https://img-blog.csdn.net/20180808095637763?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzgxNjQ2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

同理nextByte()，nextFloat(),nextLong(),nextShot()，当某个方法读取的数字超过自身范围，则会报错。 

<font color='red'>3、next()方法遇到第一个扫描有效字符，即第一个非空格非换行符后面开始，一直获取到下一个空格，换行符之前的，单个字符串。</font> 

​								 ![img](https://img-blog.csdn.net/20180808095733439?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzgxNjQ2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

<font color='red'> 4、nextLine()可以扫描到一行内容(当前行，光标所在行的内容，包括空格、回车)并作为一个字符串而被获取到。</font>

 ![img](https://img-blog.csdn.net/20180808095808536?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3MzgxNjQ2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

# Git概述

## 1、Git和代码托管中心

代码托管中心是基于网络服务器的远程代码仓库，一般我们简单称为远程库。

1. 局域网

- GitLab

2. 互联网

- GitHub（外网）
- Gitee 码云（国内网站）

## 2、Git的基本使用

右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端。

![1648522204423](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648522204423.png)

在 Git Bash 终端里输入 git --version 查看 git 版本，如图所示，说明 Git 安装成功。

![1648522287913](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648522287913.png)

### Git常用命令

| 命令名称                                                 | 作用                                    |
| -------------------------------------------------------- | --------------------------------------- |
| git config --global user.name 用户名                     | 设置用户签名                            |
| git config --global user.email 邮箱                      | 设置用户签名                            |
| <font color='red'>git init</font>                        | <font color='red'>初始化本地库</font>   |
| <font color='red'>git status</font>                      | <font color='red'>查看本地库状态</font> |
| <font color='red'>git add 文件名</font>                  | <font color='red'>添加到暂存区</font>   |
| <font color='red'>git commit -m "日志信息" 文件名</font> | <font color='red'>提交到本地库</font>   |
| <font color='red'>git reflog</font>                      | <font color='red'>查看历史记录</font>   |
| <font color='red'>git reset --hard 版本号</font>         | <font color='red'>版本穿梭</font>       |

#### 1、设置用户签名

1、基本语法

- git config --global user.name 用户名
- git config --global user.email 邮箱

2、案例实操

全局范围的签名设置：

![1648523223276](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648523223276.png)

说明：

- 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。

注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。

#### 2、初始化本地库

<font color='red'>基本语法：</font>

~~~
git init
~~~

结果：

![1648523422966](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648523422966.png)

#### 3、查看本地库状态

1、基本语法：

~~~
git status
~~~

2、演示：

2.1 首次查看（ 工作区没有任何文件）

![1648523453042](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648523453042.png)

2.2 新增文件（hello.txt）

<img src="C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648527951700.png" alt="1648527951700" style="zoom:33%;" />

vim进入输入模式：i

vim退出输入模式：ESC

vim复制：yy

vim粘贴：p

2.3 再次查看

![1648541894657](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648541894657.png)

#### 4、添加暂存区

##### 1、将工作区的文件添加到暂存区

1、基本语法

~~~
git add 文件名
~~~

2、示例代码：

![1648542162529](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542162529.png)

3、查看状态：检测到暂存区有新文件

![1648542223203](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542223203.png)

#### 5、提交本地库

##### 1、将暂存区的文件提交到本地库

1、基本语法

~~~
git commit -m "日志信息" 文件名
~~~

2、示例代码：

![1648542365106](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542365106.png)

3、查看状态（没有文件需要提交）

![1648542410152](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542410152.png)

###### 修改文件

修改文件后查看状态，检测到工作区有文件被修改

![1648542608779](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542608779.png)

##### 2、将修改的文件再次添加暂存区

![1648542678602](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542678602.png)

#### 6、历史版本

1、基本语法

~~~
git reflog 查看版本信息
git log 查看版本详细信息
~~~

![1648542748734](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542748734.png)

#### 7、版本穿梭

1、基本语法

~~~
git reset --hard 版本号
~~~

2、案例实操

![1648542817538](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542817538.png)

## 3、Git分支操作

![1648542857809](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648542857809.png)

#### 1、分支的概述

在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味

着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于

初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）

#### 2、分支的好处

同时并行推进多个功能开发，提高开发效率。各个分支在开发过程中，如果某一个分支开发失败，不会对其

他分支有任何影响。失败的分支删除重新开始即可。

#### 3、分支常用命令

| 命令名称            | 作用                         |
| ------------------- | ---------------------------- |
| git branch 分支名   | 创建分支                     |
| git branch -v       | 查看分支                     |
| git checkout 分支名 | 切换分支                     |
| git merge 分支名    | 把指定的分支合并到当前分支上 |

##### 1、查看分支

1、基本语法

~~~
git branch -v
~~~

2、示例代码：

![1648543170913](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543170913.png)

##### 2、创建分支

1、基本语法

~~~
git branch 分支名
~~~

2、示例代码：

![1648543249526](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543249526.png)

<font color='red'>（刚创建的新的分支，并将主分支 master
的内容复制了一份）</font>

##### 3、修改分支

![1648543308891](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543308891.png)

![1648543321966](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543321966.png)

##### 4、切换分支

1、基本语法

~~~
git checkout 分支名
~~~

2、示例代码

![1648543404941](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543404941.png)

##### 5、合并分支

1、基本语法

~~~
git merge 分支名
~~~

2、示例代码--在 master 分支上合并 hot-fix 分支

![1648543572510](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543572510.png)

3、产生冲突 <font color='orange'>冲突产生的表现：后面状态为 MERGING</font>

![1648543612000](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543612000.png)

冲突产生的原因：

- 合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须人为决定新代码内容。

查看状态（检测到有文件有两处修改）

![1648543655280](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543655280.png)

##### 6、解决冲突

**1、编辑有冲突的文件，删除特殊符号，决定要使用的内容**

![1648543696233](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543696233.png)

**2、添加到暂存区**

![1648543740474](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543740474.png)

**3、执行提交**

![1648543771129](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543771129.png)

#### 创建分支和切换分支的图解：

![1648543815974](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543815974.png)

master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD决定的。所以创建分

支的本质就是多创建一个指针。HEAD 如果指向 master，那么我们现在就在 master 分支上。HEAD 如果执行 

hotfix，那么我们现在就在 hotfix 分支上。

## 4、Git团队协作

#### 1、团队内协作

#### ![1648543878639](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543878639.png)2、跨团队协作

![1648543917530](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648543917530.png)

# GitHub操作

GitHub 网址：https://github.com/

#### 解决GitHub浏览网站速度慢的方法：

修改hosts： Windows 系统中的文件路径：`C:\WINDOWS\system32\drivers\etc` 

~~~
140.82.114.3 github.com
199.232.69.194 github.global.ssl.fastly.net
185.199.108.153 assets-cdn.github.com
185.199.109.153 assets-cdn.github.com
185.199.110.153 assets-cdn.github.com
185.199.111.153 assets-cdn.github.com
2606:50c0:8000::153 assets-cdn.github.com
2606:50c0:8001::153 assets-cdn.github.com
2606:50c0:8002::153 assets-cdn.github.com
2606:50c0:8003::153 assets-cdn.github.com
~~~

完成后，刷新DNS（域名服务器）缓存：

![1648545304149](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648545304149.png)

## 1、创建远程仓库

![1648550443941](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648550443941.png)

![1648550587641](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648550587641.png)

创建成功页面：

![1648550636280](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648550636280.png)

## 2、远程仓库操作

| 命令名称                                                    | 作用                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| git remote -v                                               | 查看当前所有远程地址别名                                     |
| git remote add 别名 远程地址                                | 起别名                                                       |
| <font color='red'>git push 别名 分支</font>                 | <font color='red'>推送本地分支上的内容到远程仓库</font>      |
| <font color='red'>git clone 远程地址</font>                 | <font color='red'>将远程仓库的内容克隆到本地</font>          |
| <font color='red'>git pull 远程库地址别名 远程分支名</font> | <font color='red'>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</font> |

### 2.1 创建远程仓库别名

1、基本语法

~~~
git remote -v 查看当前所有远程地址别名
git remote add 别名 远程地址
~~~

2、示例代码：

![1648551099765](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648551099765.png)

3、查看当前所有远程地址别名

![1648551133365](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648551133365.png)

### 2.2 推送本地分支到远程仓库

1、基本语法

~~~
git push 别名 分支
~~~

2、示例代码：

![1648554818711](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648554818711.png)

此时，master分支上的内容已推送到GitHub创建的远程仓库中：

![1648554918275](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648554918275.png)

### 2.3 拉取远程库到本地库

在远程仓库中修改代码：

![1648555122506](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648555122506.png)

1、基本语法

~~~
git pull 远程库地址别名 远程分支名
~~~

![1648555418141](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648555418141.png)

**查看文件：**<font color='red'>cat 文件名.后缀</font>

![1648555466327](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648555466327.png)

### 2.4 克隆远程仓库到本地

1、基本语法

~~~
git clone 远程地址
~~~

2、示例代码：

![1648556873320](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648556873320.png)

![1648556885604](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648556885604.png)

clone 会做如下操作。1、拉取代码。2、初始化本地仓库。3、创建别名

## 3、邀请团队成员

1、选择邀请合作者

![1648557378624](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557378624.png)

2、填入想合作的人

![1648557402992](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557402992.png)

3、复制地址并发送给成员：

![1648557431121](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557431121.png)

4、在 atguigulinghuchong 这个账号 中的地址栏复制收到邀请的链接 ，点击接受邀请。

![1648557489781](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557489781.png)

5、成功之后可以在账号上看到 git-test的远程仓库

![1648557529762](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557529762.png)

5、新加入的成员可以修改内容并push到远程仓库

## 4、跨团队协作

1、将远程仓库的地址复制发给邀请跨团队协作的人，如东方不败

![1648557701964](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557701964.png)

2、在东方不败的 GitHub 账号里的地址栏复制收到的链接，然后点击 Fork 将项目叉到自己的本地仓库

![1648557753060](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557753060.png)

插入中

![1648557766306](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557766306.png)

![1648557777123](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557777123.png)

3、东方不败就可以在线编辑拉去过来的文件

![1648557811798](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557811798.png)

![1648557819797](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557819797.png)

6、编辑完毕后，填写描述信息并点击左下角绿色按钮提交。

![1648557841129](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557841129.png)

7、**接下来点击上方的 Pull 请求，并创建一个新的请求**

![1648557872389](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557872389.png)

![1648557880769](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557880769.png)

![1648557890767](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557890767.png)

8、回到岳岳 GitHub 账号可以看到有一个 Pull request 请求

![1648557911914](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557911914.png)

![1648557918483](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557918483.png)

进入到聊天室，可以讨论代码相关内容。

![1648557935201](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557935201.png)

![1648557941488](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557941488.png)

9、如果代码没有问题，可以点击 Merge pull reque 合并代码。

![1648557965513](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557965513.png)

![1648557971137](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648557971137.png)

### SSH 免密登录

**远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 进行访问。**

![1648558007368](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648558007368.png)

#### 生成SSH密匙：

![1648558023664](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648558023664.png)

![1648558057360](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648558057360.png)

![1648558088759](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648558088759.png)

![1648558096487](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648558096487.png)

![1648558104730](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648558104730.png)

# 国内代码托管中心- 码云

码云是开源中国推出的基于 Git 的代码托管服务中心，网址是 https://gitee.com/ ，使用方式跟 GitHub 一样，

而且它还是一个中文网站，如果你英文不是很好它是最好的选择

## 1、码云帐号注册和登录

进入码云官网地址：https://gitee.com/，点击注册 Gitee

![1648559240885](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559240885.png)

新建仓库：

![1648559276825](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559276825.png)

创建分支：

![1648559294466](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559294466.png)

远程库创建好后，可以查看https和ssh链接：

![1648559324092](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559324092.png)

## 码云复制 GitHub 项目

![1648559473011](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559473011.png)

将 GitHub 的远程库 HTTPS 链接复制过来，点击创建按钮即可。

![1648559511246](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559511246.png)

导入成功后：

![1648559560018](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559560018.png)

刷新，更新代码：

![1648559623226](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648559623226.png)

# GitLab-自建代码托管平台

GitLab 是由 GitLabInc.开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有wiki 和 issue 跟踪功

能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务

#### 1、GitLab 官网地址

官网地址：https://about.gitlab.com/

安装说明：https://about.gitlab.cn/installation/

## 正则表达式

#### 1、概述

正则表达式（Regular Expression）是用于描述一组字符串特征的模式，用来匹配特定的字符串。通过特殊字

符+普通字符来进行模式描述，从而达到文本匹配目的工具。 

#### 2、应用场景

（1）验证：表单提交时，进行用户名密码的验证。

（2）查找：从大量信息中快速提取指定内容，在一批url中，查找指定url。

（3）替换：将指定格式的文本进行正则匹配查找，找到之后进行特定替换。

#### 3、基本要素

（1）字符类

（2）数量限定符

（3）位置限定符

（4）特殊符号

##### 1、字符串类

 ![img](https://img-blog.csdn.net/2018070616184021?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

##### 2、数量限定符

 ![img](https://img-blog.csdn.net/20180706172035936?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

##### 3、位置限定符

 ![img](https://img-blog.csdn.net/20180706180119741?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

##### 4、特殊符号

 ![img](https://img-blog.csdn.net/20180708091045106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

##### 5、其他普通字符集及其替换

 ![img](https://img-blog.csdn.net/20180708095339761?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXJyeWRyZWFtc292ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

#### 4、正则表达式分类

（1）基本正则表达式：Basic即BPEs

（2）扩展正则表达式：Extended即EREs

（3）Perl的正则表达式：PREs

#### 5、 贪婪模式与非贪婪模式 

1. 贪婪模式：正则表达式匹配时，会尽量多的匹配符合条件的内容 
2. 非贪婪模式：正则表达式匹配时，会尽量少的匹配符合条件的内容，也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去（除非有g，开启下一组匹配） 

# Arrays类

 **Arrays类位于 java.util 包中，主要包含了操作数组的各种方法。** 

~~~
import java.util.Arrays;
~~~

### 常用方法

#### 1、Arrays.fill()

填充数组

将指定值分配给指定数组的每个元素 

#### 2、Arrays.sort()

数组排序

#### 3、Arrays.toString()

将数组中的内容全部打印出来

 **返回数组的字符串形式** 

#### 4、Arrays.equals()

比较数组元素是否相等

#### 5、 **Arrays.binarySearch(); **

二分查找法找指定元素的索引值（下标）

#### 6、 **Arrays.copeOf() 和Arrays.copeOfRange()**

截取数组

**Arrays.copyOf(arr,i)：arr表示要截取的数组，i表示要截取的元素个数，也表示新数组的长度**

#### 7、Arrays.asList()

数组转化为List

~~~
List<String> list = new ArrayList<String>(Arrays.asList(s));
~~~

# Java自带的格式化时间的包

#### simpleDateFormat

```
Date date = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:S");//设置日期格式
String datestr = df.format(date);
System.out.println(datestr);
```

~~~
2020-06-07 16:45:58:507
~~~

模式：

> yyyy：年
> MM：月
> dd：日
> hh：1~12小时制(1-12)
> HH：24小时制(0-23)
> mm：分
> ss：秒
> S：毫秒
> E：星期几
> D：一年中的第几天
> F：一月中的第几个星期(会把这个月总共过的天数除以7)
> w：一年中的第几个星期
> W：一月中的第几星期(会根据实际情况来算)
> a：上下午标识
> k：和HH差不多，表示一天24小时制(1-24)。
> K：和hh差不多，表示一天12小时制(0-11)。
> z：表示时区

# 数组

数组是构造数据类型之一

数组：有序数据的集合，用数组名标识

元素：属同一数据类型，用数组名和下标确定

## 1、一维数组

#### 1、定义

 ![img](https://img-blog.csdnimg.cn/2019012221033046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

**例：int a[6]**

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122210520339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

#### 2、一维数组的引用

1、数组必须<font color='red'>先定义，后使用</font>

2、只能逐个引用数组元素，不能一次引用整个数组

3、数组元素标识形式：<font color='red'>数组名[下标]</font>，<font color='blue'>下标可以是常量或整形表达式</font>

#### 3、一维数组的初始化

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211041317.png) 

<font color='red'>说明：</font>

1、数组不初始化，其元素值为随机数

2、对static数组元素不赋初值，系统会自动赋以0值

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211258194.png) 

3、只给部分数组元素赋初值

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211316573.png) 

4、当全部数组元素赋初值时，可不指定数组长度

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211312528.png) 

**举例：**

1、读10个整数存入数组，找出其中最大值和最小值

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211401699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

~~~
#include <stdio.h>
#define SIZE 10
main()
{   int x[SIZE],i,max,min;
    printf("Enter 10 integers:\n");
    for(i=0;i<SIZE;i++)
    {   printf("%d:",i+1);
	scanf("%d",&x[i]);
    }
    max=min=x[0];
    for(i=1;i<SIZE;i++)
    {  if(max<x[i])  max=x[i];
       if(min>x[i])  min=x[i];
    }
    printf("Maximum value is %d\n",max);
    printf("Minimum value is %d\n",min);
}
~~~

2、用数组求Fibonacci数列前20个数

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211616598.png) 

~~~
#include <stdio.h>
main()
{   int i;
     int f[20]={1,1};
    for(i=2;i<20;i++)
       f[i]=f[i-2]+f[i-1];
    for(i=0;i<20;i++)
    {   if(i%5==0)  printf("\n");
         printf("%12d",f[i]);
    }
}
~~~

3、用冒泡排序对10个数排序

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211744453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211751694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

~~~
#include <stdio.h>
main()
{   int a[11],i,j,t;
    printf("Input 10 numbers:\n");
    for(i=1;i<11;i++)
       scanf("%d",&a[i]);
    printf("\n");
    for(j=1;j<=9;j++)
       for(i=1;i<=10-j;i++)
          if(a[i]>a[i+1])
         {t=a[i]; a[i]=a[i+1]; a[i+1]=t;}
    printf("The sorted numbers:\n");
    for(i=1;i<11;i++)
	printf("%d ",a[i]);
}
~~~

4、用简单选择法对10个数进行排序

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122211908780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122212012798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

~~~
#include <stdio.h>  
main()
{   int a[11],i,j,k,x;
    printf("Input 10 numbers:\n");
    for(i=1;i<11;i++)
       scanf("%d",&a[i]);
    printf("\n");
   for(i=1;i<10;i++)
   {  k=i;
      for(j=i+1;j<=10;j++)
            if(a[j]<a[k])  k=j;
      if(i!=k)
      {  x=a[i]; a[i]=a[k]; a[k]=x;}
   }
    printf("The sorted numbers:\n");
    for(i=1;i<11;i++)
	printf("%d ",a[i]);
}
~~~

## 二维数组

#### 1、定义

 ![img](https://img-blog.csdnimg.cn/20190122212229408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122212422750.png) 

**数组元素的存放顺序：**

1. 原因：内存是一维的
2. 二维数组：按行序优先
3. 多维数组：最右下标变化最快

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122212505901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

**<font color='red'>数组a[m][n],m行n列，共m*n个元素</font>**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122212850832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

> 这些元素占用m*n个单元，每个单元的大小取决于元素的类型。
>
> 任意元素a[i][j]在数组中的位置计算公式为：
>
> **i×n＋j （从0开始）**
>
> a——数组的起始地址；a[0]——0行0列元素的地址。

#### 2、二维数组元素的引用

形式：**数组名[下标][下标]**

#### 3、二维数组元素的初始化

1. 分行初始化
2. 按元素排列顺序初始化

#### 4、举例

 **例1：将二维数组行列元素互换，存到另一个数组中** 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019012221350429.png) 

~~~
#include <stdio.h>
main()
{   int a[2][3]={{1,2,3},{4,5,6}};
     int b[3][2],i,j;
    printf("array a:\n");
    for(i=0;i<=1;i++)
    {   for(j=0;j<=2;j++)
	{   printf("%5d",a[i][j]);
	    b[j][i]=a[i][j];
	}
	printf("\n");
    }    
    printf("array b:\n");
    for(i=0;i<=2;i++)
    {   for(j=0;j<=1;j++)
	   printf("%5d",b[i][j]);
         printf("\n");
    }
}
~~~

 **例2：求二维数组中最大元素值及其行列号** 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122213751557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

~~~
/*示例2*/
#include <stdio.h>
main()
{  int a[3][4]={{1,2,3,4},
                        {9,8,7,6},
                        {-10,10,-5,2}};
    int i,j,row=0,colum=0,max;
    max=a[0][0];
    for(i=0;i<=2;i++)
       for(j=0;j<=3;j++)
           if(a[i][j]>max)
	  {  max=a[i][j];
	     row=i;
	     colum=j;
	  }
    printf("max=%d,row=%d,\colum=%d\n",max,row,colum);
}
~~~

 **例3：分别求n阶方阵两条对角线上的元素之和** 

~~~
/*示例3*/
#define N 3
main()
{   int i,j,a[N][N];
int sum1=0,sum2=0;
for(i=0;i<N;i++)
  for(j=0;j<N;j++)
    scanf(“%d”,&a[i][j]);
for(i=0;i<N;i++)
  for(j=0;j<N;j++)
    if(i==j) sum1+=a[i][j];
for(i=0;i<N;i++)
  for(j=N-1;j>=0;j--)
    if((i+j)==N-1) sum2+=a[i][j];
printf(“sum1=%d,sum2=%d\n”,sum1,sum2);
}
~~~

## 字符数组和字符串

### 1、字符数组

#### 1、定义

每个元素存一个字符，主要用来对字符串操作

#### 2、字符数组的初始化

1. 逐个字符赋值
2. 用字符串常量

#### 3、字符数组的引用

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122214453836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122214520310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190122214550237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

## 2、字符串

#### 1、字符串及其结束标志

> （1）无字符串变量，用字符数组处理字符串。
> （2）字符串结束标志：‘\0’。

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190123194751180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

#### 2、字符串的输入输出

##### 1、输入

> - 用scanf函数
>   （1）.输入单个字符：％c 需用循环语句
>   （2）.输入字符串：%s scanf(“%s”,str);
> - 用gets函数：gets(str);

##### 2、输出

> - 用printf函数
>   （1）.输出单个字符：％c 需用循环语句
>   （2）.输出字符串：%s printf(“%s”,str);
> - 用puts函数：puts(str);

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190123195109337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzdWZ0MjAxNjQ0NDI=,size_16,color_FFFFFF,t_70) 

#### 3、常用的字符串处理函数

##### 1、字符串输出函数puts** 

> **格式：** puts(字符数组)
> **功能：** 向显示器输出字符串（输出完，换行）
> **说明：** 字符数组必须以‘\0’结束 

##### 2、字符串输入函数gets** 

> **格式：** gets(字符数组)
> **功能：** 从键盘输入一以回车结束的字符串放入字符数组中，并自动加‘\0’
> **说明：** 输入串长度应小于字符数组维数 

##### 3、字符串连接函数strcat

> **格式：** strcat(字符数组1,字符数组2)
> **功能：** 把字符数组2连到字符数组1后面
> **返值：** 返回字符数组1的首地址
> **说明：**
> 1、字符数组1必须足够大
> 2、连接前,两串均以‘\0’结束;连接后,串1的‘\0’取消, 新串最后加‘\0’ 

##### 4、字符串拷贝函数strcpy

> **格式：** strcpy(字符数组1,字符串2)
> **功能：** 将字符串2，拷贝到字符数组1中去
> **返值：** 返回字符数组1的首地址
> **说明：**
> 1、字符数组1必须足够大
> 2、拷贝时‘\0’一同拷贝
> 3、不能使用赋值语句为一个字符数组赋值 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190123195618319.png) 

##### 5、字符串比较函数strcmp

> 格式： strcmp(字符串1,字符串2)
> 功能： 比较两个字符串
> 比较规则： 对两串从左向右逐个字符比较（ASCII码），直到遇到不同字符或‘\0’为止
> 返值： 返回int型整数，
>
> - 若字符串1< 字符串2， 返回负整数
> - 若字符串1> 字符串2， 返回正整数
> - 若字符串1== 字符串2， 返回零
>
> 说明： 字符串比较不能用“==”,必须用strcmp

##### 6、字符串长度函数strlen

> 格式：strlen(字符数组)
> 功能：计算字符串长度
> 返值：返回字符串实际长度，不包括‘\0’在内 

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190123200015105.png) 



# List集合

List集合主要有三个有子类：

- ArrayList

  底层数据结构是数组。线程不安全

- LinkedList

  底层数据结构是链表。线程不安全

- Vector

  底层数据结构是数组。线程安全



## ArrayList--集合

#### 1、定义

 集合又称为容器，用于存储、提取、删除数据。JDK提供的集合API都包含在 java.util 包内。 实现了List接口。

#### 2、集合的分支

 集合框架两大分支：**Collection接口和Map接口** 

##### 1、Collection接口

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190808105343345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9fYV9ydW9feWE=,size_16,color_FFFFFF,t_70) 

##### 2、Map接口

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190808105536271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9fYV9ydW9feWE=,size_16,color_FFFFFF,t_70) 

### 3、常用方法

1、<font color='red'>add(Object element)：</font>向列表的尾部添加指定的元素。

2、<font color='red'>size()：</font> 返回列表中的元素个数。

3、<font color='red'>get(int index)：</font> 返回列表中指定位置的元素，index从0开始。

4、<font color='red'>add(int index, Object element)：</font> 在列表的指定位置插入指定元素。

5、<font color='red'>set(int i, Object element)：</font> 将索引i位置元素替换为元素element并返回被替换的元素。

6、<font color='red'>clear()：</font> 从列表中移除所有元素。

7、<font color='red'>isEmpty()：</font> 判断列表是否包含元素，不包含元素则返回 true，否则返回false。

8、<font color='red'> contains(Object o)：  </font>如果列表包含指定的元素，则返回 true。

9、<font color='red'> remove(int index)： </font> 移除列表中指定位置的元素，并返回被删元素。

10、<font color='red'>remove(Object o)：</font> 移除集合中第一次出现的指定元素，移除成功返回true，否则返回false。

11、<font color='red'>iterator()：</font> 返回按适当顺序在列表的元素上进行迭代的迭代器。

#### String[]转为List

> String[] s;
>
> List<String> list = Arrays.asList(s);

## LinkedList

LinkedList就是数据结构中的链表，有以下特点：

- 分配内存空间不是必须是连续的；
- 插入、删除操作很快，只要修改前后指针就OK了，时间复杂度为O(1)；
- 访问比较慢，必须得从第一个元素开始遍历，时间复杂度为O(n)；

### 常用方法

#### 1、add相关

- boolean <font color='red'>add(e)</font>：在链表后添加一个元素，如果成功，返回true，否则返回false；
- void <font color='red'>addFirst(e)：</font>在链表头部插入一个元素；
- <font color='red'>addLast(e)：</font>在链表尾部添加一个元素；
- void<font color='red'>  add(int index, E element)： </font>在指定位置插入一个元素。

示例代码

~~~
public class LinkedListMethodsDemo {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();

        linkedList.add("first");
        linkedList.add("second");
        linkedList.add("third");
        System.out.println(linkedList);

        linkedList.addFirst("addFirst");
        System.out.println(linkedList);

        linkedList.addLast("addLast");
        System.out.println(linkedList);

        linkedList.add(2, "addByIndex");
        System.out.println(linkedList);
    }
}
~~~

输出：

~~~
[first, second, third]
[addFirst, first, second, third]
[addFirst, first, second, third, addLast]
[addFirst, first, addByIndex, second, third, addLast]
~~~

#### 2、remove相关

- E <font color='orange'>remove()</font>；移除链表中第一个元素；
- boolean <font color='orange'>remove(Object o)</font>：移除链表中指定的元素；
- E <font color='orange'> remove(int index) </font>：移除链表中指定位置的元素；
- E <font color='orange'>removeFirst()</font>：移除链表中第一个元素，与remove类似；
- E <font color='orange'>removeLast()</font>：移除链表中最后一个元素；
- boolean <font color='orange'>removeFirstOccurrence(Object o)</font>：移除链表中第一次出现所在位置的元素；
- boolean <font color='orange'>removeLastOccurrence(Object o)</font>：移除链表中最后一次出现所在位置的元素；

示例代码：

~~~
public class LinkedListMethodsDemo {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();

        linkedList.add("first");
        linkedList.add("second");
        linkedList.add("second");
        linkedList.add("third");
        linkedList.add("four");
        linkedList.add("five");
        System.out.println(linkedList);

        linkedList.remove();
        System.out.println("remove: " + linkedList);

        linkedList.remove("second");
        System.out.println("remove(Object): " + linkedList);

        linkedList.remove("six");
        System.out.println("remove(Object) not exist: " + linkedList);

        linkedList.remove(2);
        System.out.println("remove(index): " + linkedList);

        linkedList.removeFirst();
        System.out.println("removeFirst: " + linkedList);

        linkedList.removeLast();
        System.out.println("removeLast:" + linkedList);

        System.out.println("----------------------------------");
        linkedList.clear();

        linkedList.add("first");
        linkedList.add("second");
        linkedList.add("first");
        linkedList.add("third");
        linkedList.add("first");
        linkedList.add("five");
        System.out.println(linkedList);

        linkedList.removeFirstOccurrence("first");
        System.out.println("removeFirstOccurrence: " + linkedList);

        linkedList.removeLastOccurrence("first");
        System.out.println("removeLastOccurrence: " + linkedList);
    }
}
~~~

输出：

~~~
[first, second, second, third, four, five]
remove: [second, second, third, four, five]
remove(Object): [second, third, four, five]
remove(Object) not exist: [second, third, four, five]
remove(index): [second, third, five]
removeFirst: [third, five]
removeLast:[third]
----------------------------------
[first, second, first, third, first, five]
removeFirstOccurrence: [second, first, third, first, five]
removeLastOccurrence: [second, first, third, five]
~~~

#### 3、get相关

<font color='green'>get(int index)：</font>按照下标获取元素；

<font color='green'>getFirst()：</font>获取第一个元素；

<font color='green'> getLast()： </font>获取最后一个元素

示例代码：

~~~
public class LinkedListMethodsDemo {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();

        linkedList.add("first");
        linkedList.add("second");
        linkedList.add("second");
        linkedList.add("third");
        linkedList.add("four");
        linkedList.add("five");
        System.out.println(linkedList);

        linkedList.get(3);
        System.out.println("get(index): " + linkedList.get(3));

        linkedList.getFirst();
        System.out.println("getFirst: " + linkedList.getFirst());

        linkedList.getLast();
        System.out.println("getLast: " + linkedList.getLast());

        System.out.println(linkedList);
    }
}
~~~

输出：

~~~
[first, second, second, third, four, five]
get(index): third
getFirst: first
getLast: five
[first, second, second, third, four, five]
~~~

**链表前后未发生变化**

#### 4、push、pop、pull

void <font color='blue'>push(E e)：</font>与addFirst一样，实际上它就是addFirst；

E <font color='blue'>pop()：</font>与removeFirst一样，实际上它就是removeFirst；

E<font color='blue'> poll()：</font>查询并移除第一个元素； 

示例代码：

~~~
public class LinkedListMethodsDemo {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();

        linkedList.push("first");
        linkedList.push("second");
        linkedList.push("second");
        linkedList.push("third");
        linkedList.push("four");
        linkedList.push("five");
        System.out.println("linkedList: " + linkedList);

        System.out.println("pop: " + linkedList.pop());
        System.out.println("after pop: " + linkedList);

        System.out.println("poll: " + linkedList.poll());
        System.out.println("after poll: " + linkedList);
    }
}
~~~

输出：

~~~
linkedList: [five, four, third, second, second, first]
pop: five
after pop: [four, third, second, second, first]
poll: four
after poll: [third, second, second, first]
~~~

**如果链表为空的时候， poll返回null，而pop则产生异常 **

#### 5、peek相关

E <font color='green'>peek()：</font>获取第一个元素，但是不移除；即检索链表头部元素，如链表为空则返回null；

E<font color='green'> peekFirst()：</font>获取第一个元素，但是不移除；

E<font color='green'> peekLast()：</font>获取最后一个元素，但是不移除； 

示例代码：

~~~
public class LinkedListMethodsDemo {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();

        linkedList.push("first");
        linkedList.push("second");
        linkedList.push("second");
        linkedList.push("third");
        linkedList.push("four");
        linkedList.push("five");
        System.out.println("linkedList: " + linkedList);

        System.out.println("peek: " + linkedList.peek());
        System.out.println("peekFirst: " + linkedList.peekFirst());
        System.out.println("peekLast: " + linkedList.peekLast());

        System.out.println("linkedList: " + linkedList);
    }
}
~~~

输出：

~~~
linkedList: [five, four, third, second, second, first]
peek: five
peekFirst: five
peekLast: first
linkedList: [five, four, third, second, second, first]
~~~

#### 6、offer相关

boolean <font color='red'>offer(E e)：</font>在链表尾部插入一个元素；

boolean<font color='red'> offerFirst(E e)：</font>与addFirst一样，实际上它就是addFirst；

boolean <font color='red'>offerLast(E e)：</font>与addLast一样，实际上它就是addLast； 

示例代码：

~~~
public class LinkedListMethodsDemo {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();

        linkedList.push("first");
        linkedList.push("second");
        linkedList.push("second");
        linkedList.push("third");
        linkedList.push("four");
        linkedList.push("five");
        System.out.println("linkedList: " + linkedList);

        linkedList.offer("six");
        System.out.println("linkedList: " + linkedList);

        linkedList.offerFirst("zero");
        System.out.println("linkedList: " + linkedList);

        linkedList.offerLast("seven");
        System.out.println("linkedList: " + linkedList);
    }
}
~~~

输出：

~~~
linkedList: [five, four, third, second, second, first]
linkedList: [five, four, third, second, second, first, six]
linkedList: [zero, five, four, third, second, second, first, six]
linkedList: [zero, five, four, third, second, second, first, six, seven]
~~~

#### 其他方法

> ```
> int indexOf(Object element) 
> ```
>
> - 返回节点对象element在链表中首次出现的位置，如果链表中无此节点的对象则返回-1
>
> ```
> public int lastIndexOf(Object element)
> ```
>
> - 返回节点对象element在链表中最后出现的位置，如果链表中无此节点的对象则返回-1
>
> ```
> public Object set(int index,Object element)
> ```
>
> - 将当前链表index位置节点中的对象替换成参数element指定的对象，返回被替换对象
>
> ```
> public int size()
> ```
>
> - 返回链表的长度即节点个数
>
> ```
> public boolean contains(Object element)
> ```
>
> - 判断链表节点对象中是否含有element

##### 总结：只有set方法会改变原链表，其他方法均不会

# Object类的toString方法

~~~
public String toString()
返回该对象的字符串表示。通常，toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。 
Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于： 

getClass().getName() + '@' + Integer.toHexString(hashCode())
 
返回：
该对象的字符串表示形式。
~~~

# label标签

<font color='green'>作用： 标签用于绑定一个表单元素，当点击标签内的文本时，浏览器就会自动将焦点转到或者选择对应的表单元素上。</font>

**语法：**

~~~
<form action="#" method="POST">
    <label for="name">用户名: </label>
    <input type="text" name="username" id="name">
</form>
~~~

**标签的for属性应当与相关元素的id属性相同**

# table表格

 表格是由行和列排列而成的一种结构 

 ![img](https://img-blog.csdnimg.cn/20190517150835744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzgx,size_16,color_FFFFFF,t_70) 

> HTML表格由table标签以及一个或多个tr、th或td标签组成：
>
> table标签用来定义表格，整个表格包含在<table>和</table>标签中；
>
> tr标签用来定义表格中一个行，它是单元格的容器，每行可以包含有多个单元格，由<tr>和</tr>标签表示；
>
> td标签和th标签用来定义单元格，所有单元格都在tr标签内，每个单元格由一对<td>和</td>标签或一对<th>和</th>标签表示，具体的表格内容放置在这一对td标签或th标签之中，其中th标签中的内容默认以粗体、居中的方式显示。其语法如下：

~~~
<table>
    <tr>
        <th>1行1列的内容</th>
        <th>1行2列的内容</th>
        …
    </tr>
    <tr>
        <td>2行1列的内容</td>
        <td>2行2列的内容</td>
        …
    </tr>
    …
</table>
~~~

>  <table是<tr的上层标签
> <tr必须在一个<table</table里面,它不能单独使用,相当于<table的属性标签.
> <table标示一个表格,<tr标示这个表格中间的一个行，<td、<th标示行中的一个列,需要嵌套在<tr</tr中间。 

### 表格标题caption

~~~
<table>
   <caption>我是表格标题</caption>
</table>
~~~

## table标签属性

![1648972475530](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648972475530.png)

border：设定围绕表格的边框

width：表格的宽度

border-spacing：设置外边框与单元格边框是否分离。若不分离，则设置为0

![1648972677473](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1648972677473.png)

~~~
	<style>
			table{
				border-spacing: 0;
				width: 50%;
				border: 1px solid black;
			}
			
			td{
				border: 1px solid black;
			}
	</style>
~~~

 ![结果](https://img-blog.csdnimg.cn/20190517130003992.png) 

border-collapse：设置为0，则表格边框=单元格边框+外边框的宽度之和。

> 1. separate：默认值，边框会被分开，不会忽略border-sapcing和empty-cells属性
> 2. collapse：边框会合并为一个单一的边框，会忽略border-sapcing和empty-cells属性
> 3. inherit：规定应从父元素继承border-collapse属性

### tr标签属性

height：设置一行的高度

background-color：设置一行的背景颜色

text-align：设置表格每行的对齐方式

~~~
		<style>
			table{
				border: 1px solid black;
				width: 50%;
				margin: 0 auto;
				border-spacing: 0;
				border-collapse: collapse;
				
			}
			
			tr{
				height: 50px;
				background-color:aquamarine ;
				text-align: center;
			}
			
			td{
				border: 1px solid black;
			}
		</style>
~~~

![结果](https://img-blog.csdnimg.cn/2019051713171881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzAyOTM5,size_16,color_FFFFFF,t_70) 

vertical-align：设置文本的位置（top、center、bottom）

## td标签

**跨行合并：rowspan    跨列合并：colspan** 

### 合并单元格

合并行单元格：rowspan

合并第二行和第三行的第一列单元格 ：

~~~
	<body>
		<table>
			<tr>
				<td>1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td rowspan="2">1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
		</table>
	</body>
~~~

![结果](https://img-blog.csdnimg.cn/20190517132453437.png) 

合并列单元格：colspan

合并第一行的三列单元格：

 ~~~
	<body>
		<table>
			<tr>
				<td colspan="3">1</td>
			</tr>
			<tr>
				<td rowspan="2">1</td>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
		</table>
	</body>
 ~~~

![结果](https://img-blog.csdnimg.cn/20190517132804556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzAyOTM5,size_16,color_FFFFFF,t_70) 

# jQuery动态append添加元素click点击事件失效

> 原因：append中的节点是在整个文档加载完之后开始添加，页面不会为append的元素初始化添加点击事件，故使用这种方式动态添加的节点中的click事件没有生效。
>
> 解决方案：事件委托方式解决，将指定的事件绑定在document上，只要append元素符合指定的元素，就会绑定此事件 。

示例代码：

~~~
$(document).on("click","指定的元素选择器",function(){
 
});
~~~

# JSON

> 1. JSON，全称是 JavaScript Object Notation，即 JavaScript对象标记法。
> 2. JSON是一种轻量级（Light-Meight)、基于文本的(Text-Based)、可读的(Human-Readable)格式。
> 3. JSON 的名称中虽然带有JavaScript，但这是指其语法规则是参考JavaScript对象的，而不是指只能用于JavaScript 语言。
> 4. JSON无论对于人，还是对于机器来说，都是十分便于阅读和书写的，而且相比 XML(另一种常见的数据交换格式)，文件更小，因此迅速成为网络上十分流行的交换格式。
> 5. 因为JSON本身就是参考JavaScript 对象的规则定义的，其语法与JavaScript定义对象的语法几乎完全相同。
>    JSON格式的创始人声称此格式永远不升级，这就表示这种格式具有长时间的稳定性，10 年前写的文件，10年后也能用，没有任何兼容性问题。

## JSON语法规则

- 数组（Array）用方括号(“`[]`”)表示。
- 对象（0bject）用大括号(“`{}`”)表示。
- 名称/值对(`name/value`）组合成数组和对象。
- 名称(`name`）置于**双引号**中，值（`value`）有**字符串、数值、布尔值、null、对象和数组**。
- 并列的数据之间用逗号(“`,`”）分隔

~~~
{
	"name": "xdr630",
	"favorite": "programming"
}
~~~

### JSON和XML

json

~~~
{
	"name":"兮动人",
	"age":22,
	"fruits":["apple","pear","grape"]
}
~~~

xml

~~~
<root>
	<name>兮动人</name>
	<age>22</age>
	<fruits>apple</fruits>
	<fruits>pear</fruits>
	<fruits>grape</fruits>
</root>
~~~

# JSON的解析和生成（JSON 和 JS 对象互转）

 `JSON.parse`和 `JSON.stringify` 

JSON和js对象互相转换：

1、从JSON字符串转换为JS对象，使用JSON.parse()方法

~~~
<script>
	var str = '{"name": "兮动人","age":22}';
	var obj = JSON.parse(str);
	console.log(obj);
</script>
~~~

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219104122809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjg0NjIx,size_16,color_FFFFFF,t_70) 

2、从JS对象转换为JSON字符串，使用JSON.stringify()方法

~~~
<script>
	var str = '{"name": "兮动人","age":22}';
	var obj = JSON.parse(str);
	console.log(obj);
        
	var jsonstr = JSON.stringify(obj);
	console.log(jsonstr);
</script>
~~~

## JSON格式规定

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219105012629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjg0NjIx,size_16,color_FFFFFF,t_70) 

1、Object对象

- 对象用大括号(“`{}`”）括起来，大括号里是一系列的“`名称/值对`”，请看概念图。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219105716462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjg0NjIx,size_16,color_FFFFFF,t_70)
- 两个并列的数据之间用逗号(“`,`”）隔开，注意两点:

1. 使用英文的逗号（“`,`”)，不要用中文的逗号(“`，`”)
2. 最后一个“`名称/值对`“之后不要加逗号

2、Array（数组）

- 数组表示一系列有序的值，用方括号(“`[]`”)包围起来，并列的值之间用**逗号**分隔，请看概念图。
  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219112001790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjg0NjIx,size_16,color_FFFFFF,t_70)
- 例如，以下的数组是合法的:

```html
[1,2,"three","four",true,false,null,[1,2],{"name":"兮动人"}]
```

3、名称/值对（name/value)

名称（Name）是一个字符串，**要用双引号括起来**，不能用单引号，也不能没有引号，这一点与JavaScript不同。

值的类型只有七种：<font color='red'> 字符串（string)、数值(number)、对象（object)、数组（array), true、false、null </font>。不能有这之外的类型，例如undefined、函数等。请看概念图。

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219112951313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjg0NjIx,size_16,color_FFFFFF,t_70) 

4、字符串

字符串（`string`）的规则如下:

1. 英文双引号括起来,不能用单引号，也不能没有。
2. 字符串中不能单独出现双引号（`”`）和右斜杠（“`\`")。
3. 如果要打双引号或右斜杠，需要使用“`右斜杠+字符`”的形式，例如`\”`和`\\`，其它的转义字符也是如此字符串的概念图。
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210219113102375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNjg0NjIx,size_16,color_FFFFFF,t_70)

- 转义字符

~~~
{
"string":"\\ \" "
}
~~~

# npm清除缓存

~~~
npm cache clean -f
~~~

# Map

~~~
 3 import java.util.HashMap;
 4 import java.util.Map;
 5 
 6 //map使用方法
 7 public class MapDemo {
 8 
 9     public static void main(String[] args) {
10         // map实例化
11         Map<String, Integer> maps = new HashMap<>();
12         
13         // 添加元素
14         maps.put("A", 10);
15         maps.put("B", 20);
16         maps.put("C", 30);
17         maps.put("D", 40);
18         maps.put("E", 50);
19         maps.put("F", 60);
20 
21         // 修改元素
22         maps.replace("F", 65);
23         
24         // 删除元素
25         maps.remove("E");
26         
27         // 遍历map-原始方法
28         for (Map.Entry<String, Integer> entry : maps.entrySet()) {
29             System.out.println("key:" + entry.getKey() + ";value:" + entry.getValue());
30         }
31         
32         // 遍历map-forEach方法（Java8新特性）
33         maps.forEach((k,v)->
34             System.out.println("key : " + k + "; value : " + v)
35             );
36         
37         // 查询元素
38         int f = maps.get("F");
39         System.out.println("F的值为:" +  f);
40 
41     }
42 }
~~~

## 遍历Map的四种方法

~~~
public static void main(String[] args) {
 
  Map<String, String> map = new HashMap<String, String>();
  map.put("1", "value1");
  map.put("2", "value2");
  map.put("3", "value3");
  
  //第一种：普遍使用，二次取值
  System.out.println("通过Map.keySet遍历key和value：");
  for (String key : map.keySet()) {
   System.out.println("key= "+ key + " and value= " + map.get(key));
  }
  
  //第二种
  System.out.println("通过Map.entrySet使用iterator遍历key和value：");
  Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();
  while (it.hasNext()) {
   Map.Entry<String, String> entry = it.next();
   System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
  }
  
  //第三种：推荐，尤其是容量大时
  System.out.println("通过Map.entrySet遍历key和value");
  for (Map.Entry<String, String> entry : map.entrySet()) {
   System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
  }
 
  //第四种
  System.out.println("通过Map.values()遍历所有的value，但不能遍历key");
  for (String v : map.values()) {
   System.out.println("value= " + v);
  }
 }
~~~

#### 1、 通过遍历键取值（效率低 ）

~~~
	Map<String,Object> map = new HashMap();
        map.put("a","1");
        map.put("b","2");
        map.put("c","3");
        for (String str : map.keySet()) {
            System.out.println("key:"+ str + "\tvalue:" + map.get(str));
        }
~~~

#### 2、for

for-each循环中使用entries来遍历这是最常见的并且在大多数情况下也是最可取的遍历方式，取键值都可以 

~~~
      for (Map.Entry<String, Object> entry : map.entrySet()) {
      	  System.out.println("key:"+  entry.getKey() + "\tvalue:" + entry.getValue());
      }
~~~

#### 3、迭代器遍历

~~~
	Iterator<Map.Entry<String, Object>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()){
            Map.Entry<String, Object> next = iterator.next();
            System.out.println("key:"+next.getKey()+"\tvalue:"+next.getValue());
        }
~~~

#### 4、直接遍历

> 直接遍历值，在forEach循环中遍历keys或values。如果只需key或value可以通过KeySet和values来实现遍历而不是用entryset。 

~~~
	for (Object o : map.values()) {
            System.out.println("value;"+o);
        }
~~~

#### 5、forEach

~~~
map.forEach((k,v)-> System.out.println("key:"+k+"\tvalue:"+v));
~~~

## Map常用方法

#### 1、添加-put

> put(K key,V value)
>
> putAll(Map<? extends K,? extends V> m)

##### put的返回值

Map集合的key是唯一的，如果使用put方法存储，<font color='red'>当key重复时，put方法返回原来的value值。否则，返回null。</font> 

#### 2、删除-clear()

> clear()：清空map中所有的元素
>
> remove(Object key)

#### 3、判断

> containsValue(Object value)
>
> containsKey(Object key)

#### 4、获取-get

> 1. get(Object key)
> 2.  Map.getOrDefault(Object key, V defaultValue)方法的作用是：
>      当Map集合中有这个key时，就使用这个key值；
>      如果没有就使用默认值defaultValue。 
> 3. size()：用于获取map中映射的对数
>
> 4. values()

![1650253997271](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650253997271.png)

#### 5、find

> find(key)：返回键为key的映射的迭代器

#### 6、erase

> erase()有两种用法：
>
> 删除单个元素：map.erase(it)：it为待删除元素的迭代器；  map.erase(key)：key为待删除的值
>
> 删除一个区间内所有的元素：map.erase(first,last)：删除[first,last)

# HashMap

### 常用方法

#### 1、put()

> 添加

![1650183000312](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183000312.png)

#### 2、get()

> 取值

![1650183180198](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183180198.png)

#### 3、isEmpty()

> 判断是否为空

![1650183245436](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183245436.png)

#### 4、containsKey

> 判断是否含有Key

![1650183301326](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183301326.png)

#### 5、containsValue

> 判断是否存在value

![1650183326822](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183326822.png)

#### 6、remove

> 删除

![1650183359357](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183359357.png)

#### 7、values()

> 获取所有value

![1650183384515](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183384515.png)

#### 8、size()

> 元素个数

![1650183410531](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183410531.png)

#### 9、keySet()

> 获取所有的key

![1650183491498](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183491498.png)

#### 10、entrySet()

> 显示所有的key和value

![1650183518356](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183518356.png)

#### 11、putAll()

> 全部添加

![1650183551377](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183551377.png)

#### 12、replace()

> 替换这个Key值的value

![1650183599812](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183599812.png)

#### 13、clear()

> 清空HashMap

![1650183634516](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183634516.png)

#### 14、clone()

> 克隆

![1650183652674](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183652674.png)

#### 15、putIfAbsent()

> 如果当前 Map 不存在键 key 或者该 key 关联的值为 null，那么就执行 put(key, value)；否则，便不执行 put 操作：（java8新增方法）

![1650183687344](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183687344.png)

#### 16、compute()

> 如果当前 Map 的value为xx时则值为xx否则为xx：（java8新增方法）compute 方法更适用于更新 key 关联的 value 时，新值依赖于旧值的情况

![1650183811304](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183811304.png)

![1650183838925](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650183838925.png)

#### 遍历map中的元素

![1650184197683](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650184197683.png)

![1650184032610](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650184032610.png)

<font color='red'>**新方法forEach**</font>

![1650184065053](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650184065053.png)

# StringBuilder

StringBuilder：字符串缓冲区

**字符串是常量，它们的值在创建之后不能更改，字符串缓冲区支持可变的字符串**

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200729192321962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhZGF0aQ==,size_16,color_FFFFFF,t_70) 

#### 1、构造方法

~~~
package demo01;
/*
java.lang.StringBuilder类：字符串缓冲区，可以提高字符串的效率
构造方法：
       StringBuilder()构造一个不带任何字符的字符串生成器，其初始容量为16个字符
       StringBuilder(String str)构造一个字符串生成器，并初始化为指定的字符串内容
*/
public class Demo02StringBuilder {
    public static void main(String[] args) {
        //空参数构造方法
        StringBuilder stringBuilder = new StringBuilder();
        System.out.println(stringBuilder);//默认是一个空字符串，什么都没有

        //带字符串的构造方法
        StringBuilder str = new StringBuilder();
        System.out.println("ab");//ab
    }
}

~~~

#### 2、成员方法

##### 1、append()

> **添加任意类型数据的字符串形式，并返回当前对象自身**

~~~
package demo01;
/*
StringBuilder的常用方法：
       public StringBuilder append(....),添加任意类型数据的字符串形式
       并返回当前对象自身。

*/
public class Demo03StringBuilder {
    public static void main(String[] args) {
        //创建StringBuilder对象
        StringBuilder bu = new StringBuilder();
        //使用append方法往StringBuilder中添加数据
        //append方法返回的是this,调用方法的对象bu,this==bu
       /* StringBuilder bu2 = bu.append("yiyi");
        System.out.println(bu);//yiyi
        System.out.println(bu2);//yiyi
        System.out.println(bu==bu2);//true:比较的是地址值*/

       //使用append方法无须接收返回值
        bu.append("y");
        bu.append("j");
        bu.append("9");
        bu.append("21");

        System.out.println( bu);//yj921
        /*
           链式编程
           格式：方法返回值是一个对象，可以继续调用方法
        */
        System.out.println("aa".toUpperCase().toLowerCase().toUpperCase());
        bu.append("abc").append(2).append(false).append('易');
        System.out.println(bu);//yj921abc2false易

    }
}

~~~

##### 2、toString()

> StringBuilder和String可以互相转换
>      String->StringBuilder：可以使用StringBuilder的构造方法
>          StringBuilder(String str)构造字符串生成器，并初始化为指定的字符串内容
>          StringBuilder->String可以使用StringBuilder中的toString()方法
>          public String toString(),将当前StringBuilder对象转换为String对象

~~~

public class Demo04StringBuilder {
    public static void main(String[] args) {
        //String->StringBuilder
        String str="jj";
        System.out.println("哈哈："+str);
        StringBuilder bu=new StringBuilder(str);
        //往StringBuilder中添加数据
        bu.append("world");
        System.out.println("String->StringBuilder："+bu);//jjworld
        // StringBuilder->String
        String s=bu.toString();
        System.out.println("StringBuilder->String："+s);//jjworld

    }
}
~~~

# Set集合

 ![img](https://img-blog.csdnimg.cn/20190808172013400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpdXhpYW95YW5nMTk5OQ==,size_16,color_FFFFFF,t_70) 

## HashSet

>  Hashset是Set接口较为常见的一个子类，<font color='red'>该子类的最大特点是不允许保存重复的元素，</font><font color='blue'>并且所有的内容都采用散列（无序）的方式进行存储。 </font>

创建HashSet对象

![1649554594047](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554594047.png)

### 方法

#### 1、add()

**添加元素**

![1649554157655](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554157655.png)

在上面的实例中，Runoob 被添加了两次，它在集合中也只会出现一次，**因为集合中的每个元素都必须是唯一的。** 

#### 2、contains()

**判断元素是否存在于集合中**

![1649554227166](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554227166.png)

#### 3、remove()

**删除集合中的元素**

![1649554253094](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554253094.png)

#### 4、clear()

**删除集合中所有元素**

![1649554286713](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554286713.png)

#### 5、size()

**计算HashSet中元素的数量，即HashSet的大小**

![1649554330476](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554330476.png)

#### 6、for

**迭代HashSet中的元素**

![1649554368740](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554368740.png)

#### 7、isEmpty()

**判断集合是否为空**

![1649554478819](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554478819.png)

#### 8、iterator迭代器

 **返回在此Set中的元素上进行迭代的迭代器**

![1649554665031](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554665031.png)

#### 9、addAll(集合)

**添加集合中的所有数据**

![1649554776646](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649554776646.png)

#### 10、retainAll(集合)

**获取同时在HashSet和集合中的数据，即两者的<font color='red'>交集</font>**

#### 11、removeAll(集合)

**删除HashSet中包含的所有的在集合中的数据**

## char和int型相互转换

### 1、int转char

> 1+‘0’=‘1’

### 2、char转int

> <font color='red'>char-'0'即可转化为char对应的int型</font>

# character类

 在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 以确定字符的类别（小写字母，数字，等等） 

### 1、构造方法

![1649818557819](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1649818557819.png)

### 2、判断方法

#### isDigit(char c)

> 判断指定字符是否为数字

#### isLetter(char c)

> 判断指定字符是否为字母

#### isalnum(char c)

> 判断字符是否为字母或者数字

#### isLowerCase(char c)

> 判断是否为小写字母字符

#### isUpperCase(char c)

> 判断是否为大写字母字符

#### isWhiteSpace(char c)

> 判断是否为空白字符

#### isLowerCase(char c)

> 判断是否为小写字符

#### isUpperCase(char c)

> 判断是否为大写字符

### 3、转换方法

#### toLowerCase(char c)

> 将字符转为小写字符

#### toUpperCase(char c)

> 将字符转为大写字符

#### toString(char c)

> 将单个字符转换为字符串形式

# ASCII 

 ![img](https://img-blog.csdnimg.cn/20181215211921530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTU2MzE4,size_16,color_FFFFFF,t_70) 

# List和数组的相互转换

## 数组转为List

### 1、 使用for循环把数组元素加进list 

![1650004162062](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650004162062.png)

### 2、Arrays.asList()

![1650004191871](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650004191871.png)

**asList()返回的列表大小固定**

### 3、Collections.addAll()

![1650004265093](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650004265093.png)

## List转数组

![1650004356230](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650004356230.png)

### 1、使用for循环

![1650004373305](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650004373305.png)

### 2、toArray()

![1650004390678](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650004390678.png)

## Set转为数组

#### toArray()

![1650197241308](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\1650197241308.png)